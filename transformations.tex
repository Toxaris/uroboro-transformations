% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{stmaryrd}

\newtheorem{lemma}{Lemma}
\newtheorem*{lemma*}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem*{definition*}{Definition}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

%\tableofcontents

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)}_{prg^0} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e}_{prg^0} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e}_{prg^0} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}_{prg^0}$ is short for $\langle eqn, \emptyset \rangle^{e}_{prg^0}$
\end{itemize}

Whenever $prg^0$ is left unspecified, it is assumed to be $prg$.

\item In the following, a function definition (or its equations) is called mixed if it contains a rule where the copattern is a destructor pattern and another rule where the copattern is a hole pattern.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des}_{prg} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \span\span \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \span\span \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \span\span \\
&\quad \textrm{ where } && fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig} \textrm{ if } q = fun(...)\\
&\quad && \tau.des(\tau_1, ..., \tau_k) : \sigma = \langle des \rangle^{sig} \textrm{ if } q = q'.des(...) \\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \span\span \\
& \langle `` q = t ", H \rangle^{extract\_des}_{prg} = \big\langle `` q = t ", H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\begin{framed}

For the alternative definitions of extraction functions used in the proofs, the following variant will be used.

$\langle `` q = t ", H \rangle^{extract\_des^s}_{prg} = \langle `` q = t ", H \rangle^{extract\_des}_{prg}$, if $q$ has $s$ destructors

$\langle `` q = t ", H \rangle^{extract\_des^s}_{prg} = \big\langle `` q = t ", H \big\rangle$, otherwise

\end{framed}

\item Define the extraction of the constructors of a copattern with exactly one destructor as follows:
\begin{alignat*}{3}
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns}_{prg} \\
&\quad = \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \\
&\quad \textrm{with } hname= \langle fun, des, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n, \tau'_1, ..., \tau'_k): \tau \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, \sigma.des(\tau'_1, ..., \tau'_k): \tau = \langle des \rangle^{sig} \\
&\quad heqn = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = t ", \\
&\quad \textrm{if } \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \\
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} = \big\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
&\langle `` q = t ", H \rangle^{extract\_patterns}_{prg} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\item In general, the implementations of defunctionalization and refunctionalization only work with programs which don't depend upon the order of their rules. Especially, that means that a function such as the following won't be transformed correctly:
\begin{lstlisting}

function foo where
  foo(zero()) = zero()
  foo(succ(zero()) = zero()
  foo(x) = x

\end{lstlisting}

Thanks are due to Yufei Cai and Paolo Giarrusso for this observation. Future work might add a transformation from rule-order dependent to rule-order independent programs.

\end{itemize}

\subsection{Common pre-transformations}

The transformations of this subsection are to be applied before either the defunctionalization or the refunctionalization as defined in the following sections.

\subsubsection{align\_patterns}

This step is necessary for destructor extraction to work correctly.

The purpose of $align\_patterns$ is to bring the patterns inside the copatterns within one function definition to the same level of specification. Consider the following example:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(x).d2() = t_3

\end{lstlisting}

Here, the third equation's left-hand side has a catch-all pattern (variable) in its first destructor call $d1$. The first destructor in the first and second equations' left-hand sides is also $d1$, but the patterns there are the constructors $c1()$ and $c2()$, respectively; they have a higher level of specification than the catch-all pattern. For destructor extraction to work correctly, the catch-all pattern therefore must be split. Such splitting steps are what $align\_patterns$ is doing. The result of $align\_patterns$ applied to the above function definition is:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(c1()).d2() = t_3
fun().d1(c2()).d2() = t_3

\end{lstlisting}

For programs, $align\_patterns$ is defined as follows.
\begin{alignat*}{4}
\langle prg \rangle^{align\_patterns} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ `` q' = t " ~ | ~ q' \in Q_q, `` q = t " \in eqns \} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}
with
\begin{equation*}
Q_{fun(p_1, ..., p_n)} = \{fun(p_1, ..., p_n)\}
\end{equation*}
and
\begin{equation*}
Q_{q^0.des(p_1, ..., p_k)} = \langle \overline{q^0} \rangle^{align_patterns}.des(p_1, ..., p_k)
\end{equation*}
with
\begin{equation*}
\overline{fun(p_1, ..., p_n)} = fun(\_, ..., \_)
\end{equation*}
and
\begin{equation*}
\overline{q^0.des(p_1, ..., p_k)} = \overline{q^0}.des(\_, ..., \_)
\end{equation*}
Here, the $\_$ represent holes which are used to describe generic forms of copatterns. For instance, one generic form of $fun(p_1, ..., p_n).des(p_1, ..., p_k)$ is $fun(\_, ..., \_).des(\_, ..., \_)$. The generic forms for a given copattern can be simply defined inductively, starting with setting $\_$ as being a generic form for any pattern.

For generic forms of copatterns, $align\_patterns$ is defined as follows. Let $q_\_ = fun(\_, ..., \_).des_1(\_, ..., \_)...des_k(\_, ..., \_)$, and $q^i_\_$ be the context that obtains by replacing the $i$-th hole in $q_\_$ with another kind of hole $[]$ used for plugging other contexts into it.
\begin{multline*}
\langle q_\_ \rangle^{align\_patterns} = \\
fun(\langle q^1_\_ \rangle^{a\_p}, ..., \langle q^{n_0}_\_ \rangle^{a\_p}).des_1(\langle q^{n_0 + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_1}_\_ \rangle^{a\_p})...des_k(\langle q^{n_{k-1} + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_k}_\_ \rangle^{a\_p})
\end{multline*}

Finally, $a\_p$ for such contexts is defined as follows.

\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \bigcup_{con} \{con(t_1, ..., t_n) ~ | ~ t_i \in \langle \mathcal{C}[con(\_, ..., \_, [], \_, ..., \_)] \rangle^{a\_p} \},
\end{equation*}
if $\exists$ lhs in $def$ with a prefix of the generic form $\mathcal{C}[con(\_, ..., \_)]$,
\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \{x\},
\end{equation*}
otherwise.

\subsubsection{split\_overlaps}

This step is also necessary for destructor extraction to work correctly.

The purpose of $split\_overlaps$ is to eliminate any overlapping patterns. Consider the following example:

\begin{lstlisting}

fun().d1() = t_1
fun().d1().d2() = t_2

\end{lstlisting}

When destructor extraction is applied to this to eliminate the destructor $d_2$ in the second line, the function definition of $fun$ in the transformed program looks as follows:

\begin{lstlisting}

fun().d1() = t_1
fun().d1() = h

\end{lstlisting}

Here, $h$ stands for the call to the helper equation. The resulting program is nondeterministic, even though the original wasn't. Such a case needs to be avoided, which is what $split\_overlaps$ achieves: It pre-transforms the original program in the following way:

\begin{lstlisting}

fun1().d1() = t_1

fun2().d1().d2() = t_2

\end{lstlisting}

The overlapping equations have been distributed to two different function definitions. This also requires the transforming of terms; basically, it has to be decided which of the new functions the term's function call represents: $fun().d1()$ transforms to $fun1().d1()$, and $fun().d1().d2()$ to $fun2().d1().d2()$.

TODO: define $split\_overlaps$

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix_d} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle `` q = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent definition for $elim\_multi\_des$, to be used for the simplified proofs.

$\langle prg \rangle^{elim\_multi\_des} := \langle prg \rangle^{elim\_multi\_des^m}_{prg}$

with $m$ the maximum number of destructors in any lhs of $prg$

$\langle prg \rangle^{elim\_multi\_des^s}_{prg^0} = \langle \langle prg \rangle^{extract\_helpers(extract\_des^s)}_{prg^0} \rangle^{elim\_multi\_des^{s-1}}_{prg^0}$, if $prg$ contains outer destructors

$\langle prg \rangle^{elim\_multi\_des^s}_{prg^0} = prg$, otherwise

\end{framed}
%%--

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_d} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent (for this fragment; contains unnecessary recursion which makes it identical to $unmix_r$) definition for $unmix_d$, to be used for the simplified proofs.

$\langle prg \rangle^{unmix_d} := \langle prg \rangle^{unmix_d^m}_{prg}$

with $m$ the maximum number of destructors in mixed function definitions

$\langle prg \rangle^{unmix_d^s}_{prg^0} = \langle \langle prg \rangle^{extract\_helpers(extract\_des^s, funs)}_{prg^0} \rangle^{unmix_d^{s-1}}_{prg^0}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which are mixed

$\langle prg \rangle^{unmix_d^s}_{prg^0} = prg$, otherwise

\end{framed}
%%--

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle_d} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):

$\langle prg \rangle^{disentangle_d} = \langle prg \rangle^{extract\_helpers(extract\_patterns)}$

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):

This uses the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $d^{core}$.

\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \langle && \{ def \in prg ~ | ~ def \textrm{ is codata def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has destr. pattern } \} \rangle^{d^{core}} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Technical note on constructor subsumption:

The input of $d^{core}$ in the definition above is actually not in its domain. This is because it can contain constructor calls. The following technical trick allows to transform such inputs as well: For the sake of $d^{core}$, subsume constructor names under function names (as if they were from the same syntactic domain). After the transformation, since names aren't changed (or when name changes are desired, the original name can still be retrieved), the subsumed constructor names (or their equivalents after a name change) are once again considered constructor names (from the original syntactic domain).

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle \langle prg \rangle^{extract\_outer\_des_r} \rangle^{unmix_r} \rangle^{r'}$

TODO: Refunc. has been corrected to first care about the
multiple destructor calls containing constructors. Implement these changes.

%%-- under construction
Extract outer destructor calls containing constructors:

$\langle prg \rangle^{extract\_outer\_des_r} = \langle \langle prg \rangle^{extract\_helpers(extract\_des, funs)} \rangle^{extract\_outer\_des_r}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which have multiple destructor calls containing constructors

$\langle prg \rangle^{extract\_outer\_des_r} = prg$, otherwise

%%--

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_r} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent definition for $unmix_r$, to be used for the simplified proofs.

$\langle prg \rangle^{unmix_r} := \langle prg \rangle^{unmix_r^m}_{prg}$

with $m$ the maximum number of destructors in mixed function definitions

$\langle prg \rangle^{unmix_r^s}_{prg^0} = \langle \langle prg \rangle^{extract\_helpers(extract\_des^s, funs)}_{prg^0} \rangle^{unmix_r^{s-1}}_{prg^0}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which are mixed

$\langle prg \rangle^{unmix_r^s}_{prg^0} = prg$, otherwise

\end{framed}
%%--

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle_r = step2 \circ step1$

$step1 = extract\_helpers(extract\_patterns)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars^-}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and this pattern in front of them;
\item $q^{-con}_{vars^+}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and the variable replacing this pattern in front of them;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars^-}$ and $q^{-con'}_{vars^+}$ are in the same way analogous to $q^{-con}_{vars^-}$ and $q^{-con}_{vars^+}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

\begin{framed}

Alternative, but equivalent definition for $step2$, to be used for the simplified proofs.

$\langle prg \rangle^{step2} := \langle prg \rangle^{step2}_{prg}$

$\langle prg \rangle^{step2}_{prg^0} = \langle \langle prg \rangle^{extract\_helpers(extract)}_{prg^0} \rangle^{step2}_{prg^0}$, if there is lhs in $prg$ of the form $fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n)$, $\exists p_i^j$: $p_i^j$ is constructor pattern

$\langle prg \rangle^{step2}_{prg^0} = prg$, otherwise

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract}_{prg} = \big\langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern}, prg \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract}_{prg} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

\end{framed}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first data type argument of a hole pattern):

This uses the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $r^{core}$.

Technical note: As $r^{core}$ doesn't allow destructor terms in its inputs, they have to be converted beforehand. This conversion is the same as that of $r$ for terms below, restricted to destructor terms. Call this conversion lifted to programs (in the way that all destructor terms on right-hand sides or as subterms of them are converted) $des\_conv$.

TODO: has been changed to allow for data type variables as first arguments. Implement this change along with removing the implementation for $split$.

\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \langle \langle && \{ def \in prg ~ | ~ def \textrm{ is data def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has no destr. pattern}, \\
& && &&\qquad \textrm{the first argument of the lhs isn't a variable } \} \rangle^{des\_conv} \rangle^{r^{core}} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern} \\
& && &&\quad \textrm{or where } n = 0 \textrm{ or where the first argument of the lhs is a variable} \} 
\end{alignat*}

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern or where $n = 0$ or where the first argument of the lhs is a variable \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Symmetries and alternative transformations}

A certain symmetry can be observed by laying the compositional sequences of the operations comprising defunctionalization and refunctionalization (preprocessing steps, then $d''$ or $r''$, respectively) next to each other:

\begin{alignat*}{4}
&\textrm{defunc.: } &&\textrm{ALL} \rightarrow  elim\_outer\_des \rightarrow && unmix_d \rightarrow disentangle_d && \rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{refunc.: } &&\textrm{ALL} \rightarrow && unmix_r \rightarrow disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

ALL stands for all of Uroboro, DEFUNC'ED and REFUNC'ED stand for the fragments of Uroboro the respective transformation results in. These two fragments can be transformed into one another as follows:

\begin{alignat*}{3}
&\textrm{REFUNC'ED} \rightarrow && elim\_outer\_des &&\rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{DEFUNC'ED} \rightarrow && disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

Observe that, when defunctionalizing REFUNC'EDs, only the first step $elim\_outer\_des$ of the preprocessing steps above is needed. Symmetrically, the first step $unmix_r$ of the preprocessing steps can be omitted when refunctionalizing DEFUNC'EDs.

From this symmetry one can derive an alternative defunctionalization and refunctionalization by using the respective other transformation:

$\langle prg \rangle^{d_{alt}} = \langle \langle prg \rangle^r \rangle^{elim\_outer\_des} \rangle^{d''}$

$\langle prg \rangle^{r_{alt}} = \langle \langle \langle prg \rangle^d \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

In both cases, one step of the original transformation can be saved by the above observed connection between REFUNC'ED and DEFUNC'ED. But this comes at the expense of having to run the entire refunctionalization before defunctionalizing and vice versa.

\section{Fragments for transformations}

This section identifies the relevant input fragments for the transformation steps given in section 2 and 3. Those are chosen such that the image of one step (under its relevant input fragment) is a subset of the input fragment for the next step. For each respective follow-up fragment, this can be seen directly in the definition of the previous transformation.

It can therefore be presumed that the input of a certain step comes only from its respective relevant input fragment. This will be used in the proofs of semantic preservation for the transformations steps in section 7.

Common syntax for the fragments:\\
$\sigma, \sigma_i, \tau, \tau_j = $ type names\\
$con = $ constructor names\\
$des = $ destructor names\\
$fun = $ function names\\
$x, y, x_i, y_j = $ variable names\\
$prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*$\\
$ddef ::= \textbf{data } \sigma \textbf{ where } csig^*$\\
$coddef ::= \textbf{codata } \sigma \textbf{ where } dsig^*$\\
$csig ::= con(\tau^*): \tau$
$dsig ::= \sigma.des(\tau^*): \tau$
$s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)$\\

A fragment will be defined by giving the respective EBNF rule for $fdef$, which stands for function definitions.

The entire language Uroboro is defined by giving the following rule for $fdef$:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for defunc.}

This subsection gives the relevant input fragments for the defunctionalization steps. The domain for the first step, $elim\_multi\_des$, is simply the set of all Uroboro programs. Thus the entire defunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Mixed fragment}

This is the input fragment for $unmix_d$. Informally, it consists of (co)data definitions and function definitions that may not contain multiple destructor calls in their copatterns but are otherwise unrestricted. 

Formal rules for function definitions:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ fun(p^*).des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_d$. Informally, it consists of (co)data definitions and function definitions that may neither contain multiple destructor calls nor be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(p^*).des(p^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Actual defunc. fragment}

This is the input fragment for actual defunctionalization, i.e. $d''$. Informally, it consists of (co)data definitions and function definitions where each satisfies the following property: It either is (1) in already defunctionalized form, i.e. the left-hand sides of its rules all are hole copatterns, or (2) are in the form that the core defunctionalization from the paper of Rendel, Trieflinger, and Ostermann can be applied to, i.e. the left-hand sides of its rules all are destructor copatterns, and these copatterns do not contain any constructor pattern matching.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(x^*).des(y^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for refunc.}

This subsection gives the relevant input fragments for the refunctionalization steps. The domain for the first step, $unmix_r$, is simply the set of all Uroboro programs. Thus the entire refunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_r$. Informally, it consists of (co)data definitions and function definitions that may not be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(p^*) = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Unsplit fragment}

This is the input fragment for $split$. Informally, it consists of (co)data definitions and function definitions where each may not be mixed and must satisfy the following property: For every copattern $q$ that is the left-hand side of one of its rules it holds that: Either $q$ is (1) a hole pattern, then it may contain at maximum one constructor application, and this at the left-most outer-most position, or $q$ is (2) a destructor pattern, then it must not contain any constructor applications.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$defeqn ::= dfeqn1 ~ | ~ dfeqn0$\\
$dfeqn1 ::= fun(con(x), y^*) = t$\\
$dfeqn0 ::= fun(x^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$

\subsubsection{Actual refunc. fragment}

This is the input fragment for actual refunctionalization, i.e. $r''$. Informally, it is identical to the last fragment with the following difference: Where it said ``at maximum one constructor application" in the last section, for this fragment ``exactly one constructor application" has to hold. As such, every one of its function definitions is either (1) already in refunctionalized form, i.e. the left-hand sides of its rules contain no constructor applications and they are either all destructor patterns or the function has no arguments or its first argument has codata type, or (2) core refunctionalization (Rendel, Trieflinger, Ostermann) can be applied to it.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef $\\
$dfdef ::= \textbf{function } fun(\sigma, \tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(con(x), y^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } copeqn^* ~ | ~ nopeqn^*$\\
$copeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$\\
$nopeqn ::= fun(x^*) = t$

\section{Values}

This section formalizes the notion of value for Uroboro. Unlike in the usual case, but not unlike other languages with copattern such as that of Abel et al., some values can be reduced. Not all reductions of values are preserved by the transformations above. 

As is the case with the language of Abel et al., whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from `Copatterns" (Abel et al.), section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

%%-- under construction

The value judgement makes use of a ``no-match" judgement. This judgement is complementary to the pattern matching judgement in the next section.

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Con/Card}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Card}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Des/Card}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}

%%--

\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction uses the evaluation context $\mathcal{E}$ given below, which in turn requires the syntax of the complete Uroboro.

\begin{alignat*}{2}
& v  = &&\textrm{value, that is } \vdash_v v \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}

Call a subterm of a term $fun(\overline{t}).\overline{des(\overline{t'})}$ \textit{reduction-relevant}, iff it is one of the $t_i$ or $t'_{i, j}$. The ``Subst" rule given below takes precedence over the ``Cong" rule, that is, whenever both could apply, only the ``Subst" rule may be used.

\begin{prooftree}
\AxiomC{$t \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

if the reduction-relevant subterms of $t$ are values:
\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[\sigma]$}
\end{prooftree}

Write $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

\subsection{As an extension of (Co)Data Fragment semantics}

The properties of the reductions and the de- and refunctionalization transformations of the paper of Rendel, Trieflinger, and Ostermann are used for the proofs of the next section. The domain of their defunctionalization is what they call the Codata Fragment, and that of refunctionalization the Data Fragment. Their semantic properties can be used in the proofs because, for well-typed programs and limited to terms which have copattern coverage for all of their subterms in the program (TODO: define this more precisely), this work's reducibility notion is a conservative extension of either the Data Fragment's notion or the Codata Fragment's notion. When the well-typedness and coverage conditions are dropped, the reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsubsection{Data Fragment}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment (Figure 6b), as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that it is not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from last section.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b)
\begin{equation*}
u, v ::= con(v^*),
\end{equation*}
while the V\textsubscript{CodTFun} can never be applied. This is because a function in the Data Fragment can only have data type unless it doesn't have a type defined in the program at all, as types can only be added by data definitions.

\subsubsection{Codata Fragment}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. It will be demonstrated why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if" direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. That the second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if" direction. By the rules of the judgement, a value can also be a destructor application if it has codata type and doesn't match any rule of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage for all subterms of the input term, since those are the only ones that can be relevant for the value judgement in the one-step reduction.

\section{Semantics preservation}

TODO: The bisimulation statement presupposes that the one-step reduction relation is a partial function. Change it accordingly.

In this section it is shown that the transformations above preserve the semantics of programs in a kind of weak bisimulation. Precisely, for all transformations indicated by angular brackets, it holds for all closed input terms $s, t$ and all programs $prg$ that:

\begin{itemize}
\item $s \longrightarrow_{prg} t \implies \langle s \rangle  \longrightarrow^*_{\langle prg \rangle} \tilde{t}$ for a $\tilde{t} \sim t$ (1a)

\item for all terms $s'$ in the sequence of (1a), with the exception of the last ($t'$), it is $s \sim s'$ (1b)

\item if $s \not\sim t$: $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \implies \tilde{s} \longrightarrow_{prg} \tilde{t}$ for $\tilde{s} \sim s, \tilde{t} \sim t$ (2)

\end{itemize}

The equivalence relation $\sim$ for terms is different for each extraction function, and always meant with respect to a program $prg$. Its purpose is to capture the ``sameness" of some terms that arises from the ``splitting" of a function definition into multiple definitions in the transformation. This notion of equivalence for terms can be extended to copatterns and patterns, since each of them is syntactically identical to a term.

For an extraction function, the corresponding equivalence relation is defined as the smallest equivalence relation for which some general and some specific properties hold. The general properties are shared by all equivalence relations.

The general properties are the following:

\begin{itemize}

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $con(t_1, ..., t_n) \sim con(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $fun(t_1, ..., t_n) \sim fun(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{0, ..., n\}$: $t_0.des(t_1, ..., t_n) \sim \widetilde{t_0}.des(\widetilde{t_1}, ..., \widetilde{t_n})$

\end{itemize}

The specific properties are given in the respective section for the proofs of the extraction function properties of the extraction function.

%%- old bisim. statements
%\begin{itemize}
%\item $s \longrightarrow_{prg} t \implies \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle$ (1)
%
%\item the reduction sequence from $\langle s \rangle$ to $\langle t \rangle$ in (1), contains no terms, except possibly $\langle s \rangle$ and $\langle t \rangle$, that typecheck against $prg$ (2)
%
%\item when $s, t$ typecheck against $prg$: $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \implies s \longrightarrow_{prg} t$ (3)
%
%\item there is no infinite reduction sequence with respect to $\langle prg \rangle$ containing only terms that don't typecheck in $prg$ (4)
%
%\end{itemize}
%%-

When one-step reduction is viewed as state transition, with $prg$ and $\langle prg \rangle$ standing for two different transition systems, the statements above describe the precise kind of their bisimilarity.

TODO: reformulate to fit new bisim. statements

%%- old bisim. explanation
%Statements (1) and (2) stand for the direction from $prg$ to $\langle prg \rangle$. (1) means that every state of $prg$ has a corresponding state in $\langle prg \rangle$, but there can be internal states (intermediate in the transition). (2) guarantees that these internal states are in fact internal, that is, they have no corresponding states in $prg$.
%
%Statement (3) stands for the direction from $\langle prg \rangle$ to $prg$. It means that when a state in $\langle prg \rangle$ has a corresponding state in $prg$, it behaves like it, that is, when there is a transition from it to another state with a corresponding state, there also is a transition between the corresponding states.
%
%Statement (4) is about a special property of internal states: there cannot be an infinite sequence of transitions between only internal states. Especially, this accounts for the fact that internal actions might sometimes apply to a state that corresponds to one in $prg$ but not lead to another such corresponding state. This case cannot be altogether avoided by all of the transformations, but at least be made less problematic by not allowing an infinite progression of internal transitions only. This way, it can be determined in $\langle prg \rangle$, simply by going through the internal transitions and arriving at a final internal state, that the original starting state in $prg$ doesn't lead to any other state.
%%-

(1a) is always shown in the following way:

Suppose that: $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, \\
show that: there exist derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} t_1, t_1 \longrightarrow_{\langle prg \rangle} t_2, ..., t_{n-1} \longrightarrow_{\langle prg \rangle} \langle t \rangle$, respectively

For some transformations, strong bisimulation holds, precisely, the following holds for all closed terms $s, t$:

$ s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$

Strong bisimulation implies the weak kind of bisimulation as given by (1a), (1b) and (2). It is always shown in its stead whenever possible. The proof of each side of strong bisimulation proceeds analogously to that of (1a) (but always with $n = 1$).

It's always assumed that the program that is transformed is well-typed. It also is assumed that no term is stuck, i.e., it can either be reduced or is a value.

Note/TODO: The well-typedness of the transformed program will be shown in a separate section.

For the proofs of these properties the following lemmas and definitions will be needed:

\begin{lemma}[Inversion lemma for pattern matching]

Let $\mathcal{D}$ be a derivation of $t =^? q \searrow \sigma$.

\begin{enumerate}

\item If $q = x$ then $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\item If $q = con(p_1, ..., p_n)$ then $t = con(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = fun(p_1, ..., p_n)$ then $t = fun(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = q'.des(p_1, ..., p_n)$ then $t = t'.des(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t =^? q \searrow \sigma$}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\end{enumerate}

\begin{proof}~

\begin{enumerate}

\item A matched pattern that is a variable doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Var}. Thus the derivation can only be the result of the application of this single rule.

\item A matched pattern that is a constructor application doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Con}. Thus the derivation can only be the result of the application of this rule, and of the rules leading to the premises of this rule.

\item Analogous to 2.

\item Analogous to 2.

\end{enumerate}

\end{proof}

\end{lemma}

Write $\langle prg \rangle$ for $\langle prg \rangle^{extract\_helpers(e, funs)}$ when $e, funs$ are arbitrary or clear from the context. Write $\epsilon_r, \zeta_r$ for the transformed original and the auxiliary equation in $\langle r \rangle^e$ whenever there is such an auxiliary equation. Otherwise, it is always the case that $\langle r \rangle^e$ contains only $r$ itself.

\begin{definition*}[Extraction function properties]
An extraction function $e$ is said to satisfy the extraction function properties iff

\begin{enumerate}
\item $\forall r \not\in Rules(\langle prg \rangle): s \longrightarrow^{\textrm{Subst}_r}_{prg} t \implies s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \sim t$.

\item If $s$ reduces in $prg$, so does every $\widetilde{s} \sim s$ in $\langle prg \rangle$.

\item For every equation $r$ of $prg$:
\begin{enumerate}
\item A possible $\epsilon_r$ reduces (non-strictly) the number of constructors and that of destructors, and reduces strictly either the number of constructors or that of destructors, or both.

\item The equations in $\langle r \rangle^e$ preserve the property of a term that all of its reduction-relevant subterms are values.
\end{enumerate}

\end{enumerate}

\end{definition*}

\begin{lemma}
\label{lemma3}

Let $e$ be an helper extraction function that fulfils the extraction function properties. Write $\langle prg \rangle$ short for $\langle prg \rangle^{extract\_helpers(e)}$. Let $s$ be a closed term.

If $s$ is irreducible in $prg$, then there is a reduction sequence $s \longrightarrow^*_{\langle prg \rangle} s_v$, where $s_v \sim s$ is irreducible in $\langle prg \rangle$.

\begin{proof}

First, note that by the definition of $extract\_helper$, each equation in $\langle prg \rangle$ results from the application of $e$ to an equation $r$ in $prg$; specifically, it is contained in $\langle r \rangle^e$. It can thus be distinguished between two different types of equations in $\langle prg \rangle$, those are given below.

Now, the proof proceeds by induction on the structure of $s$.

Suppose the lemma holds for the immediate subterms of $s$ (the induction hypothesis). This lets us reduce the immediate subterms of $s$ to equivalent values (in $\langle prg \rangle$) first (from left to right). Let $s^0$ be the result of these reductions; it is equivalent to $s$. Let
\begin{equation*}
s^0 \longrightarrow s^1 \longrightarrow ... \longrightarrow s^i \longrightarrow ...
\end{equation*}
be the possibly infinite reduction sequence starting with $s^0$. There are exactly two types of equations in $\langle prg \rangle$:
\begin{itemize}
\item Type 1: Those which do ``actual work" because they are the equivalent of an equation in $prg$. Precisely, such an equation $r'$ has the property that there is an $r$ of $prg$ such that: $q_{r'} \sim q_r$ and $t_{r'} \sim t_r$.

\item Type 2: Those which are ``helper steps" used to provide for the syntactic changes of the transformation. Such an equation $r_h$ doesn't do any actual ``semantic change" to the term, precisely, it has the property $q_{r_h} \sim t_{r_h}$.
\end{itemize}
It will now be shown that each reduction step
\begin{equation*}
s^i \longrightarrow s^{i+1}
\end{equation*}
in the sequence above can only use equations of Type 2. Note that from this it immediately follows that $s^{i+1} \sim s^i$. The statement is proved by induction on $i \in \mathbb{N}$:
\begin{itemize}
\item $i = 0$: The immediate subterms of $s^0$ are values. Thus it can only reduce by the ``Subst" rule. Suppose there was an equation $r'$ in $\langle prg \rangle$ of Type 1, with an equivalent $r$ in $prg$, such that $s^0$ matched $q_{r'}$. $s \sim s^0$ is a value in $prg$, thus it doesn't match $r$. Especially, this means that $s \neq q_r[\sigma]$ for \textit{every} substitution $\sigma$. For terms of $prg$, it holds that, if they aren't equal, they aren't equivalent, thus $s \not\sim q_r[\sigma]$ for every $\sigma$. But, as supposed, $s^0$ matches $q_{r'}$, and thus $s^0 = q_{r'}[\sigma]$ for some $\sigma$. Since $r'$ has Type 1, it is $q_{r'} \sim q_r$, and from this it follows that $s \sim s^0 \sim q_r[\sigma]$, a contradiction.

\item $i = i' + 1$: Each previous reduction step used the ``Subst" rule for an equation of Type 2. By the third common extraction function property, these preserve the property of a term that its immediate subterms are values. Thus $s^i$ reduces by the ``Subst" rule, as well. Suppose there was an equation $r'$ in $\langle prg \rangle$ of Type 1, with an equivalent $r$ in $prg$, such that $s^i$ matched $q_{r'}$.
By the induction hypothesis, it is $s^{i} \sim s^{i'}$. Further, it is $s^i \sim s^{i'} \sim ... \sim s^0$. $s^0$ doesn't match $q_{r'}$, and it is $s^0 \neq q_{r'}[\sigma]$ for every $\sigma$ and $s^0 \not\sim q_{r'}[\sigma]$. But, as supposed, $s^i$ matches $q_{r'}$, and thus $s^i = q_{r'}[\sigma]$ for some $\sigma$. It follows that $s^0 \sim s^i = q_{r'}[\sigma]$, a contradiction.

\end{itemize}

Finally, it needs to be shown that the reduction sequence given above is in fact not infinite. That is, it results in a value. That this value is equivalent to the start has already been shown. It has also been shown that each step uses only an equation of Type 2. By the common extraction function property 4, these have the additional property that they reduce the ``pattern weight", which is defined to mean that the number of copatterns appearing in the term, or that of patterns, or both added together, has decreased, while neither the number of copatterns nor that of the patterns has increased. But this ``pattern weight" can obviously not decrease infinitely, which means that the number of equations used must be finite.

\end{proof}

\end{lemma}

\subsection{Proofs of (1a) and (1b)}

Call the bisimulation statements (1a) and (1b) combined statement (1). It holds for the transformations $elim_multi_des$, $unmix$ and $disentangle$ of both de- and refunctionalization by virtue of Proposition 1 below. This is because they are all defined as a recursive concatenation of $extract\_helpers(e)$ for some helper extraction function $e$ with the extraction function properties, and don't affect input terms. The relevant helper extraction functions are $extract\_des$, $extract\_patterns$, and $extract$, and their extraction function properties are proved in the subsection that follows Proposition 1.

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties. Then let $trans$ be a transformation which doesn't affect input terms, and for programs, is defined as $extract\_helpers(e)$.

Statement (1) holds for $trans$.

\begin{proof}

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$s =^? q_r \searrow \sigma$}
\RightLabel{\scriptsize Subst with $r \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow t_r[\sigma]$}
\end{prooftree}

with $t_r[\sigma] = t$; the reduction-relevant subterms of $s$ are values. The transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

When $r$ is also an equation of $\langle prg \rangle$, it suffices to (a) by Lemma ?, reduce the reduction-relevant subterms of $s$ to equivalent values, and then (b) apply the ``Subst" rule for $r$ to get a reduction to a term equivalent to $t$.

When, otherwise, $r$ is not an equation of $\langle prg \rangle$, we have the desired sequence by the first extraction function property.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s^0 \longrightarrow t^0$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0] \longrightarrow \mathcal{E}[t^0]$}
\end{prooftree}

with $\mathcal{E}[s^0] = s$ and $\mathcal{E}[t^0] = t$. By the induction hypothesis, we have a reduction sequence $s^0 \longrightarrow_{\langle prg \rangle} \widetilde{t^0} \sim t^0$.

It suffices to (a) by Lemma ?, reduce the reduction-relevant subterms of $\mathcal{E}[s^0]$ left of $s^0$ to equivalent values, and then (b) use the ``Cong" rule, with the new context $\widetilde{\mathcal{E}}$ (around $s^0$) yielded by this, on the reduction sequence obtained from the induction hypothesis.

\end{enumerate}

\end{proof}

\end{proposition}

\subsubsection{Proofs for extraction function properties}

\subsection*{extract\_des:}

Specific property for the equivalence relation belonging to $extract\_des$:
\begin{equation*}
q[\sigma] \sim \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg^0 \rangle^{autogen}(\langle q \rangle^{vars})[\sigma]
\end{equation*}
iff $q.des_1(\overline{p})$ is a lhs in $prg$ such that its equation $r$ is actually transformed to $\epsilon_r$, $\zeta_r$.

\begin{lemma*}

$extract\_des$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. From the definition of $extract\_helpers$ and $extract\_des$ we thus know that $q_r$ is a destructor copattern. By inversion, we know the form of $s$ is $s^0.des(\overline{t})$ The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s^0_{subv}.des(\overline{t}) = q_{\epsilon_r}[\sigma_\epsilon].des(\overline{t})\\
&\longrightarrow &t_{\epsilon_r}.des(\overline{t})\\
&\longrightarrow^*  &t_{\epsilon_r}.des(\overline{t_v}) = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r} =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s^0$ to equivalent values. We have such a sequence by Lemma ?, because $s^0$ matches $q_{\epsilon_r}$, by the definition of $\epsilon_r$ and because $s = s^0.des(\overline{t})$ and $s$ matches $q_r$.

Similarly, the second multi-step part is concerned with reducing the $\overline{t}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.
\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s^0_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s^0_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0_{subv}] \longrightarrow \mathcal{E}[t_{\epsilon_r}[\sigma_\epsilon]]$}
\end{prooftree}
with $\mathcal{E} = [].des(\overline{t})$. $s^0_{subv}$ matches $q_{\epsilon_r}$ because $s = s^0.des(\overline{t})$ and $q_r = q_{\epsilon_r}.des(\overline{p})$ and $s$ matches $q_r$. The two sides of $\epsilon_r$ are equivalent by definition, thus $s^0_{subv}$ and $t_{\epsilon_r}[\sigma_\epsilon]$ are, too. It remains to be shown (a) why $\mathcal{E}$ is actually an evaluation context, and (b) why no ``Subst" rule can take precedence over the ``Cong" rule as used in the derivation.

\begin{enumerate}
\item $\mathcal{E}$ is derived as given below.
\begin{prooftree}
\AxiomC{}
\RightLabel{\scriptsize Hole}
\UnaryInfC{$[]$}
\RightLabel{\scriptsize Frame/Des}
\UnaryInfC{$[].des(\overline{t})$}
\end{prooftree}

\item The only extension of $s^0_{subv}$ within $s^0_{subv}.des(\overline{t})$ is $s^0_{subv}.des(\overline{t})$ itself. Suppose this term matched a lhs of $\langle prg \rangle$. Each equation of $\langle prg \rangle$ either appears identical in $prg$, or there are $\epsilon_{r'}$ and $\zeta_{r'}$ in a $\langle r' \rangle^e$ for an $r'$ of $prg$.

The first case can be excluded, since (a) the function definition of $r'$ is the same as that of $r$, and this function definition has been affected since $r$ was actually transformed, and (b) $r'$ is transformed to $\epsilon_{r'}$ and $\zeta_{r'}$ because $q_{r'}$ is a destructor copattern since it is a matched by $s^0_{subv}.des(\overline{t})$.

The second case can also be excluded, because this would mean that there are overlapping patterns in the function definition, but these were eliminated by the pre-transformation.

\end{enumerate}

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
The relevant subterms of $s^0_{subv}$ were values, thus also the terms that $\sigma_\epsilon$ substituted with. And $t_{\epsilon_r}[\sigma_\epsilon]$ contains no reduction-relevant subterms, as well. $t_[\epsilon_r]$ matches $q_{\zeta_r}$ by the definition of $\epsilon_r$ and $\zeta_r$. Because $t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\zeta]$ is equivalent to $s = q_r[\sigma]$, $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta] \sim t_r[\sigma_\zeta]$.

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_des$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg^0 \rangle^{autogen}(\langle q \rangle^{vars})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has exactly one top-level destructor call ($des_1$).

If it has more than one top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a  possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

Finally, if $\widetilde{s}$ had no top-level destructor calls, i.e., it is an application of the helper function, then there would exist equations in $prg$ which overlap. To see this, consider the form of $s \sim \widetilde{s}$: It matches a $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, as stated above. As a consequence, $q$ and $q.des_1(\overline{p})$ overlap. But this is prevented by the pre-transformation.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_des$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract\_des$.

\end{proof}

\end{lemma*}

\begin{lemma*}

Let $prg$ and all programs $prg^i$ in the intermediate transformation steps from $prg^0$ to $prg$ don't contain overlapping lhss, especially, this means these programs are deterministic. Then neither does $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(e, funs)}$, for arbitrary $funs$, $e = extract\_des^s$ with $s > 0$.

\begin{proof}

Consider equations $r, r'$ of $prg$; their transformation results will be compared.

First, consider the case that the number of destructors of both $r$ and $r'$ is $< s$; their transformation result is $r$ and $r'$, respectively. We already know that these don't overlap.

Second, consider the case that the number of destructors of both $r$ and $r'$ is $s$; their transformation result is $\epsilon_r, \zeta_r$, and $\epsilon_{r'}, \zeta_r$, respectively. Because of $align\_patterns$, $r$ and $r'$ also have the same level of pattern specification. It follows that, by their definition, $\epsilon_r$ and $\epsilon_{r'}$ are the same, and that $\zeta_r$ and $\zeta_{r'}$ only overlap if $r$ and $r'$ do, which would contradict the assumption. $\zeta_r$ and $\epsilon_{r'}$, or $\zeta_{r'}$ and $\epsilon_r$, respectively, can't overlap, since, by their definition, their function names are different.

Third, consider the case that the number of destructors of $r$ is $s$ and that of $r'$ is $< s$ (or the other way around, assumed w.l.o.g.). This means that $r'$ needs to be compared with the transformation result $\epsilon_r, \zeta_r$ of $r$. Destructors are never extracted out of function definitions with auto-generated names, i.e., names fresh in $prg^0$. It follows that $\zeta_r$ and $r'$ can't overlap since their function names must be different. When a term matches both $q_{\epsilon_r} < q_r$ and $q_{r'}$, $q_r$ and $q_{r'}$ overlap, contrary to assumption.

\end{proof}

\end{lemma*}

\subsection*{extract\_patterns:}

Specific property for the equivalence relation belonging to $extract\_patterns$:
\begin{equation*}
fun(\overline{p}).des(\overline{p'})[\sigma] \sim \langle fun, des, prg^0 \rangle^{autogen}(\overline{p}, \overline{p'})[\sigma]
\end{equation*}
iff $fun(\overline{p}).des(\overline{p'})$ is a lhs in $prg$ such that its equation $r$ is actually transformed to $\epsilon_r$, $\zeta_r$.

\begin{lemma*}

$extract\_patterns$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by Lemma ?.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with all patterns replaced by variables. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with all variables replaced by the patterns of $q_r$. $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_patterns$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle fun, \overline{des}, prg^0 \rangle^{autogen}(\overline{x}, \overline{x'})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q_r = fun(\overline{x}.\overline{des(\overline{x'})}$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_patterns$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract\_patterns$.

\end{proof}

\end{lemma*}

\begin{lemma*}

Let $prg$ and all programs $prg^i$ in the intermediate transformation steps from $prg^0$ to $prg$ be deterministic. Then so is $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_patterns, funs)}$, for arbitrary $funs$.

\begin{proof}

Consider an atomic step of the extraction, i.e, the extraction out of a single equation. The lemma follows by combining the proofs for the atomic steps. It suffices to consider such steps which actually change the equations, i.e., they replace an equation $r$ of $prg$ with $\epsilon_r$ and $\zeta_r$. The lhss of $\epsilon_r$ and $\zeta_r$, and their prefixes, can't overlap, since they have different function names by definition. Now, consider another equation $r'$, contained in both the program before the atomic step transformation and afterwards.

First, compare $q_{r'}$ to $q_{\epsilon_r}$: $q_{\epsilon_r}$ is simply $q_r$ with all of its patterns replaced by variables, thus, a term that matches $q_{\epsilon_r}$ also matches $q_r$. If it also matched $q_{r'}$, the program before the atomic step transformation would be nondeterministic, contrary to assumption.

Second, compare $q_{r'}$ to $q_{\zeta_r}$: The lhs of $\zeta_r$ results from the extraction out of an $r^*$ of a $prg^i$. It is also contained in all predecessors of $prg^i$, that is, all $prg^k$ with $k \leq i$. The same holds for $r'$ with an $r^\#$, for a $prg^j$ and its predecessors. From a term that matches $q_{r'}$, a term can be constructed that matches $r^\#$, and the same for $q_{\zeta_r}$ and $r^*$. Because this construction is the same in both cases, when a term matches both $q_{r'}$ and $q_{\zeta_r}$, there is a term that matches both $q_{r^\#}$ and $q_{r^*}$. And these lhss are found together in one program, either in $prg^i$ when $i \leq j$, or in $prg^j$, otherwise. But this would contradict the assumption that all these programs were deterministic.

\end{proof}

\end{lemma*}

\subsection*{extract:}

Specific property for the equivalence relation belonging to $extract\_patterns$:
\begin{equation*}
q^{-con'}[\sigma] \sim \langle \langle q^{-con'} \rangle^{name\_pattern}, prg^0 \rangle^{autogen}(q^{-con'}_{vars^+})[\sigma]
\end{equation*}
iff $q$ is a lhs in $prg$ such that its equation $r$ is actually transformed to $\epsilon_r$, $\zeta_r$.

\begin{lemma*}

$extract$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by Lemma ?.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with one pattern replaced by a variable and put in front of the other patterns. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with the variable in front replaced by the respective pattern of $q_r$ (that, in $q_{\epsilon_r}$, was replaced by a variable and put in front). $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle \langle (q_r)^{-con} \rangle^{name\_pattern} \rangle^{autogen}((q_r)^{-con}_{vars^+})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q_r$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract$.

\end{proof}

\end{lemma*}

\begin{lemma*}

Let $prg$ and all programs $prg^i$ in the intermediate transformation steps from $prg^0$ to $prg$ be deterministic. Then so is $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract, funs)}$, for arbitrary $funs$.

\begin{proof}

Consider an atomic step of the extraction, i.e, the extraction out of a single equation. The lemma follows by combining the proofs for the atomic steps. It suffices to consider such steps which actually change the equations, i.e., they replace an equation $r$ of $prg$ with $\epsilon_r$ and $\zeta_r$. The lhss of $\epsilon_r$ and $\zeta_r$, and their prefixes, can't overlap, since they have different function names by definition. Now, consider another equation $r'$, contained in both the program before the atomic step transformation and afterwards.

First, compare $q_{r'}$ to $q_{\epsilon_r}$: $q_{\epsilon_r}$ is simply $q_r$ with one of its patterns replaced by variables, thus, a term that matches $q_{\epsilon_r}$ also matches $q_r$. If it also matched $q_{r'}$, the program before the atomic step transformation would be nondeterministic, contrary to assumption.

Second, compare $q_{r'}$ to $q_{\zeta_r}$: The lhs of $\zeta_r$ results from the extraction out of an $r^*$ of a $prg^i$. It is also contained in all predecessors of $prg^i$, that is, all $prg^k$ with $k \leq i$. The same holds for $r'$ with an $r^\#$, for a $prg^j$ and its predecessors. From a term that matches $q_{r'}$, a term can be constructed that matches $r^\#$, and the same for $q_{\zeta_r}$ and $r^*$. Because this construction is the same in both cases, when a term matches both $q_{r'}$ and $q_{\zeta_r}$, there is a term that matches both $q_{r^\#}$ and $q_{r^*}$. And these lhss are found together in one program, either in $prg^i$ when $i \leq j$, or in $prg^j$, otherwise. But this would contradict the assumption that all these programs were deterministic.

\end{proof}

\end{lemma*}

\subsection{Proofs of (2)}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties. Then let $trans$ be a transformation which doesn't affect input terms, and for programs, is defined as $extract\_helpers(e)$.

Statement (2) holds for $trans$.

\begin{proof} By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

By the extraction function properties, since $s \not\sim t$, it can only be the case that $`` q = s' " = \zeta$ for the $\zeta$ in $\langle r \rangle^e$. Choose $\widetilde{s} := q_r[\sigma]$ and $\widetilde{t} := t_r[\sigma]$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$. Because $\mathcal{E}[s'] \not\sim \mathcal{E}[t']$, it follows that $s' \not\sim t'$.

By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. Apply the congruence rule to get the desired
\begin{equation*}
s = \mathcal{E}[s'] \sim \widetilde{\mathcal{E}}[\widetilde{s'}] \longrightarrow_{prg} \widetilde{\mathcal{E}}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
\end{equation*}
for an $\widetilde{\mathcal{E}} \sim \mathcal{E}$ with all names declared in $prg$, which, for each extraction function, exists by the definition of its equivalence relation. Also by this definition, $\widetilde{\mathcal{E}}$ is unique, and for a $\mathcal{E}[s']$ of the form
\begin{equation*}
fun(t^0_1, ..., t^0_{n_0}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k})
\end{equation*}
$\widetilde{\mathcal{E}}[\widetilde{s'}]$ has the form
\begin{equation*}
fun'(s^0_1, ..., s^0_{n'_0}).des'_1(s^0_1, ..., s^0_{n'_1})...des'_{k'}(s^0_1, ..., s^0_{n'_{k'}}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k}),
\end{equation*}
where each of the $s^i_j$ is equivalent to exactly one of the $t^0_i$. Thus, it actually is an evaluation context in $prg$, i.e., all of its immediate subterms left of the hole are irreducible in $prg$. To see this, consider such the highest-level subterms that can be possibly be reduced (Note: this is possible under the first proposed change, because then prefixes can't be reduced using the congruence rule); those are precisely the $s^i_j$. Suppose it reduced in $prg$, then, by the second extraction function property, the equivalent term among the $t^0_i$ would reduce in $\langle prg \rangle$, contrary to the fact that it is a value in $prg$ because it is to the left of the hole in $\mathcal{E}$.

\end{enumerate}

\end{proof}

\end{proposition}

%%--

%TODO: momentarily contains the old versions of some proofs of (1a), (1b) and other old versions that all still need to be reworked
%
%\subsubsection{Eliminate multiple destructors}
%
%\begin{proof}[Proof of (2)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%Since $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract\_outer\_des}$ contains $`` q = s' "$.
%
%$extract\_outer\_des$ fulfils the extraction function properties, as shown in the proof of (1a). By the first property it is either $q \sim s'$ or ($q_r \sim q$ and $t_r \sim s'$). In the first case, it follows that $s \sim s'[\sigma] = t$, contrary to the assumption.
%
%Now, consider the second case. The desired reduction step can be derived as follows:
%\begin{prooftree}
%\AxiomC{$q_r[\sigma] =^? q_r \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q_r, t_r)$}
%\UnaryInfC{$q_r[\sigma] \longrightarrow_{prg} t_r[\sigma]$}
%\end{prooftree}
%It is clear that $\widetilde{t} := t_r[\sigma] \sim s'[\sigma] = t$. It is $\widetilde{s} := q_r[\sigma] \sim q[\sigma] = s$.
%
%It remains to be shown that the immediate subterms of $q_r[\sigma]$ are values in $prg$. Suppose that such a subterm $s^0$ reduces to some term in $prg$; this resulting term cannot be equivalent to $s^0$ unless it is identical to $s^0$. It will be shown that this leads to a contradiction.
%
%First, note that if $s^0$ reduces in $prg$, it does so in $\langle prg \rangle$, as well.
%$s^0$ can either reduce by the ``Cong" rule, or by the ``Subst" rule. If it reduces by the ``Subst" rule, then, by Lemma 2.1, it also reduces to some term in $\langle prg \rangle$. If it reduces by the ``Cong" rule, a subterm of $s^0$ reduces by the ``Subst" rule in $prg$ and by Lemma 2.1 it does so in $\langle prg \rangle$, as well. But then either (a) the ``Cong" rule can be applied, and $s^0$ reduces by this rule in $\langle prg \rangle$, or (b) there is some non-value term left of the subterm of $s^0$ which reduces in $\langle prg \rangle$, and the ``Cong" rule can be applied, to the reduction of the left-most such subterm, to reduce $s^0$.
%
%The contradiction can be shown as follows. If $s^0$ reduces to some term in $prg$, then there is a non-value immediate subterm of $s = q[\sigma]$, contrary to the assumption. In turn, this follows from the more general statement for any copatterns $q_r, q$ with $q_r \sim q$, substitutions $\sigma$, and immediate subterms $s^0$ of $q_r[\sigma]$:
%
%If $s^0$ reduces to some term in $prg$, then there is a non-value immediate subterm of $q[\sigma]$ in $\langle prg \rangle$.
%
%This is now shown by induction on the structure of $q_r$.
%
%\begin{itemize}
%
%\item $q_r = fun(p_1, ..., p_n)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = fun(\widetilde{p_1}, ..., \widetilde{p_n})$ with $p_i \sim \widetilde{p_i}$ for $i = 1, ..., n$.
%
%Since the patterns $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus it is $q_r = q$ and $q_r[\sigma] = q[\sigma]$ and thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $s = q[\sigma]$ contains a non-value immediate subterm.
%
%\item $q = \langle \textrm{extract}, \langle q_r \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle q_r \rangle^{vars})$.
%
%The patterns $p_i$ of $q_r$ are made up only of constructor calls and variables. It follows that a reduction of $s^0$ needs to contain a step in its derivation that starts with a term that $\sigma$ substitutes one of its variables with. But this term is also a subterm of $s = q[\sigma]$, since $q$ contains (by definition) all variables of $q_r$. By the above it follows that this subterm of $s$ reduces to some term in $\langle prg \rangle$. Thus $s$ contains a non-value subterm and consequently a non-value immediate subterm.
%
%\end{itemize}
%
%\item $q_r = q'.des(p_1, ..., p_k)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = \widetilde{q'}.des(\widetilde{p_1}, ..., \widetilde{p_k})$ with $q' \sim \widetilde{q'}$ and $p_i \sim \widetilde{p_i}$ for $i \in \{1, ... k\}$.
%
%First, suppose that $s^0 = q'[\sigma]$. By the induction hypothesis, we have a non-value immediate subterm of $\widetilde{q'}[\sigma]$ in $\langle prg \rangle$. It follows that $\widetilde{q'}[\sigma]$ also is not a value in $\langle prg \rangle$. Thus we have $\widetilde{q'}[\sigma]$ as the desired non-value immediate subterm of $q[\sigma] = \widetilde{q'}[\sigma].des(\widetilde{p_1}[\sigma], ..., \widetilde{p_k}[\sigma])$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. Since the $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $q[\sigma]$ contains a non-value immediate subterm.
%
%\item $q = \langle \textrm{extract}, \langle q_r \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle q_r \rangle^{vars})$.
%
%First, suppose that $s^0 = q'[\sigma]$. But this would mean that the rule of which $q_r$ is the left-hand side can never be used. This is because any term that matches it has to contain a subterm (the term the destructor is called upon) that reduces by the rule by which $s^0$ reduces. The rule of which $q_r$ is the left-hand side thus is a ``dead" rule, and these were disallowed in the preconditions for $prg$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. The argument proceeds like in this case for $q_r = fun(p_1, ..., p_n)$.
%
%\end{itemize}
%
%\end{itemize}
%
%\item \textbf{``Cong" case}:
%
%\begin{prooftree}
%\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
%\RightLabel{Cong}
%\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
%\end{prooftree}
%
%with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.
%
%By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. By applying the congruence rule we get the desired
%\begin{equation*}
%s = \mathcal{E}[s'] \sim \mathcal{E}[\widetilde{s'}] \longrightarrow_{prg} \mathcal{E}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
%\end{equation*}
%because the subterms of $\mathcal{E}$ that are values in $\langle prg \rangle$ are values in $prg$, as well. Too see this, suppose that such a subterm $s^0$ reduces to some term in $prg$. It can either do so by the ``Cong" rule, or by the ``Subst" rule. If it reduces by the ``Subst" rule, then, by Lemma 2, $s^0$ reduces to a term in $\langle prg \rangle$, as well. But this contradicts the fact that $s^0$ is a value in $\langle prg \rangle$. If it reduces by the ``Cong" rule, there is some subterm of $s^0$ that reduces by the ``Subst" rule in $prg$, and by Lemma 2 it also reduces to some term in $\langle prg \rangle$. Thus this subterm of $s^0$ is not a value in $\langle prg \rangle$. It follows that neither is $s^0$, contrary to fact.
%
%\end{enumerate}
%
%\end{proof}
%
%\subsubsection{Unmix (defunc.)}
%
%For step $unmix_d$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%\begin{itemize}
%
%\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.
%
%Then, since $unmix_d$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.
%
%\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.
%
%It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_des}$. Using Lemma 2.1, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_d$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.
%
%What follows is the proof for the above statement. From the precondition of the ``Subst" case we have that $s$ reduces to $t$ using only $`` q = s' "$. Using Lemma 3 we have the desired sequence from $s$ to $t$ using only the rules from $\langle `` q = s' " \rangle^{extract\_des}$.
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (2)] By inspecting the proof of (1).
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (3)]
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (4)] As with $elim\_multi\_des$, all equations used in the sequence are created by destructor extraction via $extract\_des$. Again, a one-step reduction using such an equation has the property of decreasing the number of destructors embedded into the term. It follows that all terms appearing in the sequence are different and thus the sequence is not infinite.
%
%\end{proof}
%
%\subsubsection{Disentangle (defunc.)}
%
%\begin{proof}[Proof of (2)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%Since $disentangle_d = extract\_helpers(extract\_patterns)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract\_patterns}$ contains $`` q = s' "$.
%
%$extract\_patterns$ fulfils the extraction function properties, as shown in the proof of (1a). By the first property it is either $q \sim s'$ or ($q_r \sim q$ and $t_r \sim s'$). In the first case, it follows that $s \sim s'[\sigma] = t$, contrary to the assumption.
%
%Now, consider the second case. From this point, the proof proceeds like that for $elim\_multi\_des$, with the following exceptions in the proof by induction on the structure of $q_r$ (identical parts are denoted by ellipses [...]):
%
%\begin{itemize}
%
%\item $q_r = fun(p_1, ..., p_n)$. $q \sim q_r$ holds only when:
%
%$q = fun(\widetilde{p_1}, ..., \widetilde{p_n})$ with $p_i \sim \widetilde{p_i}$ for $i = 1, ..., n$.
%
%[...]
%
%\item $q_r = q'.des(p_1, ..., p_k)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = \widetilde{q'}.des(\widetilde{p_1}, ..., \widetilde{p_k})$ with $q' \sim \widetilde{q'}$ and $p_i \sim \widetilde{p_i}$ for $i \in \{1, ... k\}$.
%
%[...]
%
%\item $q = \langle fun, des, prg \rangle^{autogen}(p'_1, ..., p'_n, p_1, ..., p_k)$, where $\widetilde{p'_i} \sim p'_i$ for $i \in \{1, ..., n\}$, $\widetilde{p_j} \sim p_j$ for $j \in \{1, ..., k\}$, and with $q' = fun(p'_1, ..., p'_n)$. ($q'$ has this form because it is the only form possible in the relevant input fragment for $disentangle_d$.)
%
%First, suppose that $s^0 = q'[\sigma]$. But this would mean that the rule of which $q_r$ is the left-hand side can never be used. This is because any term that matches it has to contain a subterm (the term the destructor is called upon) that reduces by the rule by which $s^0$ reduces. The rule of which $q_r$ is the left-hand side thus is a ``dead" rule, and these were disallowed in the preconditions for $prg$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. Since the $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $q[\sigma]$ contains a non-value immediate subterm.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\subsubsection{Unmix (refunc.)}
%
%For step $unmix_r$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1a)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%TODO: Change $unmix_r$ such that this case distinction becomes unnecessary. Result should be: $unmix_r = extract\_helpers(extract\_all\_des)$, and this makes it necessary to change $extract\_all\_des$ to distinguish between rule from mixed and such from not-mixed function definitions. It can access the entire program and with this determine which of the two is the case.
%
%\begin{itemize}
%
%\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.
%
%Then, since $unmix_r$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.
%
%\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.
%
%It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_all\_des}$. Using Lemma 2.1, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_r$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.
%
%What follows is the proof for the above statement. By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and by setting $H = \emptyset$, the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the structure of $q$:
%
%If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_all\_des}$.
%
%Note the similarity between the definitions of $extract\_outer\_des$ and $extract\_all\_des$: The only difference is the distinction between outer and single destructor calls in $extract\_outer\_des$. This similarity will be used in the proof below.
%
%Proof by induction:
%
%\begin{itemize}
%
%\item \underline{Case 1}: $q$ is hole pattern:
%
%$\langle `` q = s' ", H \rangle^{extract\_all\_des} = \big\langle `` q = s' ", H \big\rangle$
%
%Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.
%
%\item \underline{Case 2}: $q = q'.des(p_1, ..., p_k)$:
%
%The argument here is identical to that of Case 3 in the induction concerning $extract\_outer\_des$, inside the ``Subst" case of the proof of (1) for $elim\_multi\_des$, with $extract\_all\_des$ substituted for $extract\_outer\_des$.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\subsubsection{Disentangle (refunc.)}
%
%For step $disentangle_r$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%It will be shown: there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\langle `` q = s' " \rangle^{extract}$. Using Lemma 2.1 for $e = extract$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $disentangle_r = extract\_helpers(extract)$.
%
%By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and by setting $H = \emptyset$, the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the number of constructor patterns appearing in $q$.
%
%If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract}$.
%
%Proof by induction:
%
%\begin{itemize}
%
%\item \underline{Case 1:} 0 constructor patterns appear in $q$:
%
%Then the first two cases of the definition of $extract$ are not effective, since they depend upon the presence of at least one constructor pattern in $q$. It follows that the third case (``otherwise") of the definition is effective:
%
%$\langle `` q = s' ", H \rangle^{extract} = \big\langle `` q = s' ", H \big\rangle$
%
%Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.
%
%\item \underline{Case 2:} $n+1$ constructor pattern appear in $q$, with $n \geq 0$:
%
%\begin{itemize}
%
%\item \underline{Case 2.1}: $q = fun(p^0_1, ..., p^0_n).des_1(p^1_1, ..., p^1_{n_1})...des_k(p^k_1, ..., p^k_{n_k})$, $k \geq 1$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:
%
%$\langle `` q = s' ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}$
%
%with $hname, hsig, heqn$ as in the definition of $extract$.
%
%Compared to $q$, $q^{-con}$ has one less constructor pattern. Thus we can apply the induction hypothesis to $q^{-con}$, yielding a reduction sequence from $s$ to $t$ using only the equations within $\langle `` q = s' ", H \rangle^{extract}$ if there is one with respect to $\big\langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle$.
%
%This last sequence can be constructed as in the following steps, somewhat analogous to the construction in Lemma 3. The construction starts from the known original sequence with respect to $\big\langle `` q = s' ", H \big\rangle$; let this sequence be:
%
%$t_1 \longrightarrow t_2 \longrightarrow ... \longrightarrow t_{n-1} \longrightarrow t$
%
%with $t_1 = s$, $t_n = t$. Also, let $r := (q, s')$.
%
%\begin{enumerate}
%
%\item Let $I \subseteq \{1, ..., n - 1\}$ be the set of indices $j$ where $t_j \longrightarrow t_{j+1}$ contains an application of the ``Subst" rule for $r$. For all indices $k \not\in I$, $t_k \longrightarrow t_{k+1}$ is with respect to the equations within $H$.
%
%\item For a $j \in I$, by inversion, we know the derivation of $t_j \longrightarrow t_{j+1}$ looks as follows:
%
%\begin{prooftree}
%\AxiomC{\vdots}
%\RightLabel{\scriptsize PM\textsubscript{Des}}
%\UnaryInfC{$t^0_j =^? q \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q, s')$}
%\UnaryInfC{$t^0_j \longrightarrow s'[\sigma]$}
%\UnaryInfC{$\mathcal{D'}$}
%\UnaryInfC{$t_j \longrightarrow t_{j+1}$}
%\end{prooftree}
%
%for some substitution $\sigma$, some intermediate derivation $\mathcal{D'}$ and a subterm $t^0_j$ of $t_j$.
%
%\item In the original sequence above, for every $j \in I$, replace $t_j \longrightarrow t_{j+1}$ with the two reduction steps $t_j \longrightarrow t'_j$, $t'_j \longrightarrow t_{j+1}$, in this order, with the following derivations:
%
%Derivation for $t_j \longrightarrow t'_j$:
%\begin{prooftree}
%\AxiomC{\vdots}
%\UnaryInfC{$t^0_j =^? q^{-con} \searrow \sigma'$}
%\RightLabel{\scriptsize Subst with $(q^{-con}, `` hname(q^{-con}_{vars^+}) ")$}
%\UnaryInfC{$t^0_j \longrightarrow t_h$}
%\UnaryInfC{$\mathcal{D'}_1$}
%\UnaryInfC{$t_j \longrightarrow t'_j$}
%\end{prooftree}
%
%The derivation for $t^0_j =^? q^{-con} \searrow \sigma'$, for some substitution $\sigma'$ has been omitted. We know from above that $t^0_j$ matches against $q$ returning $\sigma$. $q^{-con}$ is simply $q$ with one of its patterns $p$ replaced by a variable $x_p$, thus it catches at least all terms which are caught by $q$. $\sigma'$ is $\sigma$ where the part $\sigma_p$ of the substitution returned by matching the relevant subterm $t_p$ against $p$ is replaced by $t_p / x_p$. Let $x_1, ..., x_n$ be the variables in $q^{-con}$. It is $\sigma = \sigma_p, \sigma'[\{ x_1, ..., x_n \} \setminus \{ x_p \}]$, where $\sigma'[S]$ for a set $S$ means the substitutions of $\sigma'$ limited to those for variables in $S$.
%
%$\mathcal{D'}_1$ is $\mathcal{D'}$ where all the occurrences of $s'[\sigma]$ that stem from the reduction by substitution of $t^0_j$ to it are replaced by
%
%$t_h := `` hname(q^{-con}_{vars^+}) "[\sigma']$.
%
%$t'_j$ is defined accordingly.
%
%For the next derivation, let $q_h = `` hname(q^{-con}_{vars^-}) "$. Thus it is $heqn = `` q_h = s'  "$. 
%
%Let $k$ be the index of $x_p$, that is $x_p = x_k$, and $(y_1, ..., y_m)$ be the list $(x_1, ..., x_{k-1}, x_{k+1}, ..., x_n)$ ($m = n-1$). The list $q^{-con}_{vars^+}$ is, by definition, $(x_p, y_1, ..., y_m)$. The list $q^{-con}_{vars^-}$ is $(p, y_1, ..., y_m)$. Note that for the $\sigma'$ described above, $x_p[\sigma'] = t_p$. In the derivation below, the derivation for $x_p[\sigma'] =^? p \searrow \sigma_p$, with $\sigma_p$ as described above, has thus been omitted.
%
%Derivation for $t'_j \longrightarrow t_{j+1}$:
%
%{\setlength{\parindent}{-\leftmargin}
%\AxiomC{\vdots}
%\UnaryInfC{$x_p[\sigma'] =^? p \searrow \sigma_p$}
%\AxiomC{}
%\RightLabel{\scriptsize PM\textsubscript{Var}}
%\UnaryInfC{$y_1[\sigma'] =^? y_1 \searrow \sigma'[y_1]$}
%\AxiomC{...}
%\AxiomC{}
%\RightLabel{\scriptsize PM\textsubscript{Var}}
%\UnaryInfC{$y_m[\sigma'] =^? y_m \searrow \sigma'[y_m]$}
%\RightLabel{\scriptsize PM\textsubscript{App}}
%\QuaternaryInfC{$t_h =^? q_h \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q_h,  s')$}
%\UnaryInfC{$t_h \longrightarrow s'[\sigma]$}
%\UnaryInfC{$\mathcal{D'}_2$}
%\UnaryInfC{$t'_j \longrightarrow t_{j+1}$}
%\DisplayProof
%}
%
%where $\mathcal{D'}_2$ is $\mathcal{D'}$ where all the occurrences of $t^0_j$ that stem from its reduction by substitution to $s'[\sigma]$ are replaced by $t_h$.
%
%
%
%\end{enumerate}
%
%\item \underline{Case 2.2}: $q = fun(con(p^0_1, ..., p^0_n), p^1_1, ..., p^1_n)$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:
%
%This case proceeds completely analogous to Case 2.1, where a left-most outer constructor pattern is skipped over. This is possible since second case of the definition of $extract$, which is effective in this case, is only different in exactly this way: All relevant definitions are precisely analogous to the respective other definitions.
%
%\item \underline{Case 2.3}: otherwise:
%
%Since neither the first (as in Case 2.1) nor the second (as in Case 2.2) case of the definition of $extract$ is effective, it follows that the third case (``otherwise") is effective. Thus, proceed as in Case 1.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (2)] By inspecting the proof of (1).
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (3)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ ($s,t$ typecheck against $prg$)
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%When $(q, s') \in \textrm{Rules}(prg)$, so, by the ``Subst" rule, $s \longrightarrow_{prg} t$. It remains to be shown that $(q, s') \in \textrm{Rules}(prg)$.
%
%Since $disentangle_r = extract\_helpers(extract)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract}$ contains $`` q = s' "$.
%
%\begin{itemize}
%
%\item \underline{Case 1}: $r = `` fun(p^0_1, ..., p^0_n).des_1(p'_1, ..., p'_{n_1})...des_k(p^k_1, ..., p^k_{n_k}) = t' " $, $k \geq 1$, $\exists p^j_i: p^j_i \textrm{ is constructor pattern}$:
%
%It will be shown that this case contradicts the fact that $\langle r \rangle^{extract}$ contains $`` q = s' "$. This is done by showing, by induction on the number $n_c$ of constructor patterns contained in $q'$, for any $r := `` q' = t' "$ that has the above form and any helpers set $H$ (including the empty one):
%
%$\langle r , H \rangle^{extract}$ doesn't contain $`` q = s' "$ unless it is already within $H$
%
%\begin{enumerate}
%
%\item $n_c = 1$:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}
%\end{equation*}
%with $hname, hsig, heqn$ as in the definition of $extract$. Since $q'$ contains only one constructor pattern, $q'^{-con}$ contains no constructor pattern. It follows that:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \big\langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle
%\end{equation*}
% Neither of the two equations outside of $H$ in $\langle r, H \rangle^{extract}$ is $`` q = s' "$, since they both contain function names not present in $prg$.
%
%\item $n_c = n'_c + 1$, $n'_c \geq 0$:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}
%\end{equation*}
%with $hname, hsig, heqn$ as in the definition of $extract$. Since $q'^{-con}$ contains one less constructor pattern than $q'$, it contains $n'_c$ such patterns. Applying the induction hypothesis we have that $\langle r, H \rangle^{extract}$ doesn't contain $`` q = s' "$ outside of $\{ \big\langle hsig, heqn \big\rangle \} \cup H$. The only remaining equation outside of $H$ that could be $`` q = s' "$ is defined by $heqn$ to contain a function name not present in $prg$. Thus this equation can't be $`` q = s' "$, either.
%
%\end{enumerate}
%
%\item \underline{Case 2}:  $r = `` fun(con(p^0_1, ..., p^0_k), p^1_1, ..., p^1_n) = t' " $, $\exists p^j_i: p^j_i \textrm{ is constructor pattern}$:
%
%This case can be shown analogously to Case 1, by using instead this other form of $r$ and the respective analogues $q^{-con'}, q^{-con'}_{vars^+}$ etc. in the places of $q^{-con}, q^{-con}_{vars^+}$ etc.
%
%\item \underline{Case 3}: otherwise:
%\begin{equation*}
%\langle r \rangle^{extract} = \big\langle r \big\rangle
%\end{equation*}
%Thus it must be $r = `` q = s' "$ and therefore $(q, s') \in \textrm{Rules}(prg)$.
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (4)]
%
%TODO
%
%\end{proof}

\subsection{Proofs of strong bisimulation}

Strong bisimulation holds for actual defunctionalization and actual refunctionalization.

\subsubsection{Actual defunctionalization}

For the actual defunctionalization, $d''$, strong bisimulation holds. The proof relies on properties of the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $d^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $d^{core}$, the Codata Fragment, and, analogously, when restricted to the domain of their refunctionalization, the Data Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $d^{core}$.

\begin{proof}[Proof of strong bisimulation for $d''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$). Such equations (and indeed the function definitions) are left unchanged by $d''$ except for defunctionalizing the right-hand term, as can be seen directly in the definition of $d''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

By inversion, we have from $s =^? q \searrow \sigma$ that $s$ has the form $fun(v_1, ..., v_n)$ for some values $v_1, ..., v_n$, thus $\langle s \rangle = fun(\langle v_1 \rangle, ..., \langle v_n \rangle)$. By inversion for values, we have that each $v_i$ is either a constructor application or a value of codata type. If it is a value of codata type, by inversion on pattern matching, the relevant subpattern of $q$ can only be a variable, thus it is also matched by $\langle v_i \rangle$. If it is a constructor application, the relevant subpattern of $q$ is either a variable, and the same holds, or it is a constructor pattern, and by recursively descending into its subpatterns we still get that $\langle v_i \rangle = con(\langle v^1_i \rangle, ..., \langle v^m_n \rangle)$ matches against the subpattern of $q$.

By carrying the substitutions returned from the matchings along in the above recursive argument, we get a substitution $\sigma'$ such that $\langle s \rangle =^? q \searrow \sigma'$ and, by distributing over $\langle s' \rangle$, $\langle s' \rangle [\sigma'] = \langle s'[\sigma] \rangle = \langle t \rangle$. It follows that $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $d''$). Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $d^{core}$, as specified in the definition of $d''$. Let this part, amended by the ``constructor subsumption" noted for the definition of $d''$, be $prg'$; it is: $s \longrightarrow_{prg'} t$

By (*) we would have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. 

For the coverage, bear in mind that the equation $`` q = s' "$ enabling the reduction of $s$ by the ``Subst" rule is part of $prg'$ by the precondition of Case 2. As $s$ matches against $q$, copattern coverage for $s$ is trivially fulfilled in $prg'$. The immediate subterms of $s$ are values with respect to $prg$ and, by inversion, their immediate subterms and so forth, which especially means that there is no rule in $prg$ against which they match. But $prg$ has copattern coverage for such a subterm (TODO: make this a general precondition) and there is already no rule for it in $prg$. It follows that $prg'$ still has copattern coverage for the subterm even though there is no rule for it in $prg'$. This is because, either (1) the subterm is a destructor call, then it can only be covered by destructor copatterns (as it matches against a destructor copattern) and those only occur within $prg'$, or (2) it is a constructor call, which doesn't need to be matched for coverage. It can't be a function call, since these can only be covered by directly matching the call, which isn't the case even in $prg$, for which coverage is assumed. Thus coverage holds for $prg'$.

For well-typedness, simply treat the missing types temporarily, that is, for the sake of (*), as codata types. This is no problem for the restriction to the domain of $d^{core}$, since such types could be introduced inside the Codata Fragment with codata definitions. To be more precise, empty function definitions can be added for missing ones and empty codata definitions for missing types, and removed again after using (*), without adding or removing possible reductions, respectively. All in all, we have by (*):
\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle
\end{equation*}

But this program $\langle prg' \rangle^{d^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $d''$. This implies the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

Other cases are excluded by the relevant input fragment.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $\langle s' \rangle \longrightarrow_{\langle prg \rangle} \langle t' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$, defined analogously to the transformation of terms by transforming the terms in $\mathcal{E}$ and by setting $\langle [] \rangle = []$. By applying the congruence rule we get $\langle \mathcal{E} \rangle[\langle s' \rangle] \longrightarrow_{\langle prg \rangle} \langle \mathcal{E} \rangle[\langle t' \rangle]$. It is clear that $\langle \mathcal{E} \rangle[\langle s' \rangle] = \langle \mathcal{E}[s'] \rangle = \langle s \rangle$ and $\langle \mathcal{E} \rangle[\langle t' \rangle] = \langle \mathcal{E}[t'] \rangle = \langle t \rangle$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part of $prg$, as specified in the definition of $d''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $d''$, this other part is taken over unchanged from $prg$ except for defunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle$.

By (*) we would have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle \iff s \longrightarrow_{prg'} t,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. Both of those properties can be shown or simulated similarly to the way they are in the $`` \Rightarrow "$ part.

But it is $prg' \subseteq prg$, as can be seen in the definition of $d''$. This implies the desired $s \longrightarrow_{prg} t$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = \langle s \rangle$ and $\mathcal{E}[t'] = \langle t \rangle$.

By the induction hypothesis we have $s'' \longrightarrow_{prg} t''$ with $s' = \langle s'' \rangle$, $t' = \langle t'' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$ (defined as in the $`` \Rightarrow "$ part). Apply the congruence rule to get $\mathcal{E}'[s''] \longrightarrow_{prg} \mathcal{E}'[t'']$ with $\mathcal{E} = \langle \mathcal{E}' \rangle$. That is, $\mathcal{E}'$ is the result of applying the inverse of $\langle \cdot \rangle$ to $\mathcal{E}$, which is possible, since, for instance, $\mathcal{E}[s'] = \langle s \rangle$. It is $\langle \mathcal{E}'[s''] \rangle = \langle \mathcal{E}' \rangle[\langle s'' \rangle] = \mathcal{E}[s'] = \langle s \rangle$ and $\langle \mathcal{E}'[t''] \rangle = \langle \mathcal{E}' \rangle[\langle t'' \rangle] = \mathcal{E}[t'] = \langle t \rangle$ and thus we have the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\end{proof}

\subsubsection{Actual refunctionalization}

For the actual refunctionalization, $r''$, strong bisimulation holds. The proof relies on properties of the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $r^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $r^{core}$, the Data Fragment, and, analogously, when restricted to the domain of their defunctionalization, the Codata Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $r^{core}$.

\begin{proof}[Proof of strong bisimulation for $r''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2 (it is omitted that $prg$ is passed to $r$ as well). This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is destructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $r''$). Such equations (and indeed the function definitions) are left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

From here, the argument proceeds analogously to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

\item \underline{Case 2}: $q$ is hole pattern without arguments or where the first argument has codata type:

Then the equation is left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Proceed as in Case 1.

\item \underline{Case 3}: $q$ is hole pattern and has a first argument with data type:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$), and it has a first argument with data type. Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $des\_conv$, and then the result of this to $r^{core}$, as specified in the definition of $r''$. Let the part passed to $des\_conv$ be $prg'$; it is: $s \longrightarrow_{prg'} t$.

By (*) we have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{r^{core}}} \langle t \rangle,
\end{equation*}

But this program $\langle prg' \rangle^{r^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $r''$. Thus we have the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2. This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part of $prg$, as specified in the definition of $r''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $r''$, this other part is taken over unchanged from $prg$ except for refunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle$.

By (*) we have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle \iff s \longrightarrow_{\langle prg' \rangle^{des\_conv}} t.
\end{equation*}

In the result of $des\_conv$, no new matching left-hand sides are added. That is, $prg'$ contains at least all the matching left-hand sides that $\langle prg' \rangle^{des\_conv}$ has. Thus any reduction that is possible with respect to $\langle prg' \rangle^{des\_conv}$ is already possible with respect to $prg'$.

But it is $prg' \subseteq prg$, as can be seen in the definition of $r''$. This implies the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{proof}

\end{document}
