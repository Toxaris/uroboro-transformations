% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{listings}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Currently doesn't support multiple destructor calls in a copattern.

\item It still is able to defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item In the following, a function definition (or its equations) is called mixed if it has both destructor and hole patterns.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle p \rangle^{name\_pattern}$ gives a pattern a unique name, unique modulo the variable names.

\item $\langle p \rangle^{vars}$ gives all variables appearing in the pattern (from left to right) as a list.

\item $\langle p, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the pattern (from left to right) by going recursively through the pattern's constructor calls. If the pattern $p$ is a variable itself, returns only $\tau$.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{roboroTransformations.MixedDefs.Defunc.namePattern} and \texttt{constructorTypes} for limitations.)

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}
\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle prg \rangle^{extract\_des} \rangle^{d'}$

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{extract\_des} & = ~&&\{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n):\sigma \textrm{\textbf{ where }} \\
& && && \{ fun(p_1, ..., p_n) = \\
& && &&\quad \langle `` \textrm{extract} ", \langle fun(p_1, ..., p_n) \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle p_1 \rangle^{vars}, ..., \langle p_n \rangle^{vars}) \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with mixed } eqns \} \\
&\cup && \{ && \textrm{\textbf{function }} \langle `` \textrm{extract} ", \langle fun(p_1, ..., p_n) \rangle^{name\_pattern}, prg \rangle^{autogen} (\\
& && &&\quad \langle p_1, \tau_1 \rangle^{vartypes}, ..., \langle p_n, \tau_n \rangle^{vartypes} \\
& && &&): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle `` \textrm{extract} ", \langle fun(p_1, ..., p_n) \rangle^{name\_pattern}, prg \rangle^{autogen}(\\
& && &&\quad \langle p_1 \rangle^{vars}, ..., \langle p_n \rangle^{vars} \\
& && &&\quad ).des'(p''_1, ..., p''_{k'}) = t' \\
& && && | ~ `` fun(p_1, ..., p_n).des'(p''_1, ..., p''_k) = t' " \in eqns \} \\
& && | && `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \textrm{ with } \\
& && &&\quad `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns" \in prg, eqns \textrm{ mixed } \} \\
&\cup && \{ && def ~ | ~ def \in prg, ~ def \textrm{ is (co)data definition or non-mixed function def. } \}
\end{alignat*}

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):
\begin{alignat*}{3}
\langle prg \rangle^{disentangle} & = ~&&\{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = \langle fun, des, prg \rangle^{autogen}(x_1, ..., x_n, x'_1, ..., x'_k) \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = ... " \in eqns \textrm{ with } \\
& && &&\quad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && \cup && \{ fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \textrm{ with } \\
& && &&\quad \not\exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
&\cup && \{ && \textrm{\textbf{function }} \langle fun, des, prg \rangle^{autogen}(\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun, des, prg \rangle^{autogen}(p_1, ..., p_n, p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma_1, ..., \sigma_n): \tau \textrm{\textbf{ where }} eqns ", `` \tau.des(\sigma'_1,...,\sigma'_k): \sigma " \in prg \\
& && &&\quad \textrm{ with } \exists e \in eqns: e = `` fun(p_1, ..., p_n).des(p'_1,..., p'_k) = t ", \\
& && &&\qquad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application } \} \\
& \cup && \{ && def ~ | ~ def \in prg, def \textrm{ is (co)data def. or function def. without destructor patterns } \}
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):
\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \{ ~&& \textrm{\textbf{data }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun \rangle^d (\tau_1, ..., \tau_n): \sigma \\
& && && | ~ `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
& && | && "\textrm{\textbf{codata }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle des \rangle^d (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} \\
& && && \{ \langle des \rangle^d ( \langle fun \rangle^d (x_1, ..., x_n), y_1, ..., y_k) = \langle t \rangle^d \\
& && && | ~ `` fun(x_1, ..., x_n).des(y_1, ..., y_k) = t " \in prg \} \\
& && | && `` \sigma.des(\tau_1, ... \tau_n): \tau " \in prg \} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\end{document}
