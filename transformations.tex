% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}

\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}$ is short for $\langle eqn, \emptyset \rangle^{e}$
\end{itemize}

\item In the following, a function definition (or its equations) is called mixed if it contains a rule where the copattern is a destructor pattern and another rule where the copattern is a hole pattern.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \span\span \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \span\span \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \span\span \\
&\quad \textrm{ where } && fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig} \textrm{ if } q = fun(...)\\
&\quad && \tau.des(\tau_1, ..., \tau_k) : \sigma = \langle des \rangle^{sig} \textrm{ if } q = q'.des(...) \\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \span\span \\
& \langle `` q = t ", H \rangle^{extract\_des} = \big\langle `` q = t ", H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\item In general, the implementations of defunctionalization and refunctionalization only work with programs which don't depend upon the order of their rules. Especially, that means that a function such as the following won't be transformed correctly:
\begin{lstlisting}

function foo where
  foo(zero()) = zero()
  foo(succ(zero()) = zero()
  foo(x) = x

\end{lstlisting}

Thanks are due to Yufei Cai and Paolo Giarrusso for this observation. Future work might add a transformation from rule-order dependent to rule-order independent programs.

\end{itemize}

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix_d} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle `` q = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_d} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle_d} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):

$\langle prg \rangle^{disentangle_d} = \langle prg \rangle^{extract\_helpers(extract\_patterns)}$

Extract undesired pattern matching of a single equation into a helper function:
\begin{alignat*}{3}
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} \\
&\quad = \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \\
&\quad \textrm{with } hname= \langle fun, des, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n, \tau'_1, ..., \tau'_k): \tau \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, \sigma.des(\tau'_1, ..., \tau'_k): \tau = \langle des \rangle^{sig} \\
&\quad heqn = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = t ", \\
&\quad \textrm{if } \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \\
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} = \big\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
&\langle `` q = t ", H \rangle^{extract\_patterns} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):

This uses the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $d^{core}$.

\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \langle && \{ def \in prg ~ | ~ def \textrm{ is codata def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has destr. pattern } \} \rangle^{d^{core}} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Technical note on constructor subsumption:

The input of $d^{core}$ in the definition above is actually not in its domain. This is because it can contain constructor calls. The following technical trick allows to transform such inputs as well: For the sake of $d^{core}$, subsume constructor names under function names (as if they were from the same syntactic domain). After the transformation, since names aren't changed (or when name changes are desired, the original name can still be retrieved), the subsumed constructor names (or their equivalents after a name change) are once again considered constructor names (from the original syntactic domain).

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle prg \rangle^{unmix_r} \rangle^{r'}$

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_r} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle_r = extract\_helpers(extract)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars^-}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and this pattern in front of them;
\item $q^{-con}_{vars^+}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and the variable replacing this pattern in front of them;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars^-}$ and $q^{-con'}_{vars^+}$ are in the same way analogous to $q^{-con}_{vars^-}$ and $q^{-con}_{vars^+}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con}_{vars^-}) = t ", \\
&\quad && `` \tau.des_k(...): \sigma " = \langle des_k \rangle^{sig}, \\
&\quad \textrm{if } q = fun(p_1^0, ..., p_n^0).des_1(p_1^1, ..., p_{n_1}^1)...des_k(p_1^k, ..., p_{n_k}^k), k \geq 1 \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

Splitting of the first argument in hole patterns

(as in $fun(x,...) = t \rightarrow \{fun(con_1(...),...) = t, fun(con_2(...),...) = t\}$):

\begin{alignat*}{5}
\langle prg \rangle^{split} & = ~&& \{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \span\span\span\span \\
& && && \bigcup && \{ && \{ fun(con(y_1, ..., y_k), x_2, ..., x_n) = t[con(y_1, ..., y_k)/x_1] \\
& && && && && | ~ `` con(\sigma_1, ..., \sigma_k): \tau_1 " \in prg; ~ y_1, ..., y_k, x_2, ..., x_n \textrm{ all distinct} \} \\
& && && && | ~ `` fun(x_1, x_2, ..., x_n) = t " \in eqns \} \span\span \\
& && && \cup \{ fun(con(...), ...) = t ~ | ~ `` fun(con(...), ...) = t " \in eqns \} \span\span\span\span \\
& && && \cup \{ q.des(...) = t ~ | ~ `` q.des(...) = t " \in eqns \} \span\span\span\span \\
& && | `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg, n > 0 \textrm{ and } \tau_1 \textrm{ is data type} \} \span\span\span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is function def. with signature } fun(\tau_1, ..., \tau_n): \sigma, \span\span\span\span \\
& && &&\quad \textrm{ with } n = 0 \textrm{ or } \tau_1 \textrm{ is codata type} \} \span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is (co)data def.} \} \span\span\span\span
\end{alignat*}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first data type argument of a hole pattern):

This uses the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $r^{core}$.

Technical note: As $r^{core}$ doesn't allow destructor terms in its inputs, they have to be converted beforehand. This conversion is the same as that of $r$ for terms below, restricted to destructor terms. Call this conversion lifted to programs (in the way that all destructor terms on right-hand sides or as subterms of them are converted) $des\_conv$.

\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \langle \langle && \{ def \in prg ~ | ~ def \textrm{ is data def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has no destr. pattern}, \\
& && &&\qquad \textrm{the function has a first argument with data type } \} \rangle^{des\_conv} \rangle^{r^{core}} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern} \\
& && &&\quad \textrm{or where } n = 0 \textrm{ or where } \tau_1 \textrm{ is codata type} \} 
\end{alignat*}

TODO: Implement the changes to $split$ and $r''$

(see commit 862dd968ff41eaadc5196605652b04eef6e8a047)

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern or where $n = 0$ or where $\tau_1$ is codata type  \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Symmetries and alternative transformations}

A certain symmetry can be observed by laying the compositional sequences of the operations comprising defunctionalization and refunctionalization (preprocessing steps, then $d''$ or $r''$, respectively) next to each other:

\begin{alignat*}{4}
&\textrm{defunc.: } &&\textrm{ALL} \rightarrow  elim\_outer\_des \rightarrow && unmix_d \rightarrow disentangle_d && \rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{refunc.: } &&\textrm{ALL} \rightarrow && unmix_r \rightarrow disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

ALL stands for all of Uroboro, DEFUNC'ED and REFUNC'ED stand for the fragments of Uroboro the respective transformation results in. These two fragments can be transformed into one another as follows:

\begin{alignat*}{3}
&\textrm{REFUNC'ED} \rightarrow && elim\_outer\_des &&\rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{DEFUNC'ED} \rightarrow && disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

Observe that, when defunctionalizing REFUNC'EDs, only the first step $elim\_outer\_des$ of the preprocessing steps above is needed. Symmetrically, the first step $unmix_r$ of the preprocessing steps can be omitted when refunctionalizing DEFUNC'EDs.

From this symmetry one can derive an alternative defunctionalization and refunctionalization by using the respective other transformation:

$\langle prg \rangle^{d_{alt}} = \langle \langle prg \rangle^r \rangle^{elim\_outer\_des} \rangle^{d''}$

$\langle prg \rangle^{r_{alt}} = \langle \langle \langle prg \rangle^d \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

In both cases, one step of the original transformation can be saved by the above observed connection between REFUNC'ED and DEFUNC'ED. But this comes at the expense of having to run the entire refunctionalization before defunctionalizing and vice versa.

\section{Fragments for transformations}

This section identifies the relevant input fragments for the transformation steps given in section 2 and 3. Those are chosen such that the image of one step (under its relevant input fragment) is a subset of the input fragment for the next step. For each respective follow-up fragment, this can be seen directly in the definition of the previous transformation.

It can therefore be presumed that the input of a certain step comes only from its respective relevant input fragment. This will be used in the proofs of semantic preservation for the transformations steps in section 7.

Common syntax for the fragments:\\
$\sigma, \sigma_i, \tau, \tau_j = $ type names\\
$con = $ constructor names\\
$des = $ destructor names\\
$fun = $ function names\\
$x, y, x_i, y_j = $ variable names\\
$prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*$\\
$ddef ::= \textbf{data } \sigma \textbf{ where } csig^*$\\
$coddef ::= \textbf{codata } \sigma \textbf{ where } dsig^*$\\
$csig ::= con(\tau^*): \tau$
$dsig ::= \sigma.des(\tau^*): \tau$
$s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)$\\

A fragment will be defined by giving the respective EBNF rule for $fdef$, which stands for function definitions.

\subsection{Fragments for defunc.}

This subsection gives the relevant input fragments for the defunctionalization steps. The domain for the first step, $elim\_multi\_des$, is simply the set of all Uroboro programs. Thus the entire defunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Mixed fragment}

This is the input fragment for $unmix_d$. Informally, it consists of (co)data definitions and function definitions that may not contain multiple destructor calls in their copatterns but are otherwise unrestricted. 

Formal rules for function definitions:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ fun(p^*).des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_d$. Informally, it consists of (co)data definitions and function definitions that may neither contain multiple destructor calls nor be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(p^*).des(p^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Actual defunc. fragment}

This is the input fragment for actual defunctionalization, i.e. $d''$. Informally, it consists of (co)data definitions and function definitions where each satisfies the following property: It either is (1) in already defunctionalized form, i.e. the left-hand sides of its rules all are hole copatterns, or (2) are in the form that the core defunctionalization from the paper of Rendel, Trieflinger, and Ostermann can be applied to, i.e. the left-hand sides of its rules all are destructor copatterns, and these copatterns do not contain any constructor pattern matching.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(x^*).des(y^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for refunc.}

This subsection gives the relevant input fragments for the refunctionalization steps. The domain for the first step, $unmix_r$, is simply the set of all Uroboro programs. Thus the entire refunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_r$. Informally, it consists of (co)data definitions and function definitions that may not be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(p^*) = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Unsplit fragment}

This is the input fragment for $split$. Informally, it consists of (co)data definitions and function definitions where each may not be mixed and must satisfy the following property: For every copattern $q$ that is the left-hand side of one of its rules it holds that: Either $q$ is (1) a hole pattern, then it may contain at maximum one constructor application, and this at the left-most outer-most position, or $q$ is (2) a destructor pattern, then it must not contain any constructor applications.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$defeqn ::= dfeqn1 ~ | ~ dfeqn0$\\
$dfeqn1 ::= fun(con(x), y^*) = t$\\
$dfeqn0 ::= fun(x^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$

\subsubsection{Actual refunc. fragment}

This is the input fragment for actual refunctionalization, i.e. $r''$. Informally, it is identical to the last fragment with the following difference: Where it said ``at maximum one constructor application" in the last section, for this fragment ``exactly one constructor application" has to hold. As such, every one of its function definitions is either (1) already in refunctionalized form, i.e. the left-hand sides of its rules contain no constructor applications and they are either all destructor patterns or the function has no arguments or its first argument has codata type, or (2) core refunctionalization (Rendel, Trieflinger, Ostermann) can be applied to it.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef $\\
$dfdef ::= \textbf{function } fun(\sigma, \tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(con(x), y^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } copeqn^* ~ | ~ nopeqn^*$\\
$copeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$\\
$nopeqn ::= fun(x^*) = t$

\section{Values}

This section formalizes the notion of value for Uroboro. Unlike in the usual case, but not unlike other languages with copattern such as that of Abel et al., some values can be reduced. Not all reductions of values are preserved by the transformations above. 

As is the case with the language of Abel et al., whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from `Copatterns" (Abel et al.), section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

%%-- under construction

The value judgement makes use of a ``no-match" judgement. This judgement is complementary to the pattern matching judgement in the next section.

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Con/Card}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Card}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Des/Card}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}

%%--

\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction uses the evaluation context $\mathcal{E}$ given below, which in turn requires the syntax of the complete Uroboro (TODO: Define this like its fragments in section 5). 

\begin{alignat*}{2}
& v  = &&\textrm{value, that is } \vdash_v v \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}

\begin{prooftree}
\AxiomC{$t \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[\sigma]$}
\end{prooftree}

where the following holds: If $t = fun(t_1, ..., t_n)$ or $t = con(t_1, ..., t_n)$, then $\vdash_v t_i$ for $i = 1,...,n$. If $t = t_0.des(t_1, ..., t_n)$, then $\vdash_v t_i$ for $i = 0,1,...,n$.

Write $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

\subsection{As an extension of (Co)Data Fragment semantics}

The properties of the reductions and the de- and refunctionalization transformations of the paper of Rendel, Trieflinger, and Ostermann are used for the proofs of the next section. The domain of their defunctionalization is what they call the Codata Fragment, and that of refunctionalization the Data Fragment. Their semantic properties can be used in the proofs because, for well-typed programs and limited to terms which have copattern coverage for all of their subterms in the program (TODO: define this more precisely), this work's reducibility notion is a conservative extension of either the Data Fragment's notion or the Codata Fragment's notion. When the well-typedness and coverage conditions are dropped, the reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsubsection{Data Fragment}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment (Figure 6b), as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that it is not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from last section.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b)
\begin{equation*}
u, v ::= con(v^*),
\end{equation*}
while the V\textsubscript{CodTFun} can never be applied. This is because a function in the Data Fragment can only have data type unless it doesn't have a type defined in the program at all, as types can only be added by data definitions.

\subsubsection{Codata Fragment}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. It will be demonstrated why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if" direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. That the second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if" direction. By the rules of the judgement, a value can also be a destructor application if it has codata type and doesn't match any rule of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage for all subterms of the input term, since those are the only ones that can be relevant for the value judgement in the one-step reduction.

\section{Semantics preservation}

TODO: The bisimulation statement presupposes that the one-step reduction relation is a partial function. Change it accordingly.

In this section it is shown that the transformations above preserve the semantics of programs in a kind of weak bisimulation. Precisely, for all transformations indicated by angular brackets, it holds for all closed input terms $s, t$ and all programs $prg$ that:

$s \longrightarrow_{prg} t \implies \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle$ (1)

and

the reduction sequence from $\langle s \rangle$ to $\langle t \rangle$ in (1), contains no terms, except possibly $\langle s \rangle$ and $\langle t \rangle$, that typecheck against $prg$ (2)

and

when $s$ doesn't reduce to anything in $prg$, then there is no infinite reduction sequence starting with $\langle s \rangle$ in $prg$ (3)

and

when $s, t$ typecheck against $prg$: $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \implies s \longrightarrow_{prg} t$ (4)

When one-step reduction is viewed as state transition, with $prg$ and $\langle prg \rangle$ standing for two different transition systems, the statements above describe the precise kind of their bisimilarity.

Statements (1) to (3) stand for the direction from $prg$ to $\langle prg \rangle$. (1) means that every state of $prg$ has a corresponding state in $\langle prg \rangle$, but there can be internal states (intermediate in the transition). (2) guarantees that these internal states are in fact internal, that is, they have no corresponding states in $prg$. (3) accounts for the fact that internal actions might sometimes apply to a state that corresponds to one in $prg$ but not lead to another such corresponding state. This case cannot be altogether avoided by all of the transformations, but at least be made less problematic by not allowing an infinite progression of internal transitions only.

Statement (4) stands for the direction from $\langle prg \rangle$ to $prg$. It means that when a state in $\langle prg \rangle$ has a corresponding state in $prg$, it behaves like it, that is, when there is a transition from it to another state with a corresponding state, there also is a transition between the corresponding states.

(1) is always shown in the following way:

Suppose that: $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, \\
show that: there exist derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} t_1, t_1 \longrightarrow_{\langle prg \rangle} t_2, ..., t_{n-1} \longrightarrow_{\langle prg \rangle} \langle t \rangle$, respectively

For some transformations, strong bisimulation holds, precisely, the following holds for all closed terms $s, t$:

$ s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$

Strong bisimulation implies the weak kind of bisimulation as given by (1), (2) and (3). It is always shown in its stead whenever possible. The proof of each side of strong bisimulation proceeds analogously to that of (1) (but always with $n = 1$).

It's always assumed that the program that is transformed is well-typed. It also is assumed that no term is stuck, i.e., it can either be reduced or is a value.

Note/TODO: The well-typedness of the transformed program will be shown in a separate section.

For the proofs of these properties the following lemmas will be needed:

\begin{lemma}[Inversion lemma for pattern matching]

Let $\mathcal{D}$ be a derivation of $t =^? q \searrow \sigma$.

\begin{enumerate}

\item If $q = x$ then $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\item If $q = con(p_1, ..., p_n)$ then $t = con(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = fun(p_1, ..., p_n)$ then $t = fun(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = q'.des(p_1, ..., p_n)$ then $t = t'.des(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t =^? q \searrow \sigma$}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\end{enumerate}

\begin{proof}~

\begin{enumerate}

\item A matched pattern that is a variable doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Var}. Thus the derivation can only be the result of the application of this single rule.

\item A matched pattern that is a constructor application doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Con}. Thus the derivation can only be the result of the application of this rule, and of the rules leading to the premises of this rule.

\item Analogous to 2.

\item Analogous to 2.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma} Let $e$ be a helper extraction function, i.e. a function that can be an argument of $extract\_helpers$ as defined in section 1. For any program $prg$ and any two closed terms $s,t$ with $s =^? q \searrow \sigma$, $s'[\sigma] = t$ for a rule $(q, s') \in \textrm{Rules}(prg)$ it holds that:

If $\langle (q, s') \rangle^e = \big\langle r, H \big\rangle$ such that there is a reduction sequence from $s$ to $t$ with respect to $\{ r \} \cup \{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$,

then $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.

\begin{proof}

Let the conditions be satisfied. As we can see in the definition of $extract\_helpers$, for every equation $eqn$ in the original program, the transformed program contains the equation $r$ and the equations in the set $\{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$, with $\big\langle r, H \big\rangle = \langle eqn \rangle^e$. Thus there is a reduction sequence from $s$ to $t$ with respect to the equations of the transformed program: $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.

\end{proof}

\end{lemma}

\begin{lemma}

If there is a reduction sequence from $s$ to $t$ with respect to $\{ r \} \cup \{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$ for a pair $\big\langle r, H \big\rangle$,

then there is a reduction sequence from $s$ to $t$ with respect to $\langle r, H \rangle^{extract\_des}$.

\begin{proof}

\begin{itemize}

\item \underline{Case 1}: There exists a reduction sequence from $s$ to $t$ with respect to $\{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$.

It is $\langle r, H \rangle^{extract\_des} = \big\langle r', H' \cup H \big\rangle$ for some (possibly empty) helpers set H' and some (possibly equal to r) equation r'. Thus the equations in this result are a superset of those within $H$. Since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the reduction sequence that exists with respect to the equations within H exists also with respect to this superset.

\item \underline{Case 2}: The reduction sequence from $s$ to $t$ depends upon the equation $r$. It therefore contains at least one reduction step where the derivation contains an application of the ``Subst" rule for $r$.

Let $r := `` q' = s' "$, and the reduction sequence be:

$t_1 \longrightarrow t_2 \longrightarrow ... \longrightarrow t_{n-1} \longrightarrow t$

with $t_1 = s$, $t_n = t$.

In the case where $\langle r, H \rangle^{extract\_des} = \big\langle r, H \big\rangle$, that is, $q'$ is hole pattern, the resulting equations have not changed and thus a reduction sequence trivially exists with respect to them: It is the same sequence as given above.

Next, consider the case where $q'$ is $q.des(p_1, ..., p_k)$, and thus $\langle r, H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle$, with $hname$, $hsig$, $heqn$ as in the definition of $extract\_des$. Especially it is $heqn = `` q_h = s' "$, with $q_h$ defined as $hname(\langle q \rangle^{vars}).des(p_1, ..., p_k)$. The sequence with respect to the equations in this result can be constructed as follows:

\begin{enumerate}

\item Let $I \subseteq \{1, ..., n - 1\}$ be the set of indices $j$ where $t_j \longrightarrow t_{j+1}$ contains an application of the ``Subst" rule for $r$. For all indices $k \not\in I$, $t_k \longrightarrow t_{k+1}$ is with respect to the equations within $H$.

\item Without loss of generality, let there be only one application of the ``Subst" rule for $r$ in the derivation. When there is more than one such application, simply repeat this construction until they are all dealt with. For a $j \in I$, by inversion, we know the derivation of $t_j \longrightarrow t_{j+1}$ looks as follows:

\begin{prooftree}
\AxiomC{$t'^0_j =^? q \searrow \sigma_0$}
\AxiomC{$t^{1,1}_j =^? p_1 \searrow \sigma_1$}
\AxiomC{...}
\AxiomC{$t^{1,k}_j =^? p_k \searrow \sigma_k$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\QuaternaryInfC{$t^0_j =^? q' \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q', s')$}
\UnaryInfC{$t^0_j \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}$}
\UnaryInfC{$t_j \longrightarrow t_{j+1}$}
\end{prooftree}

with $\sigma = \sigma_0, \sigma_1, ..., \sigma_k$, for some intermediate derivation $\mathcal{D'}$ and a subterm $t^0_j$ of $t_j$. By inversion, we know that $t^0_j = t'^0_j.des(t^{1,1}_j, ..., t^{1,k}_j)$.

\item In the original sequence above, for every $j \in I$, replace $t_j \longrightarrow t_{j+1}$ with the two reduction steps $t_j \longrightarrow t'_j$, $t'_j \longrightarrow t_{j+1}$, in this order, with the following derivations:

Derivation for $t_j \longrightarrow t'_j$:
\begin{prooftree}
\AxiomC{$t'^0_j =^? q \searrow \sigma_0$}
\RightLabel{\scriptsize Subst with $(q, `` hname(\langle q \rangle^{vars}) ")$}
\UnaryInfC{$t'^0_j \longrightarrow `` hname(\langle q \rangle^{vars}) "[\sigma_0]$}
\RightLabel{\scriptsize $\longrightarrow$\textsubscript{Des\textsubscript{P}}}
\UnaryInfC{$t^0_j \longrightarrow t_h$}
\UnaryInfC{$\mathcal{D'}_1$}
\UnaryInfC{$t_j \longrightarrow t'_j$}
\end{prooftree}

where $\mathcal{D'}_1$ is $\mathcal{D'}$ where all the occurrences of $s'[\sigma]$ that stem from the reduction by substitution of $t^0_j$ to it are replaced by $t_h := `` hname(\langle q \rangle^{vars}) "[\sigma'].des(t^{1,1}_j, ..., t^{1,k}_j)$. $t'_j$ is defined accordingly.

For the next derivation, remember that $q_h = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) "$ and $heqn = `` q_h = s'  "$. 

Derivation for $t'_j \longrightarrow t_{j+1}$:
{\setlength{\parindent}{-\leftmargin}

\AxiomC{$`` hname(\langle q \rangle^{vars}) "[\sigma_0] =^? `` hname(\langle q \rangle^{vars}) " \searrow \sigma_0$}
\AxiomC{$t^{1,1}_j =^? p_1 \searrow \sigma_1$}
\AxiomC{...}
\AxiomC{$t^{1,k}_j =^? p_k \searrow \sigma_k$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\QuaternaryInfC{$t_h =^? q_h \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q_h, s')$}
\UnaryInfC{$t_h \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}_2$}
\UnaryInfC{$t'_j \longrightarrow t_{j+1}$}
\DisplayProof
}

where $\mathcal{D'}_2$ is $\mathcal{D'}$ where all the occurrences of $t^0_j$ that stem from its reduction by substitution to $s'[\sigma]$ are replaced by $t_h$.

\end{enumerate}

\end{itemize}

\end{proof}

\end{lemma}

Exemplary, the proof of strong bisimulation for the transformation $split$ is given below.

\subsection{Split}

\begin{proof}[Proof of strong bisimulation, ``$\Rightarrow$"] ~

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_1$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$; it is $\langle s \rangle = s$ and $\langle t \rangle = t$ ($split$ doesn't change input terms).

For this, define $\mathcal{D}_1$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(\langle prg \rangle)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(\langle prg \rangle)$ as well as in Rules$(prg)$, since $split$ doesn't change rules where the copattern has this form. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(con(x_1, ..., x_k), y_1, ..., y_n)$:

The argument here is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(x_1, x_2, ..., x_n)$, where $x_1$ has codata type or $n = 0$:

The argument here is identical to that in Case 1.

\item \underline{Case 4}: $q = fun(x_1, x_2, ..., x_n)$, where $n > 0$, $x_1$ has data type:

Since $(q, s') \in \textrm{Rules}(prg)$ there exists a $(q_2, s_2') \in \textrm{Rules}(\langle prg \rangle)$ with $q_2 = fun(con(y_1, ..., y_k), x_2, ..., x_n)$ and $s'_2 = s'[con(y_1, ..., y_k) / x_1]$ for every constructor $con$ with the correct type (i.e. with return type equal to the type of the first argument of $fun$). This can also be seen directly in the definition of $split$. The concrete choice of $q_2$ depends upon the choice of $con$ -- below, $con$ will be chosen as needed.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 1}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 1}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:

\begin{prooftree}
\AxiomC{$t_1 =^? x_1 \searrow t_1 / x_1$}
\AxiomC{...}
\AxiomC{$t_n =^? x_n \searrow t_n / x_n$}
\TrinaryInfC{$fun(t_1, ..., t_n) =^? q \searrow t_1 / x_1, ..., t_n / x_n$}
\end{prooftree}

With that, we also know the form of $s$: $s = fun(t_1, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 1}$ as follows:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t_1^1 =^? y_1 \searrow t_1^1 / y_1$}
\AxiomC{...}
\AxiomC{$t_k^1 =^? y_k \searrow t_k^1 / y_k$}
\TrinaryInfC{$t_1 =^? con(y_1, ..., y_k) \searrow t_1^1 / y_1, ..., t_k^1 / y_k$}
\AxiomC{$t_2 =^? x_2 \searrow t_2 / x_2$}
\AxiomC{...}
\AxiomC{$t_n =^? x_2 \searrow t_n / x_n$}
\QuaternaryInfC{$fun(t_1, ..., t_n) =^? q_2 \searrow t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  
t_n / x_n$}
\DisplayProof
}

Remember that the choice of $con$ and, depending upon that, $q_2$, was left open until needed. This is now the place where $con$ needs to be chosen such that $t_1 = con(t^1_1, ..., t^1_k)$, with the result that the derivation $\mathcal{D}_{\textrm{PM}, 1}$ given above is correct.

It is still open why $t_1$ can be chosen that way at all. To see this, consider the following cases: If $t_1$ is a variable, $s$ isn't a closed term, which is excluded by definition. If $t_1$ isn't a variable but also not a value, then the ``Subst" rule wouldn't even apply. The only case that remains is that $t_1$ is a value that has data type. By inversion (TODO: prove lemma of inversion for values) we know that $t_1$ is a constructor application of a constructor $con$. Since $t_1$ has the correct type, this same constructor $con$ can simply be chosen, as stated above.

In the derivation above, $\sigma_2 = t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  t_n / x_n$ and thus:

$s'_2[\sigma_2] = s'[con(y_1, ..., y_k) / x_1][\sigma_2] \\
= s'[con(t_1^1, ... t_k^1) / x_1, t_2 / x_2, ..., t_n / x_n] = s'[t_1 / x_1, t_2 / x_2, ..., t_n / x_n] = s'[\sigma] = t$

There is no conflict between the substitutions for, e.g., $x_2$ and $y_1$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

Other cases for $q$ are outside the relevant input fragment for $split$. (TODO: Define this fragment and others and prove for every transformation: that the image of this transformation is a subset of the relevant input fragment of the next transformation.) This concludes the proof for the ``Subst" case.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $s' \longrightarrow_{\langle prg \rangle} t'$. By applying the congruence rule we get $\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$.

\end{enumerate}

\end{proof}

\begin{proof}[Proof of strong bisimulation, ``$\Leftarrow$"] ~

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$ ($\langle s \rangle = s, \langle t \rangle = t$); the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_1$ for $s \longrightarrow_{prg} t$.

For this, define $\mathcal{D}_1$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow_{prg} s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(prg)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(prg)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(prg)$ as well as in Rules$(\langle prg \rangle)$, since the result of $split$ doesn't contain a rule where the left-hand side copattern has this form unless the input of $split$ already contains this rule. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(x_1, ..., x_n)$:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(con(x_1, ..., x_k), y_2, ..., y_n)$:

Then there either exists $(q, s')$ in Rules($prg$) as well, in this case proceed as in Case 1, or there exists $q_2 := fun(y_1, y_2, ..., y_n)$, ($q_2, s'_2) \in \textrm{Rules}(prg)$, $s' = s'_2[con(x_1, ..., x_k) / y_1]$. This is because these are the only cases in which a rule with left-hand side copattern $q$ of this form is present in Rules($\langle prg \rangle$), as can be seen directly in the definition of $split$.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 1}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 1}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t^1_1 =^? x_1 \searrow t^1_1 / x_1$}
\AxiomC{...}
\AxiomC{$t^1_k =^? x_k \searrow t^1_k / x_k$}
\TrinaryInfC{$con(t^1_1, ..., t^1_k) =^? con(x_1, ..., x_k) \searrow t^1_1 / x_1, ..., t^1_k / x_k$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2 ..., t_n) =^? q \searrow t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$}
\DisplayProof
}

With that, $\sigma = t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$ and we also know the form of $s$: $s = fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 1}$ as follows:

\begin{prooftree}
\AxiomC{$con(t^1_1, ..., t^1_k) =^? y_1 \searrow con(t^1_1, ..., t^1_k) / y_1$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n) =^? q_2 \searrow \sigma_2$}
\end{prooftree}

In the derivation above, $\sigma_2 = con(t_1^1 ..., t_k^1) / y_1,  t_2 / y_2, ...,  t_n / y_n$ and thus:

$t = s'[\sigma] = s'_2[con(x_1, ..., x_k) / y_1][\sigma] = s'_2[con(t^1_1, ..., t^1_k) / y_1, t_2 / y_2, ..., t_n / y_n] = s'_2[\sigma_2]$

There is no conflict between the substitutions for, e.g., $x_1$ and $y_2$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

This concludes the proof for the ``Subst" case.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $s' \longrightarrow_{prg} t'$. By applying the congruence rule we get $\mathcal{E}[s'] \longrightarrow_{prg} \mathcal{E}[t']$.

\end{enumerate}

\end{proof}

\subsection{Eliminate multiple destructors}

For step $elim\_multi\_des$, the described kind of weak bisimulation holds.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

It will be shown: there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\langle `` q = s' " \rangle^{extract\_outer\_des}$. Using Lemma 2 for $e = extract\_outer\_des$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$.

By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the structure of $q$:

If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_outer\_des}$.

Proof by induction:

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

$\langle `` q = s' ", H \rangle^{extract\_outer\_des} = \big\langle `` q = s' ", H \big\rangle$

Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.

\item \underline{Case 2}: $q = q'.des(p_1, ..., p_k)$, $q'$ is hole pattern:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = q'.des(p_1, ..., p_k)$, $q'$ is destructor pattern:

$\langle `` q = s' ", H \rangle^{extract\_outer\_des} = \langle \langle `` q = s' ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des}$

By Lemma 3, since there is a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also is such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_des}$. 

From the definition of $extract\_des$ we have that:

$\langle `` q = s' ", H \rangle^{extract\_des} = \langle `` q'.des(p_1, ..., p_k) = s' ", H \rangle^{extract\_des} = \big\langle `` q' = t_h ", H' \big\rangle$ for some term $t_h$ and some helpers set $H'$. 

We thus have a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q' = t_h ", H' \big\rangle$. By the induction hypothesis, applied to $q'$, we have the reduction sequence with respect to $\langle `` q' = t_h ", H' \rangle^{extract\_outer\_des}$, which is the desired sequence.

\end{itemize}

This concludes the proof for the ``Subst" case.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $s' \longrightarrow_{\langle prg \rangle} t'$. By applying the congruence rule we get $\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$.

\end{enumerate}

\end{proof}

Note that the ``Cong" case doesn't depend upon the concrete transformation. Thus it can be reused in proofs of (1) for other transformations such that only the proof for the ``Subst" case needs to be given individually for each proof.

\begin{proof}[Proof of (2)] By inspecting the proof of (1).

\begin{enumerate}

\item \textbf{``Subst" case}:

Lemma 2 returns the relevant sequence by leaving the sequence constructed in the rest of the proof unchanged.

This sequence is constructed inductively, on the structure of $q$, starting with the original single-step sequence $s \longrightarrow_{prg} t$. In Case 1 and 2 of this induction, the sequence returned is the one from the induction hypothesis, unchanged.

The interesting case is Case 3, where the sequence is constructed by Lemma 3 from the one from the induction hypothesis. Lemma 3 itself is only interesting when $extract\_des$ changes the equations, otherwise, it returns the sequence it is given. The relevant construction is described in the lemma in three steps.

The first partitions the given sequence steps. The ones that don't contain an application of the relevant ``Subst" rule are left unchanged. But they only use equations within $H$, the given helpers set. Again, by inspecting this proof, one can see that only the equations for $extract\_outer\_des$ are used to add equations to the helpers set. Thus they always depend upon the presence of a helper function which has a fresh name (different from all names in $prg$) and therefore doesn't typecheck against $prg$.

Each sequence step in the other part of the partition is always replaced by two one-step reductions. The first of those starts at a term containing a call to a helper function which has a fresh name (different from all in $prg$) and therefore doesn't typecheck against $prg$. The second reduction both starts and ends at a term containing a call to this helper functions and therefore doesn't typecheck against $prg$, either.

\end{enumerate}

TODO: the other cases

\end{proof}

\begin{proof}[Proof of (3)] TODO

\end{proof}

\subsection{Unmix (defunc.)}

For step $unmix_d$, the described kind of weak bisimulation holds.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}

\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

\begin{itemize}

\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.

Then, since $unmix_d$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.

\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.

It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_des}$. Using Lemma 2, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_d$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.

What follows is the proof for the above statement. From the precondition of the ``Subst" case we have that $s$ reduces to $t$ using only $`` q = s' "$. Using Lemma 3 we have the desired sequence from $s$ to $t$ using only the rules from $\langle `` q = s' " \rangle^{extract\_des}$.

\end{itemize}

\end{enumerate}

For the ``Cong" case, proceed as with $elim\_multi\_des$.

\end{proof}

\subsection{Disentangle (defunc.)}

For step $disentangle_d$, the described kind of weak bisimulation holds.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}

\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_patterns}$. Using Lemma 2, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $disentangle_d = extract\_helpers(extract\_patterns)$.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

$\langle `` q = s' " \rangle^{extract\_patterns} = \big\langle `` q = s' ", \emptyset \big\rangle$

Thus the only resulting equation is the same as the original equation, for which we already know (from the precondition of the ``Subst" case) that the desired (one-step) reduction sequence exists.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\not\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:

$\langle q \rangle^{extract\_patterns}$\\
$= \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{ \big\langle hsig, heqn \big\rangle \} \big\rangle $

with $hname, hsig, heqn$ as in the definition of $extract\_patterns$.

By inversion we have the following form for $\mathcal{D}_{\textrm{PM}}$:
\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{\scriptsize PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\AxiomC{$t'_i =^? p'_i \searrow \sigma'_i ~ \forall i \in \{1, ..., k\}$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\BinaryInfC{$fun(t_1, ..., t_n).des(t'_1, ..., t'_k) =^? fun(p_1, ..., p_n).des(p'_1, ..., p'_k) \searrow \sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k$}
\end{prooftree}

We also have that $s = `` fun(t_1, ..., t_n).des(t'_1, ..., t'_k) "$ and $t = s'[\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k]$. The desired sequence from $s$ to $t$ can thus be given as follows:

$s \longrightarrow hname(t_1, ..., t_n, t'_1, ..., t'_k) \longrightarrow t$

The first reduction step can be derived as follows, using only

$r := `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) "$:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{}
\RightLabel{\scriptsize PM\textsubscript{Var}}
\UnaryInfC{$t_i =^? x_i \searrow t_i / x_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{\scriptsize PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(x_1, ..., x_n) \searrow t_1 / x_1, ..., t_n / x_n$}
\AxiomC{}
\RightLabel{\scriptsize PM\textsubscript{Var}}
\UnaryInfC{$t'_i =^? x'_i \searrow t'_i / x'_i ~ \forall i \in \{1, ..., k\}$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\BinaryInfC{$s =^? fun(x_1, ..., x_n).des(x'_1, ..., x'_k) \searrow t_1 / x_1, ..., t_n / x_n, t'_1 / x'_1, ..., t'_k / t'_k$}
\RightLabel{\scriptsize Subst with $r$}
\UnaryInfC{$s \longrightarrow ``hname(x_1, ..., x_n, x'_1, ..., x'_k)"[t_1 / x_1, ..., t_n / x_n, t'_1 / x'_1, ..., t'_k / t'_k]$}
\DisplayProof
}

It is clear that

$`` hname(x_1, ..., x_n, x'_1, ..., x'_k) "[t_1 / x_1, ..., t_n / x_n, t'_1 / x'_1, ..., t'_k / t'_k] = `` hname(t_1, ..., t_n, t'_1, ..., t'_k) "$.

The second reduction step can be derived as follows below, using only $heqn$. Remember that $heqn = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = s' "$.
\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\AxiomC{$t'_i =^? p'_i \searrow \sigma'_i ~ \forall i \in \{1, ..., k\}$}
\RightLabel{\scriptsize PM\textsubscript{App}}
\BinaryInfC{$hname(t_1, ..., t_n, t'_1, ..., t'_k) =^? hname(p_1, ..., p_n, p'_1, ..., p'_k) \searrow \sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k$}
\RightLabel{\scriptsize Subst with $heqn$}
\UnaryInfC{$hname(t_1, ..., t_n, t'_1, ..., t'_k) \longrightarrow s'[\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k]$}
\end{prooftree}

As stated above, $t = s'[\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k]$.

\end{itemize}

\end{enumerate}

For the ``Cong" case, proceed as with $elim\_multi\_des$.

\end{proof}

\subsection{Unmix (refunc.)}

For step $unmix_r$, the described kind of weak bisimulation holds.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}

\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

\begin{itemize}

\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.

Then, since $unmix_r$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.

\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.

It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_all\_des}$. Using Lemma 2, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_r$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.

What follows is the proof for the above statement. By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the structure of $q$:

If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_all\_des}$.

Note the similarity between the definitions of $extract\_outer\_des$ and $extract\_all\_des$: The only difference is the distinction between outer and single destructor calls in $extract\_outer\_des$. This similarity will be used in the proof below.

Proof by induction:

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

$\langle `` q = s' ", H \rangle^{extract\_all\_des} = \big\langle `` q = s' ", H \big\rangle$

Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.

\item \underline{Case 2}: $q = q'.des(p_1, ..., p_k)$:

The argument here is identical to that of Case 3 in the induction concerning $extract\_outer\_des$, inside the ``Subst" case of the proof of (1) for $elim\_multi\_des$, with $extract\_all\_des$ substituted for $extract\_outer\_des$.

\end{itemize}

\end{itemize}

\end{enumerate}

For the ``Cong" case, proceed as with $elim\_multi\_des$.

\end{proof}

\subsection{Disentangle (refunc.)}

For step $disentangle_r$, the described kind of weak bisimulation holds.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

It will be shown: there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\langle `` q = s' " \rangle^{extract}$. Using Lemma 2 for $e = extract$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $disentangle_r = extract\_helpers(extract)$.

By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the number of constructor patterns appearing in $q$.

If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract}$.

Proof by induction:

\begin{itemize}

\item \underline{Case 1:} 0 constructor patterns appear in $q$:

Then the first two cases of the definition of $extract$ are not effective, since they depend upon the presence of at least one constructor pattern in $q$. It follows that the third case (``otherwise") of the definition is effective:

$\langle `` q = s' ", H \rangle^{extract} = \big\langle `` q = s' ", H \big\rangle$

Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.

\item \underline{Case 2:} $n+1$ constructor pattern appear in $q$, with $n \geq 0$:

\begin{itemize}

\item \underline{Case 2.1}: $q = fun(p^0_1, ..., p^0_n).des_1(p^1_1, ..., p^1_{n_1})...des_k(p^k_1, ..., p^k_{n_k})$, $k \geq 1$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:

$\langle `` q = s' ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}$

with $hname, hsig, heqn$ as in the definition of $extract$.

Compared to $q$, $q^{-con}$ has one less constructor pattern. Thus we can apply the induction hypothesis to $q^{-con}$, yielding a reduction sequence from $s$ to $t$ using only the equations within $\langle `` q = s' ", H \rangle^{extract}$ if there is one with respect to $\big\langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle$.

This last sequence can be constructed as in the following steps, somewhat analogous to the construction in Lemma 3. The construction starts from the known original sequence with respect to $\big\langle `` q = s' ", H \big\rangle$; let this sequence be:

$t_1 \longrightarrow t_2 \longrightarrow ... \longrightarrow t_{n-1} \longrightarrow t$

with $t_1 = s$, $t_n = t$. Also, let $r := (q, s')$.

\begin{enumerate}

\item Let $I \subseteq \{1, ..., n - 1\}$ be the set of indices $j$ where $t_j \longrightarrow t_{j+1}$ contains an application of the ``Subst" rule for $r$. For all indices $k \not\in I$, $t_k \longrightarrow t_{k+1}$ is with respect to the equations within $H$.

\item For a $j \in I$, by inversion, we know the derivation of $t_j \longrightarrow t_{j+1}$ looks as follows:

\begin{prooftree}
\AxiomC{\vdots}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\UnaryInfC{$t^0_j =^? q \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q, s')$}
\UnaryInfC{$t^0_j \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}$}
\UnaryInfC{$t_j \longrightarrow t_{j+1}$}
\end{prooftree}

for some substitution $\sigma$, some intermediate derivation $\mathcal{D'}$ and a subterm $t^0_j$ of $t_j$.

\item In the original sequence above, for every $j \in I$, replace $t_j \longrightarrow t_{j+1}$ with the two reduction steps $t_j \longrightarrow t'_j$, $t'_j \longrightarrow t_{j+1}$, in this order, with the following derivations:

Derivation for $t_j \longrightarrow t'_j$:
\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t^0_j =^? q^{-con} \searrow \sigma'$}
\RightLabel{\scriptsize Subst with $(q^{-con}, `` hname(q^{-con}_{vars^+}) ")$}
\UnaryInfC{$t^0_j \longrightarrow t_h$}
\UnaryInfC{$\mathcal{D'}_1$}
\UnaryInfC{$t_j \longrightarrow t'_j$}
\end{prooftree}

The derivation for $t^0_j =^? q^{-con} \searrow \sigma'$, for some substitution $\sigma'$ has been omitted. We know from above that $t^0_j$ matches against $q$ returning $\sigma$. $q^{-con}$ is simply $q$ with one of its patterns $p$ replaced by a variable $x_p$, thus it catches at least all terms which are caught by $q$. $\sigma'$ is $\sigma$ where the part $\sigma_p$ of the substitution returned by matching the relevant subterm $t_p$ against $p$ is replaced by $t_p / x_p$. Let $x_1, ..., x_n$ be the variables in $q^{-con}$. It is $\sigma = \sigma_p, \sigma'[\{ x_1, ..., x_n \} \setminus \{ x_p \}]$, where $\sigma'[S]$ for a set $S$ means the substitutions of $\sigma'$ limited to those for variables in $S$.

$\mathcal{D'}_1$ is $\mathcal{D'}$ where all the occurrences of $s'[\sigma]$ that stem from the reduction by substitution of $t^0_j$ to it are replaced by

$t_h := `` hname(q^{-con}_{vars^+}) "[\sigma']$.

$t'_j$ is defined accordingly.

For the next derivation, let $q_h = `` hname(q^{-con}_{vars^-}) "$. Thus it is $heqn = `` q_h = s'  "$. 

Let $k$ be the index of $x_p$, that is $x_p = x_k$, and $(y_1, ..., y_m)$ be the list $(x_1, ..., x_{k-1}, x_{k+1}, ..., x_n)$ ($m = n-1$). The list $q^{-con}_{vars^+}$ is, by definition, $(x_p, y_1, ..., y_m)$. The list $q^{-con}_{vars^-}$ is $(p, y_1, ..., y_m)$. Note that for the $\sigma'$ described above, $x_p[\sigma'] = t_p$. In the derivation below, the derivation for $x_p[\sigma'] =^? p \searrow \sigma_p$, with $\sigma_p$ as described above, has thus been omitted.

Derivation for $t'_j \longrightarrow t_{j+1}$:

{\setlength{\parindent}{-\leftmargin}
\AxiomC{\vdots}
\UnaryInfC{$x_p[\sigma'] =^? p \searrow \sigma_p$}
\AxiomC{}
\RightLabel{\scriptsize PM\textsubscript{Var}}
\UnaryInfC{$y_1[\sigma'] =^? y_1 \searrow \sigma'[y_1]$}
\AxiomC{...}
\AxiomC{}
\RightLabel{\scriptsize PM\textsubscript{Var}}
\UnaryInfC{$y_m[\sigma'] =^? y_m \searrow \sigma'[y_m]$}
\RightLabel{\scriptsize PM\textsubscript{App}}
\QuaternaryInfC{$t_h =^? q_h \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q_h,  s')$}
\UnaryInfC{$t_h \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}_2$}
\UnaryInfC{$t'_j \longrightarrow t_{j+1}$}
\DisplayProof
}

where $\mathcal{D'}_2$ is $\mathcal{D'}$ where all the occurrences of $t^0_j$ that stem from its reduction by substitution to $s'[\sigma]$ are replaced by $t_h$.



\end{enumerate}

\item \underline{Case 2.2}: $q = fun(con(p^0_1, ..., p^0_n), p^1_1, ..., p^1_n)$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:

This case proceeds completely analogous to Case 2.1, where a left-most outer constructor pattern is skipped over. This is possible since second case of the definition of $extract$, which is effective in this case, is only different in exactly this way: All relevant definitions are precisely analogous to the respective other definitions.

\item \underline{Case 2.3}: otherwise:

Since neither the first (as in Case 2.1) nor the second (as in Case 2.2) case of the definition of $extract$ is effective, it follows that the third case (``otherwise") is effective. Thus, proceed as in Case 1.

\end{itemize}

\end{itemize}

\end{enumerate}

For the ``Cong" case, proceed as with $elim\_multi\_des$.

\end{proof}

\subsection{Actual defunctionalization}

For the actual defunctionalization, $d''$, strong bisimulation holds. The proof relies on properties of the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $d^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $d^{core}$, the Codata Fragment, and, analogously, when restricted to the domain of their refunctionalization, the Data Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $d^{core}$.

\begin{proof}[Proof of strong bisimulation for $d''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$). Such equations (and indeed the function definitions) are left unchanged by $d''$ except for defunctionalizing the right-hand term, as can be seen directly in the definition of $d''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

By inversion, we have from $s =^? q \searrow \sigma$ that $s$ has the form $fun(v_1, ..., v_n)$ for some values $v_1, ..., v_n$, thus $\langle s \rangle = fun(\langle v_1 \rangle, ..., \langle v_n \rangle)$. By inversion for values, we have that each $v_i$ is either a constructor application or a value of codata type. If it is a value of codata type, by inversion on pattern matching, the relevant subpattern of $q$ can only be a variable, thus it is also matched by $\langle v_i \rangle$. If it is a constructor application, the relevant subpattern of $q$ is either a variable, and the same holds, or it is a constructor pattern, and by recursively descending into its subpatterns we still get that $\langle v_i \rangle = con(\langle v^1_i \rangle, ..., \langle v^m_n \rangle)$ matches against the subpattern of $q$.

By carrying the substitutions returned from the matchings along in the above recursive argument, we get a substitution $\sigma'$ such that $\langle s \rangle =^? q \searrow \sigma'$ and, by distributing over $\langle s' \rangle$, $\langle s' \rangle [\sigma'] = \langle s'[\sigma] \rangle = \langle t \rangle$. It follows that $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $d''$). Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $d^{core}$, as specified in the definition of $d''$. Let this part, amended by the ``constructor subsumption" noted for the definition of $d''$, be $prg'$; it is: $s \longrightarrow_{prg'} t$

By (*) we would have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. 

For the coverage, bear in mind that the equation $`` q = s' "$ enabling the reduction of $s$ by the ``Subst" rule is part of $prg'$ by the precondition of Case 2. As $s$ matches against $q$, copattern coverage for $s$ is trivially fulfilled in $prg'$. The immediate subterms of $s$ are values with respect to $prg$ and, by inversion, their immediate subterms and so forth, which especially means that there is no rule in $prg$ against which they match. But $prg$ has copattern coverage for such a subterm (TODO: make this a general precondition) and there is already no rule for it in $prg$. It follows that $prg'$ still has copattern coverage for the subterm even though there is no rule for it in $prg'$. This is because, either (1) the subterm is a destructor call, then it can only be covered by destructor copatterns (as it matches against a destructor copattern) and those only occur within $prg'$, or (2) it is a constructor call, which doesn't need to be matched for coverage. It can't be a function call, since these can only be covered by directly matching the call, which isn't the case even in $prg$, for which coverage is assumed. Thus coverage holds for $prg'$.

For well-typedness, simply treat the missing types temporarily, that is, for the sake of (*), as codata types. This is no problem for the restriction to the domain of $d^{core}$, since such types could be introduced inside the Codata Fragment with codata definitions. To be more precise, empty function definitions can be added for missing ones and empty codata definitions for missing types, and removed again after using (*), without adding or removing possible reductions, respectively. All in all, we have by (*):
\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle
\end{equation*}

But this program $\langle prg' \rangle^{d^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $d''$. This implies the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

Other cases are excluded by the relevant input fragment.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $\langle s' \rangle \longrightarrow_{\langle prg \rangle} \langle t' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$, defined analogously to the transformation of terms by transforming the terms in $\mathcal{E}$ and by setting $\langle [] \rangle = []$. By applying the congruence rule we get $\langle \mathcal{E} \rangle[\langle s' \rangle] \longrightarrow_{\langle prg \rangle} \langle \mathcal{E} \rangle[\langle t' \rangle]$. It is clear that $\langle \mathcal{E} \rangle[\langle s' \rangle] = \langle \mathcal{E}[s'] \rangle = \langle s \rangle$ and $\langle \mathcal{E} \rangle[\langle t' \rangle] = \langle \mathcal{E}[t'] \rangle = \langle t \rangle$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part of $prg$, as specified in the definition of $d''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $d''$, this other part is taken over unchanged from $prg$ except for defunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle$.

By (*) we would have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle \iff s \longrightarrow_{prg'} t,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. Both of those properties can be shown or simulated similarly to the way they are in the $`` \Rightarrow "$ part.

But it is $prg' \subseteq prg$, as can be seen in the definition of $d''$. This implies the desired $s \longrightarrow_{prg} t$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = \langle s \rangle$ and $\mathcal{E}[t'] = \langle t \rangle$.

By the induction hypothesis we have $s'' \longrightarrow_{prg} t''$ with $s' = \langle s'' \rangle$, $t' = \langle t'' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$ (defined as in the $`` \Rightarrow "$ part). Apply the congruence rule to get $\mathcal{E}'[s''] \longrightarrow_{prg} \mathcal{E}'[t'']$ with $\mathcal{E} = \langle \mathcal{E}' \rangle$. That is, $\mathcal{E}'$ is the result of applying the inverse of $\langle \cdot \rangle$ to $\mathcal{E}$, which is possible, since, for instance, $\mathcal{E}[s'] = \langle s \rangle$. It is $\langle \mathcal{E}'[s''] \rangle = \langle \mathcal{E}' \rangle[\langle s'' \rangle] = \mathcal{E}[s'] = \langle s \rangle$ and $\langle \mathcal{E}'[t''] \rangle = \langle \mathcal{E}' \rangle[\langle t'' \rangle] = \mathcal{E}[t'] = \langle t \rangle$ and thus we have the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\end{proof}

\subsection{Actual refunctionalization}

For the actual refunctionalization, $r''$, strong bisimulation holds. The proof relies on properties of the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $r^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $r^{core}$, the Data Fragment, and, analogously, when restricted to the domain of their defunctionalization, the Codata Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $r^{core}$.

\begin{proof}[Proof of strong bisimulation for $r''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2 (it is omitted that $prg$ is passed to $r$ as well). This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is destructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $r''$). Such equations (and indeed the function definitions) are left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

From here, the argument proceeds analogously to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

\item \underline{Case 2}: $q$ is hole pattern without arguments or where the first argument has codata type:

Then the equation is left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Proceed as in Case 1.

\item \underline{Case 3}: $q$ is hole pattern and has a first argument with data type:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$), and it has a first argument with data type. Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $des\_conv$, and then the result of this to $r^{core}$, as specified in the definition of $r''$. Let the part passed to $des\_conv$ be $prg'$; it is: $s \longrightarrow_{prg'} t$.

By (*) we have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{r^{core}}} \langle t \rangle,
\end{equation*}

But this program $\langle prg' \rangle^{r^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $r''$. Thus we have the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2. This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part of $prg$, as specified in the definition of $r''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $r''$, this other part is taken over unchanged from $prg$ except for refunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle$.

By (*) we have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle \iff s \longrightarrow_{\langle prg' \rangle^{des\_conv}} t.
\end{equation*}

In the result of $des\_conv$, no new matching left-hand sides are added. That is, $prg'$ contains at least all the matching left-hand sides that $\langle prg' \rangle^{des\_conv}$ has. Thus any reduction that is possible with respect to $\langle prg' \rangle^{des\_conv}$ is already possible with respect to $prg'$.

But it is $prg' \subseteq prg$, as can be seen in the definition of $r''$. This implies the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{proof}

\end{document}
