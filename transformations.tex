% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}$ is short for $\langle eqn, \emptyset \rangle^{e}$
\end{itemize}

\item In the following, a function definition (or its equations) is called mixed if it contains a rule where the copattern is a destructor pattern and another rule where the copattern is a hole pattern.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, q = fun(...) [...]\\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \\
& \langle `` q = t ", H \rangle^{extract\_des} = \big\langle `` q = t ", H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\end{itemize}

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix_d} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle `` q = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_d} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle_d} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):
\begin{alignat*}{3}
\langle prg \rangle^{disentangle_d} & = ~&&\{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = \langle fun, des, prg \rangle^{autogen}(x_1, ..., x_n, x'_1, ..., x'_k) \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = ... " \in eqns \textrm{ with } \\
& && &&\quad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && \cup && \{ fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \textrm{ with } \\
& && &&\quad \not\exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
&\cup && \{ && \textrm{\textbf{function }} \langle fun, des, prg \rangle^{autogen}(\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun, des, prg \rangle^{autogen}(p_1, ..., p_n, p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma_1, ..., \sigma_n): \tau \textrm{\textbf{ where }} eqns ", `` \tau.des(\sigma'_1,...,\sigma'_k): \sigma " \in prg \\
& && &&\quad \textrm{ with } \exists e \in eqns: e = `` fun(p_1, ..., p_n).des(p'_1,..., p'_k) = t ", \\
& && &&\qquad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application } \} \\
& \cup && \{ && def ~ | ~ def \in prg, def \textrm{ is (co)data def. or function def. without destructor patterns } \}
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):
\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \{ ~&& \textrm{\textbf{data }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun \rangle^d (\tau_1, ..., \tau_n): \sigma \\
& && && | ~ `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
& && | && "\textrm{\textbf{codata }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle des \rangle^d (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} \\
& && && \{ \langle des \rangle^d ( \langle fun \rangle^d (x_1, ..., x_n), y_1, ..., y_k) = \langle t \rangle^d \\
& && && | ~ `` fun(x_1, ..., x_n).des(y_1, ..., y_k) = t " \in prg \} \\
& && | && `` \sigma.des(\tau_1, ... \tau_n): \tau " \in prg \} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle prg \rangle^{unmix_r} \rangle^{r'}$

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_r} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle_r = extract\_helpers(extract)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars^-}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and this pattern in front of them;
\item $q^{-con}_{vars^+}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and the variable replacing this pattern in front of them;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars^-}$ and $q^{-con'}_{vars^+}$ are in the same way analogous to $q^{-con}_{vars^-}$ and $q^{-con}_{vars^+}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con}_{vars^-}) = t ", \\
&\quad && `` \tau.des_k(...): \sigma " = \langle des_k \rangle^{sig}, \\
&\quad \textrm{if } q = fun(p_1^0, ..., p_n^0).des_1(p_1^1, ..., p_{n_1}^1)...des_k(p_1^k, ..., p_{n_k}^k), k \geq 1 \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

Splitting of the first argument in hole patterns

(as in $fun(x,...) = t \rightarrow \{fun(con_1(...),...) = t, fun(con_2(...),...) = t\}$):

\begin{alignat*}{4}
\langle prg \rangle^{split} & = ~&& \{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \span\span \\
& && && \bigcup && \{ \{ fun(con(y_1, ..., y_k), x_2, ..., x_n) = t[con(y_1, ..., y_k)/x_1] ~ | ~ `` con(y_1, ..., y_k): \tau_1 " \in prg \} \\
& && && && | ~ `` fun(x_1, x_2, ..., x_n) = t " \in eqns \} \\
& && && \cup \{ fun(con(...), ...) = t ~ | ~ `` fun(con(...), ...) = t " \in eqns \} \span\span \\
& && && \cup \{ q.des(...) = t ~ | ~ `` q.des(...) = t " \in eqns \} \span\span \\
& && | `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is (co)data def.} \} \span\span
\end{alignat*}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first argument of a hole pattern):
\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \{ ~&& \textrm{\textbf{codata }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \sigma .\langle fun, prg \rangle^r (\tau_1, ..., \tau_n): \tau \\
& && && | ~ `` fun (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has no destructor pattern }  \} \\
& && | && "\textrm{\textbf{data }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle con \rangle^r (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle con \rangle^r (x_1, ..., x_n) .\langle fun \rangle^r (y_1, ..., y_k) = \langle t, prg \rangle^r \\
& && && | ~ `` fun(con(x_1, ..., x_n), y_1, ..., y_k) = t " \in prg \} \\
& && | && `` con(\tau_1, ... \tau_n): \sigma " \in prg \} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern}\} 
\end{alignat*}

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern  \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise (all constructor patterns) \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Symmetries and alternative transformations}

A certain symmetry can be observed by laying the compositional sequences of the operations comprising defunctionalization and refunctionalization (preprocessing steps, then $d''$ or $r''$, respectively) next to each other:

\begin{alignat*}{4}
&\textrm{defunc.: } &&\textrm{ALL} \rightarrow  elim\_outer\_des \rightarrow && unmix_d \rightarrow disentangle_d && \rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{refunc.: } &&\textrm{ALL} \rightarrow && unmix_r \rightarrow disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

ALL stands for all of Uroboro, DEFUNC'ED and REFUNC'ED stand for the fragments of Uroboro the respective transformation results in. These two fragments can be transformed into one another as follows:

\begin{alignat*}{3}
&\textrm{REFUNC'ED} \rightarrow && elim\_outer\_des &&\rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{DEFUNC'ED} \rightarrow && disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

Observe that, when defunctionalizing REFUNC'EDs, only the first step $elim\_outer\_des$ of the preprocessing steps above is needed. Symmetrically, the first step $unmix_r$ of the preprocessing steps can be omitted when refunctionalizing DEFUNC'EDs.

From this symmetry one can derive an alternative defunctionalization and refunctionalization by using the respective other transformation:

$\langle prg \rangle^{d_{alt}} = \langle \langle prg \rangle^r \rangle^{elim\_outer\_des} \rangle^{d''}$

$\langle prg \rangle^{r_{alt}} = \langle \langle \langle prg \rangle^d \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

In both cases, one step of the original transformation can be saved by the above observed connection between REFUNC'ED and DEFUNC'ED. But this comes at the expense of having to run the entire refunctionalization before defunctionalizing and vice versa.

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule).

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Con}}
\UnaryInfC{$con(t_1, ... t_j, ..., t_n) \longrightarrow con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Fun}}
\UnaryInfC{$fun(t_1, ... t_j, ..., t_n) \longrightarrow fun(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Des\textsubscript{P}}}
\UnaryInfC{$t.des(t_1, ... t_j, ..., t_n) \longrightarrow t.des(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \longrightarrow t'$}
\RightLabel{$\longrightarrow$\textsubscript{Des\textsubscript{Args}}}
\UnaryInfC{$t.des(t_1, ..., t_n) \longrightarrow t'.des(t_1, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[\sigma]$}
\end{prooftree}

Write $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

\section{Semantics preservation}

In this section it is shown that the transformations above preserve the semantics of programs. That is, for a transformation indicated by angular brackets, it holds for all closed input terms $s, t$ and all programs $prg$ that:

$s \longrightarrow_{prg}^* t ~ \Leftrightarrow ~ \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle $

This will be shown for each transformation by showing

$s \longrightarrow_{prg} t \Rightarrow \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle$ (1)

and

$\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \Rightarrow s \longrightarrow_{prg}^* t$ (2)

It's always assumed that the program that is transformed is well-typed.

Note/TODO: The well-typedness of the transformed program will be shown in a separate section.

(1) is always shown in the following way:

Suppose that: $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, \\
show that: there exist derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ for $\langle s \rangle \longrightarrow_{prg} t_1, t_1 \longrightarrow_{prg} t_2, ..., t_{n-1} \longrightarrow_{prg} \langle t \rangle$, respectively

(2) is always shown analogously.

Exemplary, the proof of (1) for the transformation $split$ is given below.

\subsection{Split}

Proof of (1): by induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Axiom" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_2$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$; it is $\langle s \rangle = s$ and $\langle t \rangle = t$ ($split$ doesn't change input terms).

For this, define $\mathcal{D}_2$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(\langle prg \rangle)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(\langle prg \rangle)$ as well as in Rules$(prg)$, since $split$ doesn't change rules where the copattern has this form. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(con(x_1, ..., x_k), y_1, ..., y_k)$:

The argument here is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(x_1, x_2, ..., x_n)$:

Since $(q, s') \in \textrm{Rules}(prg)$ there exists a $(q_2, s_2') \in \textrm{Rules}(\langle prg \rangle)$ with $q_2 = fun(con(y_1, ..., y_k), x_2, ..., x_n)$ and $s'_2 = s'[con(y_1, ..., y_k) / x_1]$ for every constructor $con$ with the correct type (i.e. with return type equal to the type of the first argument of $fun$). This can also be seen directly in the definition of $split$. The concrete choice of $q_2$ depends upon the choice of $con$ -- below, $con$ will be chosen as needed.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 2}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 2}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists $\mathcal{D}_{\textrm{PM}}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 2}$}
\UnaryInfC{$s =^? q \searrow \sigma$}
\end{prooftree}

By inversion (TODO: proofs for inversion lemmas) we have the following form for $\mathcal{D}_{\textrm{PM}}$:

\begin{prooftree}
\AxiomC{$t_1 =^? x_1 \searrow t_1 / x_1$}
\AxiomC{...}
\AxiomC{$t_n =^? x_n \searrow t_n / x_n$}
\TrinaryInfC{$fun(t_1, ..., t_n) =^? q \searrow t_1 / x_1, ..., t_n / x_n$}
\end{prooftree}

With that, we also know the form of $s$: $s = fun(t_1, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}}$ as follows:

\begin{prooftree}
\AxiomC{$t_1^1 =^? y_1 \searrow t_1^1 / y_1$}
\AxiomC{...}
\AxiomC{$t_k^1 =^? y_k \searrow t_k^1 / y_k$}
\TrinaryInfC{$t_1 =^? con(y_1, ..., y_k) \searrow t_1^1 / y_1, ..., t_k^1 / y_k$}
\AxiomC{$t_2 =^? x_2 \searrow t_2 / x_2$ ...}
% change to this as soon as I have the new bussproofs package
% \AxiomC{...}
% ...
% \QuaternaryInfC{...
\AxiomC{$t_n =^? x_2 \searrow t_n / x_n$}
\TrinaryInfC{$fun(t_1, ..., t_n) =^? q_2 \searrow t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  t_n / x_n$}
\end{prooftree}

Remember that the choice of $con$ and, depending upon that, $q_2$, was left open until needed. This is now the place where $con$ needs to be chosen such that $t_1 = con(t^1_1, ..., t^1_k)$, with the result that the derivation $\mathcal{D}_{\textrm{PM}}$ given above is correct.

In the derivation above, $\sigma_2 = t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  t_n / x_n$ and thus:

$s'_2[\sigma_2] = s'[con(y_1, ..., y_k) / x_1][\sigma_2] \\
= s'[con(t_1^1, ... t_k^1) / x_1, t_2 / x_2, ..., t_n / x_n] = s'[t_1 / x_1, t_2 / x_2, ..., t_n / x_n] = s'[\sigma] = t$

\end{itemize}

This concludes the proof for the ``Axiom" case.

\item \textbf{``Constructor" case}:

TODO

\end{enumerate}


\end{document}
