% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}$ is short for $\langle eqn, \emptyset \rangle^{e}$
\end{itemize}

\item In the following, a function definition (or its equations) is called mixed if it has both destructor and hole patterns.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, q = fun(...) [...]\\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \\
& \langle q, H \rangle^{extract\_des} = \big\langle q, H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\end{itemize}

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle q, H \rangle^{extract\_outer\_des} = \big\langle q, H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):
\begin{alignat*}{3}
\langle prg \rangle^{disentangle} & = ~&&\{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = \langle fun, des, prg \rangle^{autogen}(x_1, ..., x_n, x'_1, ..., x'_k) \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = ... " \in eqns \textrm{ with } \\
& && &&\quad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && \cup && \{ fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \textrm{ with } \\
& && &&\quad \not\exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \} \\
& && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
&\cup && \{ && \textrm{\textbf{function }} \langle fun, des, prg \rangle^{autogen}(\sigma_1, ..., \sigma_n, \sigma'_1, ..., \sigma'_k): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun, des, prg \rangle^{autogen}(p_1, ..., p_n, p'_1, ..., p'_k) = t \\
& && && | ~ `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t " \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma_1, ..., \sigma_n): \tau \textrm{\textbf{ where }} eqns ", `` \tau.des(\sigma'_1,...,\sigma'_k): \sigma " \in prg \\
& && &&\quad \textrm{ with } \exists e \in eqns: e = `` fun(p_1, ..., p_n).des(p'_1,..., p'_k) = t ", \\
& && &&\qquad \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application } \} \\
& \cup && \{ && def ~ | ~ def \in prg, def \textrm{ is (co)data def. or function def. without destructor patterns } \}
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):
\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \{ ~&& \textrm{\textbf{data }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun \rangle^d (\tau_1, ..., \tau_n): \sigma \\
& && && | ~ `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
& && | && "\textrm{\textbf{codata }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle des \rangle^d (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} \\
& && && \{ \langle des \rangle^d ( \langle fun \rangle^d (x_1, ..., x_n), y_1, ..., y_k) = \langle t \rangle^d \\
& && && | ~ `` fun(x_1, ..., x_n).des(y_1, ..., y_k) = t " \in prg \} \\
& && | && `` \sigma.des(\tau_1, ... \tau_n): \tau " \in prg \} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle prg \rangle^{unmix} \rangle^{r'}$

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle = extract\_helpers(extract)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars}$ gives the following patterns: the variables in $q$, but the left-most inner-most constructor pattern is kept;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars}$ is in the same way analogous to $q^{-con}_{vars}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con} = hname (\langle q^{-con} \rangle^{vars}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con}_{vars}) = t ", \\
&\quad && `` \tau.des_k(...): \sigma " = \langle des_k \rangle^{sig}, \\
&\quad \textrm{if } q = fun(p_1^0, ..., p_n^0).des_1(p_1^1, ..., p_{n_1}^1)...des_k(p_1^k, ..., p_{n_k}^k), k \geq 1 \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (\langle q^{-con'} \rangle^{vars}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

Splitting of the first argument in hole patterns

(as in $fun(x,...) = t \rightarrow \{fun(con_1(...),...) = t, fun(con_2(...),...) = t\}$):

\begin{alignat*}{4}
\langle prg \rangle^{split} & = ~&& \{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \span\span \\
& && && \bigcup && \{ \{ fun(con(y_1, ..., y_k), x_2, ..., x_n) = t[con(y_1, ..., y_k)/x_1] ~ | ~ `` con(y_1, ..., y_k): \tau_1 " \in prg \} \\
& && && && | ~ `` fun(x_1, x_2, ..., x_n) = t " \in eqns \} \\
& && && \cup \{ fun(con(...), ...) = t ~ | ~ `` fun(con(...), ...) = t " \in eqns \} \span\span \\
& && && \cup \{ q.des(...) = t ~ | ~ `` q.des(...) = t " \in eqns \} \span\span \\
& && | `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is (co)data def.} \} \span\span
\end{alignat*}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first argument of a hole pattern):
\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \{ ~&& \textrm{\textbf{codata }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \sigma .\langle fun, prg \rangle^r (\tau_1, ..., \tau_n): \tau \\
& && && | ~ `` fun (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has no destructor pattern }  \} \\
& && | && "\textrm{\textbf{data }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle con \rangle^r (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle con \rangle^r (x_1, ..., x_n) .\langle fun \rangle^r (y_1, ..., y_k) = \langle t, prg \rangle^r \\
& && && | ~ `` fun(con(x_1, ..., x_n), y_1, ..., y_k) = t " \in prg \} \\
& && | && `` con(\tau_1, ... \tau_n): \sigma " \in prg \} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern}\} 
\end{alignat*}

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern  \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise (all constructor patterns) \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \bigcup_{i \in \{1, ..., n\}} \sigma_i$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \bigcup_{i \in \{1, ..., n\}} \sigma_i$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction function for closed terms, which is assumed to be used with respect to the rules $(q, t) \in \textrm{Rules}(prg)$ of a program $prg$, where $q$ is a copattern (left-hand side of the rule) and $t$ a term (right-hand side of the rule).

\begin{prooftree}
\AxiomC{$\forall i < j: \not\exists t: t_i \longrightarrow t$}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Con}}
\BinaryInfC{$con(t_1, ... t_j, ..., t_n) \longrightarrow con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\forall i < j: \not\exists t: t_i \longrightarrow t$}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Fun}}
\BinaryInfC{$fun(t_1, ... t_j, ..., t_n) \longrightarrow fun(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\forall i < j: \not\exists t: t_i \longrightarrow t$}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Des}}
\BinaryInfC{$t_1.des(t_2, ... t_j, ..., t_n) \longrightarrow t_1.des(t_2, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? p \searrow \sigma$ with $(p, t') = min \{ (p_2, t'_2) \in prg ~ | ~ t =^? p_2 \searrow \sigma_2 \}$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[s]$}
\end{prooftree}

Here $(p_1, t_1) < (p_2, t_2)$ means that the first rule appears in $prg$ before the second, the minimum of a set of rules is defined accordingly.

\end{document}
