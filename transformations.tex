% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{stmaryrd}

\newtheorem{lemma}{Lemma}
\newtheorem*{lemma*}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem*{definition*}{Definition}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

%\tableofcontents

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}$ is short for $\langle eqn, \emptyset \rangle^{e}$
\end{itemize}

\item In the following, a function definition (or its equations) is called mixed if it contains a rule where the copattern is a destructor pattern and another rule where the copattern is a hole pattern.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \span\span \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \span\span \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \span\span \\
&\quad \textrm{ where } && fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig} \textrm{ if } q = fun(...)\\
&\quad && \tau.des(\tau_1, ..., \tau_k) : \sigma = \langle des \rangle^{sig} \textrm{ if } q = q'.des(...) \\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \span\span \\
& \langle `` q = t ", H \rangle^{extract\_des} = \big\langle `` q = t ", H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\item Define the extraction of the constructors of a copattern with exactly one destructor as follows:
\begin{alignat*}{3}
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} \\
&\quad = \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \\
&\quad \textrm{with } hname= \langle fun, des, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n, \tau'_1, ..., \tau'_k): \tau \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, \sigma.des(\tau'_1, ..., \tau'_k): \tau = \langle des \rangle^{sig} \\
&\quad heqn = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = t ", \\
&\quad \textrm{if } \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \\
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} = \big\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
&\langle `` q = t ", H \rangle^{extract\_patterns} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

\item Both the defunctionalization and the refunctionalization described in the sections below require one shared preprocessing step, $align\_patterns$. This step is necessary for destructor extraction to work correctly.

The purpose of $align\_patterns$ is to bring the patterns inside the copatterns within one function definition to the same level of specification. Consider the following example:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(x).d2() = t_3

\end{lstlisting}

Here, the third equation's left-hand side has a catch-all pattern (variable) in its first destructor call $d1$. The first destructor in the first and second equations' left-hand sides is also $d1$, but the patterns there are the constructors $c1()$ and $c2()$, respectively; they have a higher level of specification than the catch-all pattern. For destructor extraction to work correctly, the catch-all pattern therefore must be split. Such splitting steps are what $align\_patterns$ is doing. The result of $align\_patterns$ applied to the above function definition is:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(c1()).d2() = t_3
fun().d1(c2()).d2() = t_3

\end{lstlisting}

For programs, $align\_patterns$ is defined as follows.
\begin{alignat*}{4}
\langle prg \rangle^{align\_patterns} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ `` q' = t " ~ | ~ q' \in Q_q, `` q = t " \in eqns \} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}
with
\begin{equation*}
Q_{fun(p_1, ..., p_n)} = \{fun(p_1, ..., p_n)\}
\end{equation*}
and
\begin{equation*}
Q_{q^0.des(p_1, ..., p_k)} = \langle \overline{q^0} \rangle^{align_patterns}.des(p_1, ..., p_k)
\end{equation*}
with
\begin{equation*}
\overline{fun(p_1, ..., p_n)} = fun(\_, ..., \_)
\end{equation*}
and
\begin{equation*}
\overline{q^0.des(p_1, ..., p_k)} = \overline{q^0}.des(\_, ..., \_)
\end{equation*}
Here, the $\_$ represent holes which are used to describe generic forms of copatterns. For instance, one generic form of $fun(p_1, ..., p_n).des(p_1, ..., p_k)$ is $fun(\_, ..., \_).des(\_, ..., \_)$. The generic forms for a given copattern can be simply defined inductively, starting with setting $\_$ as being a generic form for any pattern.

For generic forms of copatterns, $align\_patterns$ is defined as follows. Let $q_\_ = fun(\_, ..., \_).des_1(\_, ..., \_)...des_k(\_, ..., \_)$, and $q^i_\_$ be the context that obtains by replacing the $i$-th hole in $q_\_$ with another kind of hole $[]$ used for plugging other contexts into it.
\begin{multline*}
\langle q_\_ \rangle^{align\_patterns} = \\
fun(\langle q^1_\_ \rangle^{a\_p}, ..., \langle q^{n_0}_\_ \rangle^{a\_p}).des_1(\langle q^{n_0 + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_1}_\_ \rangle^{a\_p})...des_k(\langle q^{n_{k-1} + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_k}_\_ \rangle^{a\_p})
\end{multline*}

Finally, $a\_p$ for such contexts is defined as follows.

\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \bigcup_{con} \{con(t_1, ..., t_n) ~ | ~ t_i \in \langle \mathcal{C}[con(\_, ..., \_, [], \_, ..., \_)] \rangle^{a\_p} \},
\end{equation*}
if $\exists$ lhs in $def$ with a prefix of the generic form $\mathcal{C}[con(\_, ..., \_)]$,
\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \{x\},
\end{equation*}
otherwise.

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\item In general, the implementations of defunctionalization and refunctionalization only work with programs which don't depend upon the order of their rules. Especially, that means that a function such as the following won't be transformed correctly:
\begin{lstlisting}

function foo where
  foo(zero()) = zero()
  foo(succ(zero()) = zero()
  foo(x) = x

\end{lstlisting}

Thanks are due to Yufei Cai and Paolo Giarrusso for this observation. Future work might add a transformation from rule-order dependent to rule-order independent programs.

\end{itemize}

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix_d} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle `` q = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent definition for $elim\_multi\_des$, to be used for the simplified proofs.

$\langle prg \rangle^{elim\_multi\_des} = \langle \langle prg \rangle^{extract\_helpers(extract\_des^{>1})} \rangle^{elim\_multi\_des}$, if $prg$ contains outer destructors

$\langle prg \rangle^{elim\_multi\_des} = prg$, otherwise

\end{framed}
%%--

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_d} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent (for this fragment; contains unnecessary recursion which makes it identical to $unmix_r$) definition for $unmix_d$, to be used for the simplified proofs.

$\langle prg \rangle^{unmix_d} = \langle \langle prg \rangle^{extract\_helpers(extract\_des, funs)} \rangle^{unmix_d}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which are mixed

$\langle prg \rangle^{unmix_d} = prg$, otherwise

\end{framed}
%%--

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle_d} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):

$\langle prg \rangle^{disentangle_d} = \langle prg \rangle^{extract\_helpers(extract\_patterns)}$

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):

This uses the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $d^{core}$.

\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \langle && \{ def \in prg ~ | ~ def \textrm{ is codata def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has destr. pattern } \} \rangle^{d^{core}} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Technical note on constructor subsumption:

The input of $d^{core}$ in the definition above is actually not in its domain. This is because it can contain constructor calls. The following technical trick allows to transform such inputs as well: For the sake of $d^{core}$, subsume constructor names under function names (as if they were from the same syntactic domain). After the transformation, since names aren't changed (or when name changes are desired, the original name can still be retrieved), the subsumed constructor names (or their equivalents after a name change) are once again considered constructor names (from the original syntactic domain).

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle \langle prg \rangle^{extract\_outer\_des_r} \rangle^{unmix_r} \rangle^{r'}$

TODO: Refunc. has been corrected to first care about the
multiple destructor calls containing constructors. Implement these changes.

%%-- under construction
Extract outer destructor calls containing constructors:

$\langle prg \rangle^{extract\_outer\_des_r} = \langle \langle prg \rangle^{extract\_helpers(extract\_des, funs)} \rangle^{extract\_outer\_des_r}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which have multiple destructor calls containing constructors

$\langle prg \rangle^{extract\_outer\_des_r} = prg$, otherwise

%%--

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_r} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

%%--under construction
\begin{framed}
Alternative, but equivalent definition for $unmix_r$, to be used for the simplified proofs.

$\langle prg \rangle^{unmix_r} = \langle \langle prg \rangle^{extract\_helpers(extract\_des, funs)} \rangle^{unmix_r}$, if $prg$ contains mixed function definitions

with the affected functions $funs$ being those functions of $prg$ which are mixed

$\langle prg \rangle^{unmix_r} = prg$, otherwise

\end{framed}
%%--

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle_r = step2 \circ step1$

$step1 = extract\_helpers(extract\_patterns)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars^-}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and this pattern in front of them;
\item $q^{-con}_{vars^+}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and the variable replacing this pattern in front of them;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars^-}$ and $q^{-con'}_{vars^+}$ are in the same way analogous to $q^{-con}_{vars^-}$ and $q^{-con}_{vars^+}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

\begin{framed}

Alternative, but equivalent definition for $step2$, to be used for the simplified proofs.

$\langle prg \rangle^{step2} = \langle \langle prg \rangle^{extract\_helpers(extract)} \rangle^{step2}$, if there is lhs in $prg$ of the form $fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n)$, $\exists p_i^j$: $p_i^j$ is constructor pattern

$\langle prg \rangle^{step2} = prg$, otherwise

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

\end{framed}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first data type argument of a hole pattern):

This uses the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, from now on referred to as $r^{core}$.

Technical note: As $r^{core}$ doesn't allow destructor terms in its inputs, they have to be converted beforehand. This conversion is the same as that of $r$ for terms below, restricted to destructor terms. Call this conversion lifted to programs (in the way that all destructor terms on right-hand sides or as subterms of them are converted) $des\_conv$.

TODO: has been changed to allow for data type variables as first arguments. Implement this change along with removing the implementation for $split$.

\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \langle \langle && \{ def \in prg ~ | ~ def \textrm{ is data def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has no destr. pattern}, \\
& && &&\qquad \textrm{the first argument of the lhs isn't a variable } \} \rangle^{des\_conv} \rangle^{r^{core}} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern} \\
& && &&\quad \textrm{or where } n = 0 \textrm{ or where the first argument of the lhs is a variable} \} 
\end{alignat*}

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern or where $n = 0$ or where the first argument of the lhs is a variable \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Symmetries and alternative transformations}

A certain symmetry can be observed by laying the compositional sequences of the operations comprising defunctionalization and refunctionalization (preprocessing steps, then $d''$ or $r''$, respectively) next to each other:

\begin{alignat*}{4}
&\textrm{defunc.: } &&\textrm{ALL} \rightarrow  elim\_outer\_des \rightarrow && unmix_d \rightarrow disentangle_d && \rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{refunc.: } &&\textrm{ALL} \rightarrow && unmix_r \rightarrow disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

ALL stands for all of Uroboro, DEFUNC'ED and REFUNC'ED stand for the fragments of Uroboro the respective transformation results in. These two fragments can be transformed into one another as follows:

\begin{alignat*}{3}
&\textrm{REFUNC'ED} \rightarrow && elim\_outer\_des &&\rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{DEFUNC'ED} \rightarrow && disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

Observe that, when defunctionalizing REFUNC'EDs, only the first step $elim\_outer\_des$ of the preprocessing steps above is needed. Symmetrically, the first step $unmix_r$ of the preprocessing steps can be omitted when refunctionalizing DEFUNC'EDs.

From this symmetry one can derive an alternative defunctionalization and refunctionalization by using the respective other transformation:

$\langle prg \rangle^{d_{alt}} = \langle \langle prg \rangle^r \rangle^{elim\_outer\_des} \rangle^{d''}$

$\langle prg \rangle^{r_{alt}} = \langle \langle \langle prg \rangle^d \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

In both cases, one step of the original transformation can be saved by the above observed connection between REFUNC'ED and DEFUNC'ED. But this comes at the expense of having to run the entire refunctionalization before defunctionalizing and vice versa.

\section{Fragments for transformations}

This section identifies the relevant input fragments for the transformation steps given in section 2 and 3. Those are chosen such that the image of one step (under its relevant input fragment) is a subset of the input fragment for the next step. For each respective follow-up fragment, this can be seen directly in the definition of the previous transformation.

It can therefore be presumed that the input of a certain step comes only from its respective relevant input fragment. This will be used in the proofs of semantic preservation for the transformations steps in section 7.

Common syntax for the fragments:\\
$\sigma, \sigma_i, \tau, \tau_j = $ type names\\
$con = $ constructor names\\
$des = $ destructor names\\
$fun = $ function names\\
$x, y, x_i, y_j = $ variable names\\
$prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*$\\
$ddef ::= \textbf{data } \sigma \textbf{ where } csig^*$\\
$coddef ::= \textbf{codata } \sigma \textbf{ where } dsig^*$\\
$csig ::= con(\tau^*): \tau$
$dsig ::= \sigma.des(\tau^*): \tau$
$s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)$\\

A fragment will be defined by giving the respective EBNF rule for $fdef$, which stands for function definitions.

The entire language Uroboro is defined by giving the following rule for $fdef$:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for defunc.}

This subsection gives the relevant input fragments for the defunctionalization steps. The domain for the first step, $elim\_multi\_des$, is simply the set of all Uroboro programs. Thus the entire defunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Mixed fragment}

This is the input fragment for $unmix_d$. Informally, it consists of (co)data definitions and function definitions that may not contain multiple destructor calls in their copatterns but are otherwise unrestricted. 

Formal rules for function definitions:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ fun(p^*).des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_d$. Informally, it consists of (co)data definitions and function definitions that may neither contain multiple destructor calls nor be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(p^*).des(p^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Actual defunc. fragment}

This is the input fragment for actual defunctionalization, i.e. $d''$. Informally, it consists of (co)data definitions and function definitions where each satisfies the following property: It either is (1) in already defunctionalized form, i.e. the left-hand sides of its rules all are hole copatterns, or (2) are in the form that the core defunctionalization from the paper of Rendel, Trieflinger, and Ostermann can be applied to, i.e. the left-hand sides of its rules all are destructor copatterns, and these copatterns do not contain any constructor pattern matching.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(x^*).des(y^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for refunc.}

This subsection gives the relevant input fragments for the refunctionalization steps. The domain for the first step, $unmix_r$, is simply the set of all Uroboro programs. Thus the entire refunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_r$. Informally, it consists of (co)data definitions and function definitions that may not be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(p^*) = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Unsplit fragment}

This is the input fragment for $split$. Informally, it consists of (co)data definitions and function definitions where each may not be mixed and must satisfy the following property: For every copattern $q$ that is the left-hand side of one of its rules it holds that: Either $q$ is (1) a hole pattern, then it may contain at maximum one constructor application, and this at the left-most outer-most position, or $q$ is (2) a destructor pattern, then it must not contain any constructor applications.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$defeqn ::= dfeqn1 ~ | ~ dfeqn0$\\
$dfeqn1 ::= fun(con(x), y^*) = t$\\
$dfeqn0 ::= fun(x^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$

\subsubsection{Actual refunc. fragment}

This is the input fragment for actual refunctionalization, i.e. $r''$. Informally, it is identical to the last fragment with the following difference: Where it said ``at maximum one constructor application" in the last section, for this fragment ``exactly one constructor application" has to hold. As such, every one of its function definitions is either (1) already in refunctionalized form, i.e. the left-hand sides of its rules contain no constructor applications and they are either all destructor patterns or the function has no arguments or its first argument has codata type, or (2) core refunctionalization (Rendel, Trieflinger, Ostermann) can be applied to it.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef $\\
$dfdef ::= \textbf{function } fun(\sigma, \tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(con(x), y^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } copeqn^* ~ | ~ nopeqn^*$\\
$copeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$\\
$nopeqn ::= fun(x^*) = t$

\section{Values}

This section formalizes the notion of value for Uroboro. Unlike in the usual case, but not unlike other languages with copattern such as that of Abel et al., some values can be reduced. Not all reductions of values are preserved by the transformations above. 

As is the case with the language of Abel et al., whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from `Copatterns" (Abel et al.), section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

%%-- under construction

The value judgement makes use of a ``no-match" judgement. This judgement is complementary to the pattern matching judgement in the next section.

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Con/Card}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Card}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Des/Card}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}

%%--

\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction uses the evaluation context $\mathcal{E}$ given below, which in turn requires the syntax of the complete Uroboro. 

\begin{alignat*}{2}
& v  = &&\textrm{value, that is } \vdash_v v \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}

\begin{prooftree}
\AxiomC{$t \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

if the immediate subterms of $t$ are values:
\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[\sigma]$}
\end{prooftree}

\begin{framed}
\textbf{TODO: Proposed changes}
\begin{itemize}
\item TODO 1: proposed change for preliminary version: not the immediate subterms, but the arguments of the function and the destructors. And the evaluation context is
\begin{alignat*}{3}
&\mathcal{E} &::=  ~& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}_{vcall}.des(t^*) ~ | ~ vcall.des(v^*, \mathcal{E}, t^*)&\\
&\mathcal{E}_{vcall} &::= &fun(v^*, \mathcal{E}, v^*) ~ | ~ \mathcal{E}_{vcall}.des(v^*) ~ | ~ vcall.des(v^*, \mathcal{E}, v^*)&\\
&vcall &::= & fun(v^*) ~ | ~ vcall.des(v^*)&
\end{alignat*}
Especially, this means that prefixes can't be reduced, but this may be desirable in some cases, which brings us to TODO 2.
\item TODO 2: proposed change for final version -- this version needs changes in the extraction functions --: the most specific pattern that is matched by any prefix is used.

\underline{Example:}

Program:
\begin{lstlisting}[mathescape]
fun() = $t_1$
fun().des() = $t_2$
\end{lstlisting}

Reductions:
\begin{flalign*}
&fun() \longrightarrow t_1&\\
&fun().des() \longrightarrow t_2&\\
&\textrm{Not (!) a reduction:}&\\
&fun().des() \longarrownot\longrightarrow t_1.des()&
\end{flalign*}
\end{itemize}
\end{framed}

Write $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

\subsection{As an extension of (Co)Data Fragment semantics}

The properties of the reductions and the de- and refunctionalization transformations of the paper of Rendel, Trieflinger, and Ostermann are used for the proofs of the next section. The domain of their defunctionalization is what they call the Codata Fragment, and that of refunctionalization the Data Fragment. Their semantic properties can be used in the proofs because, for well-typed programs and limited to terms which have copattern coverage for all of their subterms in the program (TODO: define this more precisely), this work's reducibility notion is a conservative extension of either the Data Fragment's notion or the Codata Fragment's notion. When the well-typedness and coverage conditions are dropped, the reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsubsection{Data Fragment}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment (Figure 6b), as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that it is not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from last section.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b)
\begin{equation*}
u, v ::= con(v^*),
\end{equation*}
while the V\textsubscript{CodTFun} can never be applied. This is because a function in the Data Fragment can only have data type unless it doesn't have a type defined in the program at all, as types can only be added by data definitions.

\subsubsection{Codata Fragment}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. It will be demonstrated why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if" direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. That the second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if" direction. By the rules of the judgement, a value can also be a destructor application if it has codata type and doesn't match any rule of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage for all subterms of the input term, since those are the only ones that can be relevant for the value judgement in the one-step reduction.

\section{Semantics preservation}

TODO: The bisimulation statement presupposes that the one-step reduction relation is a partial function. Change it accordingly.

In this section it is shown that the transformations above preserve the semantics of programs in a kind of weak bisimulation. Precisely, for all transformations indicated by angular brackets, it holds for all closed input terms $s, t$ and all programs $prg$ that:

\begin{itemize}
\item $s \longrightarrow_{prg} t \implies \langle s \rangle  \longrightarrow^*_{\langle prg \rangle} \tilde{t}$ for a $\tilde{t} \sim t$ (1a)

\item for all terms $s'$ in the sequence of (1a), with the exception of the last ($t'$), it is $s \sim s'$ (1b)

\item if $s \not\sim t$: $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \implies \tilde{s} \longrightarrow_{prg} \tilde{t}$ for $\tilde{s} \sim s, \tilde{t} \sim t$ (2)

\end{itemize}

The equivalence relation $\sim$ for terms is different for each transformation, and always meant with respect to a program $prg$. Its purpose is to capture the ``sameness" of some terms that arises from the ``splitting" of a function definition into multiple definitions in the transformation. This notion of equivalence for terms can be extended to copatterns and patterns, since each of them is syntactically identical to a term. It has a number of intended consequences, which are listed below:

TODO: extract from the proofs (see the TODOs there)

\begin{itemize}

\item Let $q$ be a copattern with its function name $fun$ different from $fun'$, and both of those names declared in $prg$. If $q' \sim q$ for a copattern $q'$, the function name of $q'$ is different from $fun'$, as well.

\item Let two terms $s,t$ have the following forms: $s = fun(...).des_1(...)...des_k()$ and $t = fun'(...).des'_1(...)...des'_l(...)$, with $k \neq l$, and with $fun$ and $fun'$ declared in $prg$. For any $\widetilde{s} \sim s$ and $\widetilde{t} \sim t$ it is $\widetilde{s} \not\sim \widetilde{t}$.

The second intended consequence is easy to show, because each equivalence relation ``mirrors" the number of destructor calls in the helper function name. This means that the result of adding the number of actual calls of a well-typed term of $\langle prg \rangle$ to the number of calls embedded in its helper function name is equal to the number of calls of the equivalent term well-typed in $prg$.

TODO: demonstrate that these intended consequences actually hold for each transformation

\end{itemize}

For a transformation, the corresponding equivalence relation is defined as the smallest equivalence relation for which some general and some specific properties hold. The general properties are shared by all equivalence relations.

The general properties are the following:

\begin{itemize}

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $con(t_1, ..., t_n) \sim con(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $fun(t_1, ..., t_n) \sim fun(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{0, ..., n\}$: $t_0.des(t_1, ..., t_n) \sim \widetilde{t_0}.des(\widetilde{t_1}, ..., \widetilde{t_n})$

\end{itemize}

There is only one specific property for $elim\_multi\_des$, as follows:

\begin{itemize}

\item If $\sigma$ and $\widetilde{\sigma}$ substitute the same variables, and for every term $t$ that $\sigma$ substitutes for a variable $x$, it is $t \sim \widetilde{t}$ for the term that $\widetilde{\sigma}$ subtitutes for $x$: $q[\sigma] \sim \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle q \rangle^{vars})[\widetilde{\sigma}]$

\end{itemize}

There is only one specific property for $disentangle_d$, as follows:

\begin{itemize}

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$ and $t'_j \sim \widetilde{t'_j}$ for $j \in \{1, ..., k\}$: $fun(t_1, ..., t_n).des(t'_1, ..., t'_k) \sim \langle fun, des, prg \rangle^{autogen}(\widetilde{t_1}, ..., \widetilde{t_n}, \widetilde{t'_1}, ..., \widetilde{t'_k})$

\end{itemize}

All of these equivalence relations are defined such that, for an equation $`` q = t "$ of $prg$, unless $q = t$, it is $q \not\sim t$.

%%- old bisim. statements
%\begin{itemize}
%\item $s \longrightarrow_{prg} t \implies \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle$ (1)
%
%\item the reduction sequence from $\langle s \rangle$ to $\langle t \rangle$ in (1), contains no terms, except possibly $\langle s \rangle$ and $\langle t \rangle$, that typecheck against $prg$ (2)
%
%\item when $s, t$ typecheck against $prg$: $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \implies s \longrightarrow_{prg} t$ (3)
%
%\item there is no infinite reduction sequence with respect to $\langle prg \rangle$ containing only terms that don't typecheck in $prg$ (4)
%
%\end{itemize}
%%-

When one-step reduction is viewed as state transition, with $prg$ and $\langle prg \rangle$ standing for two different transition systems, the statements above describe the precise kind of their bisimilarity.

TODO: reformulate to fit new bisim. statements

%%- old bisim. explanation
%Statements (1) and (2) stand for the direction from $prg$ to $\langle prg \rangle$. (1) means that every state of $prg$ has a corresponding state in $\langle prg \rangle$, but there can be internal states (intermediate in the transition). (2) guarantees that these internal states are in fact internal, that is, they have no corresponding states in $prg$.
%
%Statement (3) stands for the direction from $\langle prg \rangle$ to $prg$. It means that when a state in $\langle prg \rangle$ has a corresponding state in $prg$, it behaves like it, that is, when there is a transition from it to another state with a corresponding state, there also is a transition between the corresponding states.
%
%Statement (4) is about a special property of internal states: there cannot be an infinite sequence of transitions between only internal states. Especially, this accounts for the fact that internal actions might sometimes apply to a state that corresponds to one in $prg$ but not lead to another such corresponding state. This case cannot be altogether avoided by all of the transformations, but at least be made less problematic by not allowing an infinite progression of internal transitions only. This way, it can be determined in $\langle prg \rangle$, simply by going through the internal transitions and arriving at a final internal state, that the original starting state in $prg$ doesn't lead to any other state.
%%-

(1a) is always shown in the following way:

Suppose that: $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, \\
show that: there exist derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} t_1, t_1 \longrightarrow_{\langle prg \rangle} t_2, ..., t_{n-1} \longrightarrow_{\langle prg \rangle} \langle t \rangle$, respectively

For some transformations, strong bisimulation holds, precisely, the following holds for all closed terms $s, t$:

$ s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$

Strong bisimulation implies the weak kind of bisimulation as given by (1a), (1b) and (2). It is always shown in its stead whenever possible. The proof of each side of strong bisimulation proceeds analogously to that of (1a) (but always with $n = 1$).

It's always assumed that the program that is transformed is well-typed. It also is assumed that no term is stuck, i.e., it can either be reduced or is a value. Finally, it is assumed that the program to be transformed is deterministic, i.e., no term can be reduced by two or more rules, and contains no ``partially dead" rules, as defined below.

\begin{definition}[Partial deadness] A rule $r$ of a program $prg$ is partially dead with repect to $prg$ iff there is a term that matches $r$ and has a strict prefix that matches another rule of $prg$.
\end{definition}

Note/TODO: The well-typedness of the transformed program will be shown in a separate section.

For the proofs of these properties the following lemmas will be needed:

\begin{lemma}[Inversion lemma for pattern matching]

Let $\mathcal{D}$ be a derivation of $t =^? q \searrow \sigma$.

\begin{enumerate}

\item If $q = x$ then $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\item If $q = con(p_1, ..., p_n)$ then $t = con(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = fun(p_1, ..., p_n)$ then $t = fun(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = q'.des(p_1, ..., p_n)$ then $t = t'.des(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t =^? q \searrow \sigma$}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\end{enumerate}

\begin{proof}~

\begin{enumerate}

\item A matched pattern that is a variable doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Var}. Thus the derivation can only be the result of the application of this single rule.

\item A matched pattern that is a constructor application doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Con}. Thus the derivation can only be the result of the application of this rule, and of the rules leading to the premises of this rule.

\item Analogous to 2.

\item Analogous to 2.

\end{enumerate}

\end{proof}

\end{lemma}

%%-- old version of lemma 2
%\begin{lemma}
%
%Let $e$ be a helper extraction function, i.e., a function that can be an argument of $extract\_helpers$ as defined in section 1. For any program $prg$ and any two closed terms $s,t$ it holds that:
%
%\begin{enumerate}
%
%\item If $s =^? q \searrow \sigma$, $s'[\sigma] = t$ for a rule $(q, s') \in \textrm{Rules}(prg)$ and $\langle (q, s') \rangle^e = \big\langle r, H \big\rangle$ such that there is a reduction sequence from $s$ to $t$ with respect to $\{ r \} \cup \{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$,
%
%then $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.
%
%\item If for a rule $(q, s') \in \textrm{Rules}(\langle prg \rangle^{extract\_helpers(e)})$ it holds that $s =^? q \searrow \sigma$, $s'[\sigma] = t$,
%
%then there is an equation $r$ in the equations of $prg$ such that $\langle r \rangle^e$ contains $`` q = s' "$.
%
%\end{enumerate}
%
%\begin{proof} ~
%\begin{enumerate}
%\item Let the conditions be satisfied. As we can see in the definition of $extract\_helpers$, for every equation $eqn$ in the original program, the transformed program contains the equation $r$ and the equations in the set $\{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$, with $\big\langle r, H \big\rangle = \langle eqn \rangle^e$. Thus there is a reduction sequence from $s$ to $t$ with respect to the equations of the transformed program: $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.
%
%\item As we can see in the definition of $extract\_helpers$, $\langle prg \rangle^{extract\_helpers(e)}$ contains only equations that are contained in $\langle r \rangle^{e} = \big\langle eqn', H \big\rangle$, be they either $eqn'$ or contained in $H$, for some $r$ from the equations of $prg$.
%
%\end{enumerate}
%\end{proof}
%
%\end{lemma}
%%--

%%-- under construction

In the following, the convention that $q_r$ is the left-hand side of the equation $r$ is used.

\begin{definition}[Extraction function properties]
Let $e$ be an argument of $extract\_helpers$, and $prg$ a deterministic program without any ``partially dead" rules; write $\langle prg \rangle$ short for $\langle prg \rangle^{extract\_helpers(e)}$. $e$ is said to satisfy the extraction function properties iff it is either of kind `A' or of kind `B'. These are defined such that $\langle prg \rangle$ has the whole-program properties that it is
\begin{center}
deterministic and contains no ``partially dead" rules\\
(Note: this is unnecessary under the first proposed change to the semantics)
\end{center}
and, for any equation $r$ of $prg$, the equations within $\langle r \rangle^e$ are
\begin{equation*}
\epsilon_1, ..., \epsilon_n, \zeta,
\end{equation*}
for an $n \geq 0$, with properties partially specific to the kind of $e$. First listed are their common properties, then their respective specific properties.

%%-- under construction
\begin{itemize}
\item \underline{Common properties:}
\begin{enumerate}
\item If $n = 0$, then $\zeta = r$.
\item For $i \in \{1, ..., n\}$ it is $q_{\epsilon_i} \sim t_{\epsilon_i}$. Further, it is $q_\zeta \sim q_r$ and $t_\zeta = t_r$.
\item For any term $t$ matching one of $\epsilon_1, ..., \epsilon_n$ returning a $\sigma$, if the immediate subterms of $t$ are values, so are the immediate subterms of the respective $t_{\epsilon_i}[\sigma]$.
\item For any of $\epsilon_1, ..., \epsilon_n$ it holds that: The number of constructors on the right-hand side is smaller or equal to that of the left-hand side, the same for destructors. Further, either the number of constructors, or that of destructors, or both, is strictly smaller on the right-hand side compared to the left-hand side.
\end{enumerate}

\item \underline{Kind `A': ``Destructor extraction":} If $n \geq 1$ it holds that:
\begin{enumerate}
\item Set $q_0 := q_r$ and $q_i := q_0[q_{\epsilon_1} \leftarrow t_{\epsilon_1}]...[q_{\epsilon_i} \leftarrow t_{\epsilon_i}]$. It is $q_{\epsilon_1} < q_0, q_{\epsilon_2} < q_1, ..., q_{\epsilon_n} < q_{n-1}$, and $q_\zeta = q_n$.
\end{enumerate}

\item \underline{Kind `B': ``Constructor extraction":} If $n \geq 1$ it holds that:
\begin{enumerate}
\item For each $\sigma$ that substitutes only with values, there is a $\sigma^1_v$, that substitutes only with values, with $q_r[\sigma] = q_{\epsilon_1}[\sigma^1_v]$.
\item There exist $\sigma^2_v, ..., \sigma^{n+1}_v$ that substitute only with values and for which it holds: $t_{\epsilon_1}[\sigma^1_v] = q_{\epsilon_2}[\sigma^2_v]$, $t_{\epsilon_2}[\sigma^2_v] = q_{\epsilon_3}[\sigma^3_v]$, ..., $t_{\epsilon_{n-1}}[\sigma^{n-1}_v] = q_{\epsilon_n}[\sigma^n_v]$, and $t_{\epsilon_n}[\sigma^n_v] = q_\zeta[\sigma^{n+1}_v]$
\item For $i \in \{2, ..., n\}$, $q_{\epsilon_i}$ is hole pattern. Further, $q_\zeta$ is hole pattern.
\end{enumerate}
\end{itemize}

\end{definition}

\begin{lemma}
\label{lemma2}

Let $e$ be an argument of $extract\_helpers$ that satisfies the extraction function properties, and let $prg$ be a deterministic program (TODO: define this as not containing any two rules which both match the same term).

For any two closed terms $s,t$ it holds that:

\begin{enumerate}

\item If $s =^? q_r \searrow \sigma$, $t_r[\sigma] = t$ for some equation $r := `` q_r = t_r "$ of $prg$, and the (immediate) subterms of $s$ are values in $prg$,

then $s \longrightarrow^*_{\langle prg \rangle^{extract\_helpers(e)}} t'$ for a $t'$ with $t' \sim t$.

\item If for a rule $(q, s') \in \textrm{Rules}(\langle prg \rangle^{extract\_helpers(e)})$ it holds that $s =^? q \searrow \sigma$, $s'[\sigma] = t$,

then there is an equation $r$ in the equations of $prg$ such that $\langle r \rangle^e$ contains $`` q = s' "$.

\end{enumerate}

\begin{proof}

\begin{enumerate}

\item

As we can see in the definition of $extract\_helpers$, the transformed program $\langle prg \rangle$ contains, for every equation $r^*$ of $prg$, the equations within $\langle r^* \rangle^e$, and no others. Especially, $\langle prg \rangle$ contains $\langle r \rangle^e$, because $prg$ contains $r$. The desired sequence can be constructed as follows; it will be distinguished between the two kinds that $e$ can have.

\begin{proof}[Proof for Kind `A'] Consider the equations that can be in $\langle r \rangle^e$. Two cases will be distinguished.

\begin{itemize}

\item $n = 0$. Then, by the first common property, it is $\zeta = r$ for the only rule $\zeta$ contained in $\langle r \rangle^e$. Thus it is $s = q_\zeta[\sigma]$. Consider the form of $q_\zeta[\sigma] = fun(t^0_1, ..., t^0_{n_0}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k})$. The desired sequence can be given as follows:
\begin{equation*}
s \longrightarrow^* fun((t^0_1)_v, ..., (t^0_{n_0})_v).des_1((t^1_1)_v, ..., (t^1_{n_1})_v)...des_k((t^k_1)_v, ..., (t^k_{n_k})_v) \longrightarrow t
\end{equation*}
First, the initial part of this sequence is constructed. The arguments $t^i_j$, which are values in $prg$, are reduced to their corresponding values $(t^i_j)_v \sim t^i_j$. We have such reductions by Lemma 3. Apply the ``Cong" rule, for an $\mathcal{E}$ detailed below, after each such reduction to obtain the reduction given below. All of those reductions, put behind one another, result in the initial part of the sequence.
\begin{equation*}
\mathcal{E}[t^i_j] \longrightarrow \mathcal{E}[(t^i_j)_v]
\end{equation*}
Such an $\mathcal{E}$ depends on the $i$ and $j$; it is constructed from $s$ by replacing the arguments to the left of $t^i_j$ with their corresponding values, as constructed for the previous steps, and leaving a hole for $t^i_j$. It remains to be shown why $\mathcal{E} = fun(...).des_1(...)...des_i(...[]...)...des_k(...)$ is actually a reduction context. I.e., why is it not possible to reduce $fun(...).des_1(...)...des_{i-1}(...)$? The arguments of $fun$ and of the destructors are values by construction. $fun(...).des_1(...)...des_l(...)$, for $l \in \{0, ..., i-1\}$, doesn't match any equation of $\langle prg \rangle$ because $\zeta$ would be ``partially dead" otherwise. This is because then there would be a term that matches both a prefix of $q_\zeta$ and this equation's left-hand side.

(Note: Under the first proposed change for the semantics: The above argument can replaced by simply stating that it can be directly seen that $\mathcal{E}$ is a reduction context, because of its form and the $(t^i_j)_v$ being values.) 

Second, the final step of the sequence is derived. This is done by using the ``Subst" rule for $\zeta$.

\item $n \geq 1$. First, the prefixes of $s = q_r[\sigma]$ are converted. Set $q_0 := q_r$, $\sigma^0_v := \sigma$, and $q_i := q_r[q_{\epsilon_1} \leftarrow t_{\epsilon_1}]...[q_{\epsilon_i} \leftarrow t_{\epsilon_i}]$. By property 1 of kind `A' there are equations $\epsilon_1, ..., \epsilon_n$ with $q_{\epsilon_1} \leq q_0, q_{\epsilon_2} \leq q_1, ..., q_{\epsilon_n} \leq q_{n-1}$. From this we have the sequence
\begin{equation*}
s = q_0[\sigma^0_v] \longrightarrow^* q_1[\sigma^1_v] \longrightarrow^* ... \longrightarrow^* q_n[\sigma^n_v];
\end{equation*}
the $\sigma^i_v$ are constructed iteratively, as follows below. This sequence consists of the sequences
\begin{equation*}
q_i[\sigma^i_v] \longrightarrow^* q_i[\sigma^{i+1}_v] \longrightarrow q_{i+1}[\sigma^{i+1}_v]
\end{equation*}
for each $i \in \{0, ..., n-1\}$. The initial part is responsible for reducing the immediate subterms of the prefix $q_{\epsilon_{i+1}}[\sigma^i_v] \leq q_i[\sigma^i_v]$ to values, resulting in $q_i[\sigma^{i+1}_v]$. Afterwards, the last step is derived by using the ``Subst" rule for $\epsilon_{i+1}$.

For the initial part of the sequence, it suffices to reduce the arguments of the function call and, of the destructor call, if any (from left to right), because there is no equation in $\langle prg \rangle$ that a strict prefix of $q_{\epsilon_{i+1}}[\sigma^i_v]$ matches. Otherwise $q_{\epsilon_{i+1}}$ would be ``partially dead"; the argument here is analogous to the ``$n = 0$" case.

Second, the final step of the overall sequence is derived. This is done by using the ``Subst" rule for $\zeta$.

\end{itemize}

\end{proof}

\begin{proof}[Proof for Kind `B'] Consider the equations that can be in $\langle r \rangle^e$. Two cases will be distinguished.

\begin{itemize}
\item $n = 0$. Then, by the first common property, it is $\zeta = r$ for the only rule $\zeta$ contained in $\langle r \rangle^e$. Thus it is $s = q_\zeta[\sigma]$. Consider the form of $q_\zeta[\sigma] = fun(t^0_1, ..., t^0_{n_0}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k})$. The desired sequence can be given as follows:
\begin{equation*}
s \longrightarrow^* fun((t^0_1)_v, ..., (t^0_{n_0})_v).des_1((t^1_1)_v, ..., (t^1_{n_1})_v)...des_k((t^k_1)_v, ..., (t^k_{n_k})_v) \longrightarrow t
\end{equation*}
The initial part of this sequence is concerned with reducing the $t^i_j$ to equivalent values. Its construction is identical to that of this case for an $e$ of Kind `A', consisting of reduction steps
\begin{equation*}
\mathcal{E}[t^i_j] \longrightarrow \mathcal{E}[(t^i_j)_v]
\end{equation*}
with $\mathcal{E}$ constructed as in Kind `A'. It will now be shown that $\mathcal{E}$ actually is a reduction context. Like in the proof for Kind `A' this is because $fun(...).des_1(...)...des_l(...)$ doesn't match any equation of $\langle prg \rangle$, for $l \in \{0, ..., i-1\}$. And again, this is because then $\zeta$ would be ``partially dead".

(Note: Under the first proposed change for the semantics: Again, the above argument can replaced by simply stating that it can be directly seen that $\mathcal{E}$ is a reduction context, because of its form and the $(t^i_j)_v$ being values.) 

Finally, the final step of the sequence is derived. This is done by using the ``Subst" rule for $\zeta$.

\item $n \geq 1$. First, the arguments of the function and destructor calls need to be reduced to equivalent values, analogously to the ``$n = 0$" case, yielding an initial reduction sequence
\begin{equation*}
s = q_r[\sigma] \longrightarrow^* q_r[\sigma^0_v] \sim s,
\end{equation*}
with a $\sigma^0_v$ that substitutes only with values.

By property 1 and 2, we have equations $\epsilon_1, ..., \epsilon_n, \zeta$ in $\langle r \rangle^e$ with $q_r[\sigma^0_v] = q_{\epsilon_1}[\sigma^1_v], t_{\epsilon_1}[\sigma^1_v] = q_{\epsilon_2}[\sigma^2_v], t_{\epsilon_2}[\sigma^2_v] = q_{\epsilon_3}[\sigma^3_v], ..., t_{\epsilon_n}[\sigma^n_v] = q_\zeta[\sigma^{n+1}_v]$.
From this we have the sequence
\begin{equation*}
s = q_{\epsilon_1}[\sigma^1_v] \longrightarrow t_{\epsilon_1}[\sigma^1_v] \longrightarrow ... \longrightarrow t_{\epsilon_n}[\sigma^n_v] = q_\zeta[\sigma^{n+1}_v] \longrightarrow t_\zeta[\sigma^{n+1}_v] =: \widetilde{t}.
\end{equation*}
Let $t_{\epsilon_0} := q_{\epsilon_1}$. Except for the last, each of the steps
\begin{equation*}
t_{\epsilon_i}[\sigma^i_v] \longrightarrow t_{\epsilon_{i+1}}[\sigma^{i+1}_v]
\end{equation*}
can be derived using the ``Subst" rule for the equation $\epsilon_i$, for $i \in \{0, ..., n-1\}$. This is possible because all immediate subterms of $t_{\epsilon_i}[\sigma^i_v] = q_{\epsilon_{i+1}}[\sigma^{i+1}_v]$ are values. This is because (a) $\sigma^0_v$ substitutes only with values, thus, by property 1, so does $\sigma^1_v$, and thus, by property 2, so do $\sigma^2_v, ..., \sigma^{n+1}_v$, and (b) by property 3 $q_{\epsilon_{i+1}}$ is hole pattern.

The final step is derived using the ``Subst" rule for $\zeta$, possible because all immediate subterms of $q_\zeta[\sigma^{n+1}_v]$ are values. This is because, by property 2, $\sigma^{n+1}_v$ substitutes only with values, and by property 3 $q_\zeta$ is hole pattern.

Lastly, it will be shown why $\widetilde{t} \sim t$. By the common property 2 it is $q_{\epsilon_i} \sim t_{\epsilon_i}$ and $q_{\zeta} \sim q_r$, and thus
\begin{equation*}
q_{\zeta}[\sigma^{n+1}_v] = t_{\epsilon^n_v}[\sigma^n_v] \sim q_{\epsilon^n_v}[\sigma^n_v] = t_{\epsilon^{n-1}_v} \sim ... \sim q_{\epsilon_1}[\sigma^1_v] = q_r[\sigma^0_v] \sim q_{\zeta}[\sigma^0_v] \sim q_{\zeta}[\sigma],
\end{equation*}
which means that, for each of the variables they substitute, $\sigma^{n+1}_v$ and $\sigma$ substitute with equivalent values. Especially, this means that $t_r[\sigma^{n+1}_v] \sim t_r[\sigma]$. By the common property 2, it is $t_\zeta = t_r$, and it follows that $\widetilde{t} = t_\zeta[\sigma^{n+1}_v] = t_r[\sigma^{n+1}_v] \sim t_r[\sigma] = t$.

\end{itemize}

\end{proof}

\item As we can see in the definition of $extract\_helpers$, $\langle prg \rangle^{extract\_helpers(e)}$ contains only equations that are contained in $\langle r \rangle^{e} = \big\langle eqn', H \big\rangle$, be they either $eqn'$ or contained in $H$, for some $r$ from the equations of $prg$.

\end{enumerate}

\end{proof}

\end{lemma}

%%- old version of Lemma 3
%\begin{lemma}
%
%If there is a reduction $s \longrightarrow_{prg} t$, for a program $prg$ and $s,t$ well-typed with respect to $prg$, that, in its derivation, uses only an equation $r$ and equations within a helpers set $H$,
%
%then there is a reduction sequence $s \longrightarrow^*_{prg'} t$ for some $prg'$ that contains only the equations in $\langle r, H \rangle^{extract\_des}_{prg}$.
%
%\begin{proof} Let $r := `` q' = s' "$. If $q'$ is hole pattern, it is
%\begin{equation*}
%\langle r, H \rangle^{extract\_des} = \big\langle r, H \big\rangle
%\end{equation*}
%The resulting equations are the same as the original. By setting $prg' = prg$ we have the desired $s \longrightarrow^*_{prg'} t$ (which has only one step $s \longrightarrow_{prg'} t$).
%
%Next, consider the case where $q'$ is $q.des(p_1, ..., p_k)$. It is thus
%\begin{equation*}
%\langle r, H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle
%\end{equation*}
%with $hname$, $hsig$, $heqn$ as in the definition of $extract\_des$. Especially it is $heqn = `` q_h = s' "$, with $q_h$ defined as $hname(\langle q \rangle^{vars}).des(p_1, ..., p_k)$. A sequence $s \longrightarrow^*_{prg'} t$, for a program $prg'$ that contains only the equations in $\langle r, H \rangle^{extract\_des}$ and the same data and codata definitions as $prg$, can be constructed for any reduction $s \longrightarrow_{prg} t$ by induction on the structure of its derivation.
%
%\begin{enumerate}
%
%\item \textbf{``Subst" case}:
%
%The derivation of $s \longrightarrow_{prg} t$ can either use $r$ or one of the equations within $H$.
%
%\underline{It uses an equation $`` q_H = t_H "$ within $H$.} By inversion we have the following form for the derivation:
%
%\begin{prooftree}
%\AxiomC{$s =^? q_H \searrow \sigma_H$}
%\RightLabel{\scriptsize Subst with $(q_H, t_H)$}
%\UnaryInfC{$s \longrightarrow t_H[\sigma_H]$}
%\end{prooftree}
%
%with $t_H[\sigma_H] =t$; the immediate subterms of $s$ values in $prg$. They need not be values in $prg'$, which is why the key part of the construction below is concerned with their reduction to values.
%
%Since the subterms of $s$ are values in $prg$, we already know they don't match any left-hand side of $H$. Of the two other equations' left-hand sides, only $q$ can possibly be matched by such a subterm. This is because the left-hand side of the other, $q_h$, has a function name that is different from any in $prg$. Thus the subterm wouldn't typecheck in $prg$ if it were to match against $q_h$.
%
%By Lemma 4 we have a reduction sequence
%\begin{equation*}
%s(s^1, ..., s^n) \longrightarrow^*_{prg} s(s^1_v, ..., s^n_v)
%\end{equation*}
%where all subterms of $s(s^1_v, ..., s^n_v)$ are values in $prg$, and with $s \sim s(s^1_v, ..., s^n_v)$.
%
%This reduction sequence is the initial part of the desired sequence. After it, only one final step follows, derived as given below.
%\begin{prooftree}
%\AxiomC{$s(s^1_v, ..., s^n_v) =^? q_H \searrow \sigma'_H$}
%\RightLabel{\scriptsize Subst with $(q_H, t_H)$}
%\UnaryInfC{$s(s^1_v, ..., s^n_v) \longrightarrow t_H[\sigma'_H]$}
%\end{prooftree}
%From $s \sim s(s^1_v, ..., s^n_v)$ and $s =^? q_H \searrow \sigma_H$ it follows that $t_H[\sigma'_H] \sim t_H[\sigma_H]$.
%
%\underline{The derivation uses $r$.} By inversion, we have a derivation of $s \longrightarrow_{prg} t$ that looks as follows:
%
%\begin{prooftree}
%\AxiomC{$s^{0} =^? q \searrow \sigma_0$}
%\AxiomC{$s^{1} =^? p_1 \searrow \sigma_1$}
%\AxiomC{...}
%\AxiomC{$s^{k} =^? p_k \searrow \sigma_k$}
%\RightLabel{\scriptsize PM\textsubscript{Des}}
%\QuaternaryInfC{$s =^? q' \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q', s')$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%Here it is $s = s^{0}.des(s^{1}, ..., s^{k})$, $\sigma = \sigma_0, ..., \sigma_k$ and $s'[\sigma] = t$.
%
%We also know that $s^{0}, s^1, ..., s^k$, as subterms of $s$, are values with respect to the equations of $prg$.
%
%Let $t_h := hname(\langle q \rangle^{vars})[\sigma_0]$. The desired sequence consists of the following steps:
%\begin{equation*}
%s \longrightarrow t_h.des(s^{1}, ..., s^{k}) \longrightarrow^* t_h(...).des(s^{1}_v, ..., s^{k}_v) \longrightarrow s'[\sigma']
%\end{equation*}
%The derivations for the first and the last step are given below. The intermediate sequence, which we have by Lemma 4, is necessary to reduce every $s^i$ that is not a value with respect to $prg'$ to such a value $s^i_v$. From Lemma 4 we also have
%\begin{equation*}
%t_h.des(s^{1}, ..., s^{k}) \sim t_h(...).des(s^{1}_v, ..., s^{k}_v)
%\end{equation*}
%$t_h(...)$ stands for $t_h$ with some of its subterms substituted with an equivalent subterm (especially it is $t_h(...) \sim t_h$).
%
%What follows are the derivations of the first and last step, in order.
%
%\begin{prooftree}
%\AxiomC{$s^{0} =^? q \searrow \sigma_0$}
%\RightLabel{\scriptsize Subst with $(q, `` hname(\langle q \rangle^{vars}) ")$}
%\UnaryInfC{$s^0 \longrightarrow hname(\langle q \rangle^{vars})[\sigma_0]$}
%\RightLabel{\scriptsize Cong}
%\UnaryInfC{$s \longrightarrow hname(\langle q \rangle^{vars})[\sigma_0].des(s^1, ..., s^k)$}
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$t_h(...) =^? hname(\langle q \rangle^{vars}) \searrow \sigma'_0$}
%\AxiomC{$s^{1}_v =^? p_1 \searrow \sigma'_1$}
%\AxiomC{...}
%\AxiomC{$s^{k}_v =^? p_k \searrow \sigma'_k$}
%\RightLabel{\scriptsize PM\textsubscript{Des}}
%\QuaternaryInfC{$t_h(...).des(s^1_v, ..., s^k_v) =^? q_h \searrow \sigma'$}
%\RightLabel{\scriptsize Subst with $(q_h, s')$}
%\UnaryInfC{$t_h(...).des(s^1_v, ..., s^k_v) \longrightarrow s'[\sigma']$}
%\end{prooftree}
%
%It is $s \sim t_h.des(s^1, ..., s^k) \sim t_h(...).des(s^1_v, ..., s^k_v)$ and thus $s'[\sigma'] \sim s'[sigma] = t$.
%
%For these two derivations, what also needs to be shown is the value judgement, with respect to $prg'$, for several terms used in derivation steps which require them to be values. For each such term, it suffices to show that it matches neither against $q$ nor against $q_h$, as those are the only two left-hand sides in $prg'$.
%
%\begin{itemize}
%
%\item immediate subterms of $s^0$: These terms cannot match against $q$ because $s^0$ already matches against $q$. They can also not match against $q_h$ because then they wouldn't typecheck against $prg$ (as subterms of $s$) in the first place, as $prg$ doesn't contain the function name of $q_h$.
%
%\item $hname(\langle q \rangle^{vars})[\sigma_0]$: This term cannot match against $q$ because its function name is different from any function name in $prg$. It also cannot match against $q_h$ because $q_h$ is a destructor pattern while the term is not a destructor call.
%
%\end{itemize}
%
%\item \textbf{``Cong" case}:
%
%By inversion we have the following form for the derivation:
%\begin{prooftree}
%\AxiomC{$s_0 \longrightarrow t_0$}
%\RightLabel{\scriptsize Cong}
%\UnaryInfC{$\mathcal{E}[s_0] \longrightarrow \mathcal{E}[t_0]$}
%\end{prooftree}
%with $\mathcal{E}[s_0] = s, \mathcal{E}[t_0] = t$. By the induction hypothesis, we have
%\begin{equation*}
%s_0 \longrightarrow_{prg'} t_0
%\end{equation*}
%The following sequence will be constructed:
%\begin{equation*}
%\mathcal{E}[s_0] \longrightarrow^* \mathcal{E'}[s_0] \longrightarrow \mathcal{E'}[t_0]
%\end{equation*}
%The final step is derived by using the ``Cong" rule on the step we have from the induction hypothesis. The initial sequence is necessary to turn all terms in $\mathcal{E}$ that are values in $prg$ into values in $prg'$ ($\mathcal{E'}$ is defined by this change).
%
%We already know that a value term (with respect to $prg$) appearing in $\mathcal{E}$ doesn't match against any left-hand side in $H$. It also cannot match against $q_h$ because that copattern has a function name not in $prg$, and the term is well-typed in $prg$. The only left-hand side that the term could possibly match against is $q$.
%
%Lemma 4 can now be used in a limited form to obtain
%\begin{equation*}
%\mathcal{E}[s_0] \longrightarrow^* \mathcal{E'}[s_0]
%\end{equation*}
%For this, the reduction sequence construction in Lemma 4 is only carried out up to (and not including) $s_0$. This turns all values with respect to $prg$ in $\mathcal{E}$ into values in $\mathcal{E'}$ with respect to $prg'$. Just as with the complete construction of Lemma 4, it is $\mathcal{E}[s_0] \sim \mathcal{E'}[s_0]$. Replacing $s_0$ with $t_0$, it follows that $\mathcal{E'}[t_0] \sim \mathcal{E}[t_0] = t$.
%
%\end{enumerate}
%
%\end{proof}
%
%\end{lemma}
%%-

\begin{lemma}
\label{lemma3}

Let $e$ be an helper extraction function that fulfils the extraction function properties. Write $\langle prg \rangle$ short for $\langle prg \rangle^{extract\_helpers(e)}$. Let $s$ be a closed term.

If $s$ is irreducible in $prg$, then there is a reduction sequence $s \longrightarrow^*_{\langle prg \rangle} s_v$, where $s_v \sim s$ is irreducible in $\langle prg \rangle$.

\begin{proof}

First, note that by the definition of $extract\_helper$, each equation in $\langle prg \rangle$ results from the application of $e$ to an equation $r$ in $prg$; specifically, it is contained in $\langle r \rangle^e$. It can thus be distinguished between two different types of equations in $\langle prg \rangle$, those are given below.

Now, the proof proceeds by induction on the structure of $s$.

Suppose the lemma holds for the immediate subterms of $s$ (the induction hypothesis). This lets us reduce the immediate subterms of $s$ to equivalent values (in $\langle prg \rangle$) first (from left to right). Let $s^0$ be the result of these reductions; it is equivalent to $s$. Let
\begin{equation*}
s^0 \longrightarrow s^1 \longrightarrow ... \longrightarrow s^i \longrightarrow ...
\end{equation*}
be the possibly infinite reduction sequence starting with $s^0$. There are exactly two types of equations in $\langle prg \rangle$:
\begin{itemize}
\item Type 1: Those which do ``actual work" because they are the equivalent of an equation in $prg$. Precisely, such an equation $r'$ has the property that there is an $r$ of $prg$ such that: $q_{r'} \sim q_r$ and $t_{r'} \sim t_r$.

\item Type 2: Those which are ``helper steps" used to provide for the syntactic changes of the transformation. Such an equation $r_h$ doesn't do any actual ``semantic change" to the term, precisely, it has the property $q_{r_h} \sim t_{r_h}$.
\end{itemize}
It will now be shown that each reduction step
\begin{equation*}
s^i \longrightarrow s^{i+1}
\end{equation*}
in the sequence above can only use equations of Type 2. Note that from this it immediately follows that $s^{i+1} \sim s^i$. The statement is proved by induction on $i \in \mathbb{N}$:
\begin{itemize}
\item $i = 0$: The immediate subterms of $s^0$ are values. Thus it can only reduce by the ``Subst" rule. Suppose there was an equation $r'$ in $\langle prg \rangle$ of Type 1, with an equivalent $r$ in $prg$, such that $s^0$ matched $q_{r'}$. $s \sim s^0$ is a value in $prg$, thus it doesn't match $r$. Especially, this means that $s \neq q_r[\sigma]$ for \textit{every} substitution $\sigma$. For terms of $prg$, it holds that, if they aren't equal, they aren't equivalent, thus $s \not\sim q_r[\sigma]$ for every $\sigma$. But, as supposed, $s^0$ matches $q_{r'}$, and thus $s^0 = q_{r'}[\sigma]$ for some $\sigma$. Since $r'$ has Type 1, it is $q_{r'} \sim q_r$, and from this it follows that $s \sim s^0 \sim q_r[\sigma]$, a contradiction.

\item $i = i' + 1$: Each previous reduction step used the ``Subst" rule for an equation of Type 2. By the third common extraction function property, these preserve the property of a term that its immediate subterms are values. Thus $s^i$ reduces by the ``Subst" rule, as well. Suppose there was an equation $r'$ in $\langle prg \rangle$ of Type 1, with an equivalent $r$ in $prg$, such that $s^i$ matched $q_{r'}$.
By the induction hypothesis, it is $s^{i} \sim s^{i'}$. Further, it is $s^i \sim s^{i'} \sim ... \sim s^0$. $s^0$ doesn't match $q_{r'}$, and it is $s^0 \neq q_{r'}[\sigma]$ for every $\sigma$ and $s^0 \not\sim q_{r'}[\sigma]$. But, as supposed, $s^i$ matches $q_{r'}$, and thus $s^i = q_{r'}[\sigma]$ for some $\sigma$. It follows that $s^0 \sim s^i = q_{r'}[\sigma]$, a contradiction.

\end{itemize}

Finally, it needs to be shown that the reduction sequence given above is in fact not infinite. That is, it results in a value. That this value is equivalent to the start has already been shown. It has also been shown that each step uses only an equation of Type 2. By the common extraction function property 4, these have the additional property that they reduce the ``pattern weight", which is defined to mean that the number of copatterns appearing in the term, or that of patterns, or both added together, has decreased, while neither the number of copatterns nor that of the patterns has increased. But this ``pattern weight" can obviously not decrease infinitely, which means that the number of equations used must be finite.

\end{proof}

\end{lemma}

%%- old version of Lemma 4
%\begin{lemma}
%
%Let $s(s^1, ..., s^n)$ be any closed term $s$ with its proper outer-most subterms $s^i$, from left to right, that match against $q$, for some copattern $q$. This notation for $s$ will be used for contextual substitution. Also, let there be a rule $(q, s')$ with $s^i =^? q \searrow \sigma$ and $s'[\sigma] \sim s^i$. Finally, let $prg$ be a program that contains no rule other than $(q, s')$ that any subterm of $s$ matches against, and with respect to which $s'[\sigma_v]$ is a value, for any substitution $\sigma_v$ that substitutes only with values.
%
%Then there is a reduction sequence $s \longrightarrow^*_{prg} s(s^1_v, ..., s^n_v)$ that uses only $(q, s')$ in its derivation, with all $s^i_v$ values in $prg$ and $s^i_v \sim s^i$. Especially, these last properties are equivalent with the properties that all proper subterms of $s(s^1_v, ..., s^n_v)$ are values in $prg$, and that $s \sim s(s^1_v, ..., s^n_v)$.
%
%\begin{proof} By induction on the structure of $s$.
%
%\begin{enumerate}
%
%\item $s = con(t^1, ..., t^k)$.
%
%Let $I \subseteq \{1, ..., k\}$ be the set of indices $i$ for which either $t^i$ or one of its subterms matches $q$. Set $t^i_v := t^i$ for $i \not\in I$. The desired sequence can be given as follows:
%\begin{equation*}
%con(t^1, ..., t^k) \longrightarrow^* con(t^1_v, ..., t^k_v)
%\end{equation*}
%It consists of the sequences
%\begin{equation*}
%con(t^1_v, ..., t^{i-1}_v, t^i, t^{i+1}, ..., t^k) \longrightarrow^* con(t^1_v, ..., t^{i-1}_v, t^i_v, t^{i+1}, ..., t^k)
%\end{equation*}
%for each $i \in I$, in ascending order. It will be shown that $t^i_v \sim t^i$ for each $i \in I$, from which $con(t^1, ..., t^k) \sim con(t^1_v, ..., t^k_v)$ follows (since $t^i_v = t^i$ for $i \not\in I$).
%Three cases for $i \in I$ must be distinguished.
%
%Case 1: $t^i$ matches $q$, but not any of its proper subterms. Then the above sequence consists only of one step, which can be derived as follows.
%\begin{prooftree}
%\AxiomC{$t^i =^? q \searrow \sigma^i$}
%\RightLabel{\scriptsize Subst with $(q, s')$}
%\UnaryInfC{$t^i \longrightarrow s'[\sigma^i]$}
%\RightLabel{\scriptsize Cong}
%\UnaryInfC{$con(..., t^i, ...) \longrightarrow con(..., t^i_v, ...)$}
%\end{prooftree}
%Set $t^i_v := s'[\sigma^i]$. It is a value because $\sigma^i$ can only substitute with values since the proper subterms of $t^i$ are values. Clearly $t^i$ is a proper outer-most subterm of $s$ matching $q$, thus $t^i \sim s'[\sigma^i] = t^i_v$.
%
%Case 2: $t^i$ doesn't match $q$, but at least one of its proper subterms does. Then, by the induction hypothesis, we have the following sequence that uses only $(q, s')$:
%\begin{equation*}
%t^i \longrightarrow^* t'^i
%\end{equation*}
%The subterms of $t'^i$ are values in $prg$, set $t^i_v := t'^i$. We get the above sequence for $i$ by applying the ``Cong" rule at each step. We also know from the induction hypothesis that $t^i \sim t'^i = t^i_v$.
%
%Case 3: $t^i$ and at least one of its proper subterms matches $q$. Then first retrieve a sequence like in Case 2 and add to that a step as in Case 1 (use this lemma with the result of the Case 2 sequence for this). $t^i \sim t^i_v$ follows from the equivalences shown in Case 2 and Case 1 by transitivity.
%
%\item $s = fun(t^1, ..., t^k)$.
%
%This case can be shown analogously to $s = con(t^1, ..., t^k)$.
%
%\item $s = t^0.des(t^1, ..., t^k)$.
%
%The following sequence will be constructed:
%\begin{equation*}
%t^0.des(t^1, ..., t^k) \longrightarrow^* t'^0_v.des(t'^1_v, ..., t'^k_v)
%\end{equation*}
%By the induction hypothesis, we have sequences from $t^i$ to a $t'^i$ with $t^i \sim t'^i$ and with only values as proper subterms of $t'^i$, for every $i \in \{0, ..., k\}$. Apply the ``Cong" rule at each step and add the sequences behind one another (in ascending order of $i$) to retrieve the following sequence, which is the initial part of the constructed sequence.
%\begin{equation*}
%t^0.des(t^1, ..., t^k) \longrightarrow^* t'^0.des(t'^1, ..., t'^k)
%\end{equation*}
%Set $t'^i_v := t'^i$ for each $i \in \{0, ..., k\}$ where $t'^i$ doesn't match against $q$. Add a step
%\begin{equation*}
%t'^0.des(t'^1, ..., t'^k) \longrightarrow t'^0_v.des(t'^1, ..., t'^k)
%\end{equation*}
%if $t'^0$ matches against $q$. Add further steps, in ascending order of $i$, for every $i \in \{1, ..., k\}$ where $t'^i$ matches against $q$:
%\begin{equation*}
%t'^0_v.des(t'^1_v, ..., t'^{i-1}_v, t'^i, t'^{i+1} ..., t^k) \longrightarrow t'^0_v.des(t'^1_v, ..., t'^{i-1}_v, t'^i_v, t'^{i+1} ..., t^k)
%\end{equation*}
%Those steps can all be derived analogously to 1., Case 1, and the desired properties of $t'^i_v$ can also be shown analogously to there.
%
%\end{enumerate}
%
%\end{proof}
%
%\end{lemma}

%%--

%%-- under construction

\subsection{Proofs of (1a) and (1b)}

The bisimulation statements (1a) and (1b) hold for $unmix_r$ (TODO: redefine, see TODO in its proof of (1a)), $elim\_outer\_des$ and $disentangle_d$ by virtue of Proposition 1 below. This is because they are all defined as $extract\_helpers(e)$ for some helper extraction function $e$ with the extraction function properties, and don't affect input terms. The relevant helper extraction functions are $extract\_outer\_des$, $extract\_all\_des$, and $extract\_patterns$, and their extraction function properties are proved in the subsection that follows Proposition 1.

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties. Then let $trans$ be a transformation which doesn't affect input terms, and for programs, is defined as $extract\_helpers(e)$.

\begin{enumerate}

\item Statement (1a) holds for $trans$.

\item Statement (1b) holds for $trans$.

\end{enumerate}

\begin{proof} ~

\begin{enumerate}

\item By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$s =^? q \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

We know that $e$ fulfils the extraction function properties. Using \hyperref[lemma2]{ Lemma 2.1 } for $e$ and $(q_r, t_r) = (q, s')$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t'$ for a $t' \sim t$, since $trans = extract\_helpers(e)$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s^0 \longrightarrow t^0$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s^0] \longrightarrow \mathcal{E}[t^0]$}
\end{prooftree}

with $\mathcal{E}[s^0] = s$ and $\mathcal{E}[t^0] = t$.

First note that Lemma 3 is applicable for $\langle prg \rangle$, because $trans = extract\_helpers(e)$ and $e$ fulfils the extraction function properties.

The desired sequence can be constructed as follows.

Terms immediately under $\mathcal{E}$ in its structure that are values in $prg$ but aren't values in $\langle prg \rangle$ need to be reduced to equivalent values first. For this, Lemma 3 can be applied multiple times to produce sequences that, starting with $\mathcal{E}[s^0]$ and always reducing the left-most such subterm, achieve exactly that. Thus we obtain an initial reduction $s \longrightarrow^*_{\langle prg \rangle} \widetilde{\mathcal{E}}[s^0]$ with $\widetilde{\mathcal{E}}[s^0] \sim \mathcal{E}[s^0]$.

By the induction hypothesis we have $s^0 \longrightarrow_{\langle prg \rangle} \widetilde{t^0}$, for a $\widetilde{t^0} \sim t^0$. By applying the congruence rule we get $\widetilde{\mathcal{E}}[s^0] \longrightarrow_{\langle prg \rangle} \widetilde{\mathcal{E}}[\widetilde{t^0}] \sim \mathcal{E}[\widetilde{t^0}] \sim \mathcal{E}[t^0]$.

\end{enumerate}

\item By inspecting the proof of 1.

\begin{enumerate}

\item \textbf{``Subst" case}:

The relevant sequence is constructed by \hyperref[lemma2]{ Lemma 2.1 }. As stated in its proof, all the steps before the last are constructed using \hyperref[lemma3]{ Lemma 3 }. It is also stated there that each step is equivalent to the start term, which can be seen by inspecting the proof of \hyperref[lemma3]{ Lemma 3 }. Going through this proof, one can see that any step is constructed in such a way that it is equivalent to the previous.

\item \textbf{``Cong" case}:

The relevant initial part of the sequence is constructed by Lemma 3. Again, by inspecting its proof, it can be seen that each step is equivalent to the start term.

\end{enumerate}

\end{enumerate}

\end{proof}

\end{proposition}

%%--

\subsubsection{Proofs for extraction function properties}

\begin{proof}[Proof for $extract\_outer\_des$]

This extraction function is of Kind `A' (``Destructor extraction"). First, the rule-specific properties are proved, then the whole-program properties.

\underline{Rule-specific properties:} The properties are strengthened, as follows below, and then proved by induction on the structure of $q_r$.

\underline{Induction-specific strengthening:}
\begin{enumerate}
\item The function name of $q_{\epsilon_1}$ is declared in $prg$.
\item $q_{\epsilon_2}, ..., q_{\epsilon_n}$ are all destructor patterns, and unless $r = \zeta$, $q_\zeta$ is destructor pattern, too.
\end{enumerate}

\begin{itemize}

\item \underline{Case 1:} $q_r$ is hole pattern.

\begin{equation*}
\langle r \rangle^{extract\_outer\_des} = \big\langle r, \emptyset \big\rangle
\end{equation*}
The properties are now shown one by one.
\begin{itemize}
\item \underline{Induction-specific strengthening:} Nothing to show because $n = 0$ and $r = \zeta$.

\item \underline{Common properties:}
\begin{enumerate}
\item Choose $n = 0$, $\zeta = r$.
\item Clear because $n = 0$ and $\zeta = r$.
\item Clear because $n = 0$.
\item Clear because $n = 0$.
\end{enumerate}

\item \underline{Kind `A':} Nothing to show because $n = 0$.
\end{itemize}

\item \underline{Case 2:} $q_r = q'.des(p_1, ..., p_k)$.

When $q'$ is hole pattern, it is
\begin{equation*}
\langle r \rangle^{extract\_outer\_des} = \big\langle r, \emptyset \big\rangle,
\end{equation*}
and the argument is identical to Case 1. Otherwise, it is
\begin{multline*}
\langle r \rangle^{extract\_outer\_des} = \langle \langle r \rangle^{extract\_des} \rangle^{extract\_outer\_des}\\
= \langle `` q' = hname(\langle q' \rangle^{vars}) ", \{\big\langle hsig, `` hname(\langle q' \rangle^{vars}).des(p_1, ..., p_k) = t_r " \big\rangle \} \rangle^{extract\_outer\_des},
\end{multline*}
with $hname$, $hsig$ as in the definition of $extract\_des$. The induction hypothesis, applied to $q'$, yields an $n' \geq 0$ and $\epsilon'_1, ..., \epsilon'_{n'}$, and $\zeta'$, in $\langle r \rangle^e$ with the properties. Choose $n = n' + 1$, $\epsilon_i = \epsilon'_i$ for $i \in \{1, ..., n'\}$, $\epsilon_n = \zeta'$, and
\begin{equation*}
\zeta = `` hname(\langle q' \rangle^{vars}).des(p_1, ..., p_k) = t_r ".
\end{equation*} The properties are now shown one by one. (TODO: What follows is immediately clear when extraction is reformulated (with same meaning) to Writer monad style. See also the idea with the boxed plus in the proofs above for this.)
\begin{itemize}
\item \underline{Induction-specific properties:}
\begin{enumerate}
\item Follows from the induction hypothesis, since $q_{\epsilon_1} = q_{\epsilon'_1}$.
\item For $q_{\epsilon_2}, ..., q_{\epsilon_{n-1}}$, follows from the induction hypothesis, because $q_{\epsilon_i} = q_{\epsilon'_i}$ for $i \in \{2, ..., n'\}$ and $n = n'$. It has been chosen $q_{\epsilon_n} = q_\zeta'$, and if $q' = q_\zeta'$, this is a destructor pattern, otherwise, by the induction hypothesis, it is a destructor pattern, too. Finally, $q_\zeta$ has been chosen to be a destructor pattern.
\end{enumerate}

\item \underline{Common properties:}
\begin{enumerate}
\item Irrelevant since $n = n' + 1 \geq 0 + 1$.
\item By the induction hypothesis, it is $q_{\epsilon'_i} \sim t_{\epsilon'_i}$, and it has been chosen $\epsilon_i = \epsilon'_i$, for $i \in \{1, ..., n'\}$. $n$ has been chosen as $n' + 1$, and $\epsilon_n$ as $\zeta'$. By the induction hypothesis, $q_\zeta' \sim q' \sim hname(\langle q' \rangle^{vars}) \sim t_\zeta'$. Finally, $\zeta$ has been chosen such that its left-hand side is equivalent to $q_r$ and that its right-hand side is $t_r$.
\item It has been chosen $\epsilon_i = \epsilon'_i$, for $i \in \{1, ..., n-1\}$, thus, for these equations, we have the property by the induction hypothesis. It is $t_{\epsilon_n} = t_{\zeta'} = hname(\langle q' \rangle^{vars})$. When a term $t$, that substitutes only with values, matches $q_{\epsilon_n}$, it is $t = q_{\epsilon_n}[\sigma]$ for some $\sigma$ that substitutes only with values. It follows that $hname(\langle q' \rangle^{vars})[\sigma]$ only has value subterms, as well.
\item It has been chosen $\epsilon_i = \epsilon'_i$, for $i \in \{1, ..., n-1\}$, thus, for these equations, we have the property by the induction hypothesis. It is $t_{\epsilon_n} = t_{\zeta'} = hname(\langle q' \rangle^{vars})$. It is clear that its number of constructors is smaller or equal than that of $q_{\epsilon_n}$, because $t_{\epsilon_n}$ has no constructors. The number of destructors is strictly smaller, because $q_{\epsilon_n}$ is a destructor copattern, and $hname(\langle q' \rangle^{vars})$ isn't.
\end{enumerate}

\item \underline{Kind `A':}
\begin{enumerate}
\item By the induction hypothesis, it is $q_{\epsilon'_1} < q', q_{\epsilon'_2} < q'_1, ..., q_{\epsilon'_{n'}} < q'_{n'-1}$, with $q'_i := q'[q_{\epsilon'_1} \leftarrow t_{\epsilon'_1}]...[q_{\epsilon'_i} \leftarrow t_{\epsilon'_i}]$. Since $\epsilon_i = \epsilon'_i$, $q' < q_r$, and $q'_i < q_i$, for $i \in \{1, ..., n'\}$ with $n' = n-1$, we have the property up to $n-1$, i.e., it remains to be shown that $q_{\epsilon_n} < q_{n-1}$ and $q_\zeta = q_n$. $q_{\epsilon_n}$ has been chosen as $q_\zeta'$, and by the induction hypothesis it is $q_{\zeta'} = q'_{n'} = q'[q_{\epsilon'_1} \leftarrow t_{\epsilon'_1}]...[q_{\epsilon'_{n'}} \leftarrow t_{\epsilon'_{n'}}] = q'[q_{\epsilon_1} \leftarrow t_{\epsilon_1}]...[q_{\epsilon_{n-1}} \leftarrow t_{\epsilon_{n-1}}] = q_{n-1}$. And it is $q_n = q'_{n-1}.des(p_1, ..., p_k)[q_{\epsilon_n} \leftarrow t_{\epsilon_n}] = q'_{n-1}[q_{\epsilon_n} \leftarrow t_{\epsilon_n}].des(p_1, ..., p_k)$ and, by the induction hypothesis, $t_{\epsilon_n} = t_{\zeta'} = hname(\langle q' \rangle^{vars})$.
\end{enumerate}

\end{itemize}

\end{itemize}

\underline{Whole-program properties:} That $\langle prg \rangle$ is deterministic and contains no ``partially dead" rules follows from the statement below:
\begin{center}
For any equation $r$ with $q_r \leq q^{ext}$ for a left-hand side $q^{ext}$ in $prg$ with either (a) $r$ itself contained in $prg$, or (b) $q_r$ destructor pattern and $t_r = hname(\langle q_r \rangle^{vars})$, the following holds:\\
Let $t$ be a term that matches an equation $r'$ in $\langle r \rangle^e$. No prefix of $t$ matches an equation of $\langle prg \rangle$ different from $r'$.
\end{center}
This is now proved by induction on the structure of $q_r$.

\begin{itemize}
\item $q_r$ is hole pattern:

Then $\langle r \rangle^e$ contains only $r$. Because $q_r$ is hole pattern, the only prefix of a term $t$ that matches $q_r$ is $t$ itself; further, $q_r$ has a function name declared in $prg$, and so has $t$. Also, because $q_r$ is hole pattern, $r$ is contained in $prg$. For any other equation $r^*$ of $prg$, by the rule-specific properties, the equations in $\langle r^* \rangle^e$ are either:
\begin{itemize}
\item only $r^*$: Then, when $t$ matched $r^*$ in addition to $r$, the rule of which $q^{ext}$ is the left-hand side would be ``partially dead" because of $r^*$.

\item $\epsilon_1, ... \epsilon_n, \zeta$, with the rule-specific properties for $r^*$: All of these equations except $\epsilon_1$ have left-hand sides with function names not declared in $prg$, other than $t$, thus $t$ doesn't match them. $\epsilon_1$ is a prefix of $r^*$. Suppose that $t$ matched $\epsilon_1$ in addition to $r$. Then $t$ can be extended to a $t'$ that matches $r^*$, while $t$, a prefix of $t'$, matches $r$. This means the equation $r^*$ of $prg$ would be ``partially dead" because of $r$, contrary to assumption.
\end{itemize}

\item $q_r = q'.des(p_1, ..., p_k)$:

\begin{itemize}
\item \underline{Case 1:} $q'$ is hole pattern.

Then $\langle r \rangle^e$ contains only $r$; the only copattern to consider is $q_r$.

First, consider its only strict prefix $q'$. Every strict prefix $t_p$ of $t$ matches $q'$; $t_p$ thus has a function name declared in $prg$. Consider an equation $r^*$ of $prg$. The equations of its transformation result $\langle r^* \rangle^e$ are $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$, with extraction function properties relative to $r^*$.

If it is $n > 0$, the function names of $q_{\epsilon^*_2}, ..., q_{\epsilon^*_n}$, and $q_{\zeta^*}$ aren't declared in $prg$, other than that of $t_p$, thus it cannot match these copatterns. The remaining copattern, $q_{\epsilon^*_1}$, is a destructor pattern, other than $q'$, thus $t_p$ doesn't match it.

If, otherwise $n = 0$, it is $\zeta^* = r^*$. When $t_p$ matched $q_{r^*}$, since it also matches $q' < q_r \leq q^{exp}$, the equation of $q^{exp}$ would be ``partially dead" because of $r^*$, contrary to assumption.

Second, consider $q_r$ itself and the term $t$ that matches it. Again, consider an $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, the function names of $q_{\epsilon^*_2}, ..., q_{\epsilon^*_n}$, and $q_{\zeta^*}$ aren't declared in $prg$, other than that of $t$, thus it cannot match these copatterns. What remains is $q_{\epsilon^*_1} < q_{r^*}$. When $t$ matches $q_{\epsilon^*_1}$, it matches both a prefix of $q_{r^*}$ and a prefix $q_r$ of $q^{exp}$. Because of the preprocessing done by $align\_patterns$, these prefixes have both the most specific patterns of their forms, thus they are the same: $q_{\epsilon^*_1} = q_r$. We also know that either (a) $r$ is in $prg$, and then $r^* > r$ would be ``partially dead", contrary to assumption, or (b) $t_r = hname(\langle q_r \rangle^{vars})$, and then, since $q_{\epsilon^*_1} = q_r$ and $t_{\epsilon^*_1} = hname(\langle q_{\epsilon^*_1} \rangle^{vars})$, it is $\epsilon^*_1 = r$, also contrary to assumption.

\item \underline{Case 2:} $q'$ is destructor pattern.

\begin{multline*}
\langle r \rangle^{extract\_outer\_des} = \langle \langle r \rangle^{extract\_des} \rangle^{extract\_outer\_des}\\
= \langle `` q' = hname(\langle q' \rangle^{vars}) ", \{\big\langle hsig, `` hname(\langle q' \rangle^{vars}).des(p_1, ..., p_k) = t_r " \big\rangle \} \rangle^{extract\_outer\_des},
\end{multline*}
with $hname$, $hsig$ as in the definition of $extract\_des$.

By the induction hypothesis,
\begin{equation*}
\langle `` q' = hname(\langle q' \rangle^{vars}) " \rangle^e
\end{equation*}
contains no ``partially dead" equations or equations that overlap with other equations. Let $h := hname(\langle q' \rangle^{vars})$. Only
\begin{equation*}
`` h.des(p_1, ..., p_k) = t_r "
\end{equation*}
remains to be considered.

First, consider its only strict prefix $h$; its function name isn't declared in $prg$. Consider an equation $r^*$ of $prg$. The equations of its transformation result $\langle r^* \rangle^e$ are $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$, with extraction function properties relative to $r^*$. This means that the function name of $q_{\epsilon^*_1}$ is declared in $prg$, unlike that of $h$, thus a term that matches it cannot match $h$. $h$ cannot match a term that matches $q_{\epsilon^*_i}$, for any $i \in \{2, ..., n\}$, because those are all destructor patterns. Finally, $h$ also cannot match a term that matches $q_{\zeta^*}$, because either (a) $\zeta^* = r^*$, and then $q_{\zeta^*}$ has a function name declared in $prg$, or (b) $q_{\zeta^*}$ is a destructor pattern.

Second, consider $h.des(p_1, ..., p_k)$ itself. Again, consider the equations $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$ of the transformation result of an equation $r^*$. The function name of $q_{\epsilon^*_1}$ is declared in $prg$, unlike that of $h$. If the function name of one of $q_{\epsilon^*_2}, ..., q_{\epsilon^*_n}, q_{\zeta^*}$ were equal to that of $h$, $q'.des(p_1, ..., p_k) = q_r$ would be a prefix of $q_{r^*}$. Because of the preprocessing done by $align\_patterns$, it has the most specific patterns of its form inside its function definition, and thus $h.des(p_1, ..., p_k)$ has the most specific patterns of its form inside its function definition.

The same holds for $q_{r^*}$ and the relevant equation $r'$ in $\langle r^* \rangle^e$. It follows that $h.des(p_1, ..., p_k)$ \textit{is} the left-hand side of $r'$. For all $r'$ except $\zeta^*$, since for these two equations the left-hand sides are equivalent to the right-hand sides, and the right-hand sides are hole patterns, the right-hand sides and thus the rules have to be the same. For $\zeta^*$, we know that its left-hand side is identical to $h.des(p_1, ..., p_k) = q_\zeta$, for the $\zeta$ relative to $r$, and thus the left-hand sides of $r$ and $r^*$ are identical. But then it would be $q_{r^*} \leq q^{ext}$, and thus $r^*$ would be ``partially dead" because of the equation of $q^{ext}$, contrary to assumption.

\end{itemize}

\end{itemize}

%(momentarily the first part of the ??? property)
%
%For each equation $r = `` q_r = t_r "$ there is an equation $r' = `` q_{r'} = t_{r'} "$ in $\langle `` q_r = t_r " \rangle^{extract\_outer\_des}$ such that the following holds:
%
%Let $\sigma$ be a substitution that covers the variables in $q_r$, and let $s^1, ..., s^n$ be the immediate subterms (from left to right) of $q_r[\sigma]$. In order to use it for contextual substitution, write $q_r[\sigma](s^1, ..., s^n)$ for $q_r[\sigma]$ and its subterms (from left to right). There is a substitution $\sigma_v$, which substitutes only with values, such that $q_{r'}[\sigma_v] = q_r[\sigma](s^1_v, ..., s^n_v)$.
%
%Proof:
%
%$\sigma_v$ is always constructed as follows, for each of its variables $x$:
%\begin{equation*}
%\sigma_v(x) = (\sigma(x))_v
%\end{equation*}
%
%\begin{itemize}
%
%\item \underline{Case 1:} $q_r$ is hole pattern or has only one destructor.
%
%Then it is $\langle r \rangle^{extract\_outer\_des} = \big\langle r, \emptyset \big\rangle$. Choose $r' = r$.
%
%\begin{itemize}
%
%\item \underline{Case 1.1:} $q_r$ is hole pattern, i.e., $q_r = fun(p_1, ..., p_k)$.
%
%It is
%\begin{multline*}
%q_{r'}[\sigma_v] = q_r[\sigma_v] = fun(p_1, ..., p_k)[\sigma_v] = fun(p_1[\sigma_v], ..., p_k[\sigma_v]) \\
%= fun((p_1[\sigma])_v, ..., (p_k[\sigma])_v) = fun(s^1_v, ..., s^k_v) = q_r[\sigma](s^1_v, ..., s^k_v)
%\end{multline*}
%because $p_i[\sigma_v] = (p_i[\sigma])_v$, as can be easily shown by induction on the structure of the pattern and using $\sigma_v(x) = (\sigma(x))_v$.
%
%\item \underline{Case 1.2:} $q_r = fun(p_1, ..., p_k).des(p'_1, ..., p'_l)$.
%
%It is
%\begin{multline*}
%q_{r'}[\sigma_v] = q_r[\sigma_v] = (fun(p_1, ..., p_k).des(p'_1, ..., p'_l))[\sigma_v] \\
%= fun(p_1[\sigma_v], ..., p_k[\sigma_v]).des(p'_1[\sigma_v], ..., p'_l[\sigma_v]) \\
%= fun((p_1[\sigma])_v, ..., (p_k[\sigma])_v).des((p'_1[\sigma])_v, ..., (p'_l[\sigma])_v) \\
%= (fun(p_1[\sigma], ..., p_k[\sigma]))_v.des((p'_1[\sigma])_v, ..., (p'_l[\sigma])_v) = s^1_v.des(s^2_v, ..., s^{l+1}_v)
%\end{multline*}
%because $(fun(p_1[\sigma], ..., p_k[\sigma]))_v = fun((p_1[\sigma])_v, ..., (p_k[\sigma])_v)$. This will be shown next.
%
%Suppose that $fun((p_1[\sigma])_v, ..., (p_k[\sigma])_v)$ could further reduce in $\langle prg \rangle$, which would only be possible by the ``Subst" rule using a left-hand side of the form $fun(...)$. By induction on the structure of the copattern $q$, it can be easily shown that $\langle `` q = t " \rangle^{extract\_outer\_des}$ (for arbitrary $t$) can only contain a left-hand side of the form $fun(...)$ (a hole pattern) if $q = fun(...)$. It follows that there already is a left-hand side of the form $fun(...)$ in $prg$. But then $fun(p_1[\sigma], ..., p_k[\sigma])$ would not be a value in $prg$, contrary to the assumption. Thus $fun((p_1[\sigma])_v, ..., (p_k[\sigma])_v)$ cannot reduce further in $\langle prg \rangle$ and is a value.\footnote{It has codata type because otherwise $fun(p_1[\sigma], ..., p_k[\sigma])$ would not be a value in $prg$.}
%
%\end{itemize}
%
%\item \underline{Case 2:} $q_r = q'.des(p_1, ..., p_k)$ with $q'$ a destructor pattern.
%
%Then it is
%\begin{multline*}
%\langle r \rangle^{extract\_outer\_des} = \langle \langle r \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
%= \langle `` q' = \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen} " , \{\big\langle hsig, heqn \big\rangle\} \rangle^{extract\_outer\_des}
%\end{multline*}
%with $hsig, heqn$ as in the definition of $extract\_des$, especially 
%\begin{equation*}
%heqn = ``  \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}.des(p_1, ..., p_k) = t_r "
%\end{equation*}
%This equation $heqn$ is also in $\langle r \rangle^{extract\_outer\_des}$. (TODO: This is immediately clear when extraction is reformulated (with same meaning) to Writer monad style. See also the idea with the boxed plus in the proofs above for this.) Choose $r' = heqn$. It is
%\begin{multline*}
%q_{r'}[\sigma_v] = (\langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}.des(p_1, ..., p_k))[\sigma_v] \\
%= (\langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v]).des(p_1[\sigma_v], ..., p_k[\sigma_v]) \\
%= (q'[\sigma])_v.des((p_1[\sigma])_v, ..., (p_k[\sigma])_v) = q_r[\sigma](s^1_v, ..., s^{k+1}_v)
%\end{multline*}
%because
%\begin{equation*}
%\langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v] = (q'[\sigma])_v,
%\end{equation*}
%which will be shown next. For this, let $q' = q''.des'(p_1, ..., p_l)$. It is now proved by induction on the structure of $q''$ that $q'[\sigma]$ reduces to $\langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v]$.
%
%\begin{itemize}
%
%\item $q'' = fun(p'_1, ..., p'_m)$:
%\begin{multline*}
%(q'[\sigma])_v = (fun(p'_1[\sigma], ..., p'_m[\sigma]).des(p_1[\sigma], ..., p_l[\sigma]))_v\\
%= (fun((p'_1[\sigma])_v, ..., (p'_m[\sigma])_v)_v.des((p_1[\sigma])_v, ..., (p_l[\sigma])_v))_v \\
%= ((fun(p'_1[\sigma_v], ..., p'_m[\sigma_v]))_v.des(p_1[\sigma_v], ..., p_l[\sigma_v]))_v\\
%= (((fun(p'_1, ..., p'_m))[\sigma_v])_v.des(p_1[\sigma_v], ..., p_l[\sigma_v]))_v \\
%= (q'[\sigma_v])_v = \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v]
%\end{multline*}
%The last equation is derived by using the equation
%\begin{equation*}
%`` q' = \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen} "
%\end{equation*}
%for the reduction of $q'[\sigma_v]$ by the ``Subst" rule. This equation is contained in $\langle r \rangle^{extract\_outer\_des}$ because
%\begin{multline*}
%\langle r \rangle^{extract\_outer\_des} \\
%= \langle `` q' = \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen} " , \{\big\langle hsig, heqn \big\rangle\} \rangle^{extract\_outer\_des}\\
%= \big\langle `` q' = \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen} " , \{\big\langle hsig, heqn \big\rangle\} \big\rangle
%\end{multline*}
%
%\item $q'' = q^0.des(p'_1, ..., p'_m)$:
%\begin{multline*}
%(q'[\sigma])_v = ... =  ((q^0[\sigma])_v.des(p'_1[\sigma_v], ..., p'_m[\sigma_v]).des(p_1[\sigma_v], ..., p_l[\sigma_v]))_v\\
%= (\langle \textrm{extract}, \langle q^0 \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v].des(p'_1[\sigma_v], ..., p'_m[\sigma_v]).des(p_1[\sigma_v], ..., p_l[\sigma_v]))_v\\
%= (\langle \textrm{extract}, \langle q^0.des(p'_1, ..., p'_m) \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v].des(p_1[\sigma_v], ..., p_l[\sigma_v]))_v \\
%= (\langle \textrm{extract}, \langle q^0.des(p'_1, ..., p'_m).des(p_1, ..., p_l) \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v])_v\\
%= \langle \textrm{extract}, \langle q^0.des(p'_1, ..., p'_m).des(p_1, ..., p_l) \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v]\\
%= \langle \textrm{extract}, \langle q' \rangle^{name\_pattern}, prg \rangle^{autogen}[\sigma_v]
%\end{multline*}
%
%\end{itemize}
%
%\end{itemize}

\end{proof}

\begin{proof}[Proof for $extract\_all\_des$]

TODO (very similar to $extract\_outer\_des$)

\end{proof}

\begin{proof}[Proof for $extract\_patterns$] This extraction function is of Kind `B' (``Constructor extraction"). First, the rule-specific properties are proved, then the whole-program properties.

\underline{Rule-specific properties:} The following cases need to be distinguished.

\begin{itemize}

\item \underline{Case 1}: $q_r$ is hole pattern:

$\langle `` q_r = t_r " \rangle^{extract\_patterns} = \big\langle `` q_r = t_r ", \emptyset \big\rangle$

Choose $n = 0$ and $\zeta = r$. The properties are now shown one by one.

\begin{itemize}
\item \underline{Common properties:}
\begin{enumerate}
\item Clear.
\item Clear because $n = 0$ and $\zeta = r$.
\item Clear because $n = 0$.
\item Clear because $n = 0$.
\end{enumerate}

\item \underline{Kind `B': ``Constructor extraction":} Nothing to show since $n = 0$.

\end{itemize}

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\not\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:
\begin{multline*}
\langle q \rangle^{extract\_patterns}\\
= \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{ \big\langle hsig, heqn \big\rangle \} \big\rangle
\end{multline*}
with $hname, hsig, heqn$ as in the definition of $extract\_patterns$. Choose $n = 1$ and
\begin{equation*}
\epsilon_1 = `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ".
\end{equation*}
and
\begin{equation*}
\zeta = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = t_r ".
\end{equation*}

\begin{itemize}
\item \underline{Common properties:}
\begin{enumerate}
\item Irrelevant since $n = 1$.
\item $\epsilon_1$ has been chosen such that its sides are equivalent, and $\zeta$ has been chosen such that $q_\zeta \sim q$ and its right-hand side is $t_r$.
\item Consider a term $t$ with only irreducible subterms, that matches $q_{\epsilon_1}$. It is $t = q_{\epsilon_1}[\sigma]$ for some $\sigma$ that substitutes only with values. Further, it is $t_{\epsilon_1}[\sigma] = hname(x_1, ..., x_n, x'_1, ..., x'_k)[\sigma]$, and this has only values as subterms.
\item Clear because $\epsilon_1$ has been chosen such that its left-hand side is a destructor pattern, its right-hand side isn't, and both sides don't have any constructors at all.
\end{enumerate}

\item \underline{Kind `B': ``Constructor extraction":}
\begin{enumerate}
\item Choose $q_0 = fun(x_1, ..., x_n).des(x'_1, ..., x'_k)$, $\sigma^1_v(x_i) = p_i[\sigma]$, $\sigma^1_v(x'_i) = p'_i[\sigma]$.
\item Choose $\sigma^2_v$ such that $x_i[\sigma^1_v] = p_i[\sigma^2_v]$ and $x'_i[\sigma^1_v] = p'_i[\sigma^2_v]$.
\item Clear because $n < 2$ and $q_\zeta = hname(p_1, ..., p_n, p'_1, ..., p'_k)$.
\end{enumerate}

\end{itemize}

\end{itemize}

\underline{Whole-program properties:} For every equation $r$ of $prg$, it is shown that a term that matches an equation of $\langle r \rangle^e$ matches no other equation of $\langle prg \rangle$. The following cases need to be distinguished.

\begin{itemize}

\item \underline{Case 1}: $q_r$ is hole pattern:

Then $\langle r \rangle^e$ contains only $r$. Consider another equation $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$. If $n > 0$, all of these except $\epsilon^*_1$ have left-hand sides with function names not declared in $prg$, other than $r$, and $q_{\epsilon^*_1}$ is destructor pattern, also unlike $r$. Otherwise, if $n = 0$, it is $\zeta^* = r^*$, and if a term matched both $r^*$ and $r$, $prg$ would be nondeterministic, contrary to assumption.

\item \underline{Case 2}: $q_r = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\not\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:

Then $\langle r \rangle^e$ contains only $r$. Consider another equation $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, all of these except $\epsilon^*_1$ have left-hand sides with function names not declared in $prg$, other than $r$. And $q_{\epsilon^*_1}$ is simply $q_{r^*}$ with its patterns replaced with variables. If a term matched both $q_{\epsilon^*_1}$ and $q_r$, since both have only variables as patterns, they would be identical. Thus $q_{r^*}$ and $q_r$ would overlap and $prg$ would be nondeterministic, contrary to assumption.

Otherwise, if $n = 0$, it is $\zeta^* = r^*$. And if a term matched both $r^*$ and $r$, $prg$ would be nondeterministic, contrary to assumption.

\item \underline{Case 3}: $q_r = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$, $\exists p \in \{ p_1, ..., p_n, p'_1, ..., p'_k \}: p$ is constructor application:

Then $\langle r \rangle^e$ contains only
\begin{equation*}
\epsilon_1 = ``fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hfun(x_1, ..., x_n, x'_1, ..., x'_k)"
\end{equation*}
and
\begin{equation*}
\zeta = ``hfun(p_1, ..., p_n, p'_1, ..., p'_k) = t_r".
\end{equation*}

First, consider the first equation $\epsilon_1$. Consider an equation $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, all of these except $\epsilon^*_1$ have left-hand sides with function names not declared in $prg$, unlike $\epsilon_1$. When a term $t$ matches $q_{\epsilon_1}$ and $q_{\epsilon^*_1}$, it follows that $q_{\epsilon_1} = q_{\epsilon^*_1}$, since, for both equations, all of their patterns are variables. But the right-hand side of $\epsilon^*_1$ is built from its left-hand side in the same way that the right-hand side of $\epsilon_1$ is built from the left-hand side of $\epsilon_1$, and thus $\epsilon^*_1$ and $\epsilon_1$ are the same.

If otherwise $n = 0$, it is $\zeta^* = r^*$. A term $t$ that matches $\epsilon_1$ also matches $r$, because $q_{\epsilon_1}$ is simply $q_r$ with all of its patterns replaced by variables. If $t$ matched $\zeta^* = r^*$ as well, $prg$ would be nondeterministic, contrary to assumption.

Second, consider the other equation contained in $\langle r \rangle^e$, $\zeta$. Again, consider an equation $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, that is, specifically for this extraction function, it is $n = 1$, and of the two equations in $\langle r^* \rangle^e$, only $\zeta^*$ needs to be considered, because $\epsilon^*_1$ has a function name declared in $prg$, unlike $\zeta$. For any term $t = hfun(t_1, ..., t_n, t'_1, ..., t'_k)$ that matches $q_\zeta$ there is a term $t^0 = fun(t_1, ..., t_n).des(t'_1, ..., t'_k)$ that matches $q_r$. If $t$ matched $q_{\zeta^*}$, as well, $t^0$ would also match $q_{r^*}$ in the same way, and thus $prg$ would be nondeterministic, contrary to assumption.

If otherwise $n = 0$, it is $\zeta^* = r^*$. Thus $q_{\zeta^*}$ has a function name declared in $prg$, unlike $\zeta$.

\end{itemize}

\end{proof}

\begin{proof}[Proof for $extract$]

The extraction function is of Kind `B' (``Constructor extraction"). First, the rule-specific properties are proved, then the whole-program properties.

\underline{Rule-specific properties:} The properties are strengthened, as follows below, and then proved by induction on the number $n_c$ of constructor patterns within the copattern that is the left-hand side of the argument of $extract$.

\underline{Induction-specific strengthening:}

$\zeta = heqn$ with $\langle r \rangle^{extract} = \langle r', \{\big\langle hsig, heqn \big\rangle\} \rangle^{extract}$, unless $n = 0$.

Proof by induction:

\begin{itemize}

\item $n_c = 0$.
Then it is
\begin{equation*}
\langle r \rangle^{extract} = \big\langle r, \emptyset \big\rangle.
\end{equation*}
Choose $n = 0$, $\zeta = r$. The properties are now shown one by one.

\begin{itemize}
\item \underline{Induction-specific strengthening:} Nothing to show since $n = 0$.

\item \underline{Common properties:}
\begin{enumerate}
\item Clear.
\item Clear because $n = 0$ and $\zeta = r$.
\item Clear because $n = 0$.
\item Clear because $n = 0$.
\end{enumerate}

\item \underline{Kind `B': ``Constructor extraction":} Nothing to show since $n = 0$.
\end{itemize}

\item $n_c = n'_c + 1$.
It is
\begin{equation*}
\langle r \rangle^{extract} = \langle `` (q_r)^{-con} = hname((q_r)^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \rangle^{extract}.
\end{equation*}
By the induction hypothesis, we have the property for $(q_r)^{-con}$. That is, we have $\epsilon'_1, ..., \epsilon'_{n'}, \zeta'$, for an $n' \geq 0$ with properties relative to $(q_r)^{-con}$. Choose $n = n'+1$, $\epsilon_i = \epsilon'_i$, for $i \in \{1, ..., n-1\}$, $\epsilon_n = \zeta'$, and $\zeta = heqn$.

\begin{itemize}
\item \underline{Induction-specific strengthening:} $\zeta$ has been chosen precisely to satisfy the strengthening.

\item \underline{Common properties:}
\begin{enumerate}
\item Irrelevant since $n = n'+1 > 0$.
\item It is $\epsilon_i = \epsilon'_i$ for $i \in \{1, ..., n-1\}$, thus for these the property follows from the induction hypothesis. It is $\epsilon_n = \zeta'$, and by the induction hypothesis, it is $t_{\zeta'} = hname((q_r)^{-con}_{vars^+})$. By the strengthening of the induction hypothesis, $q_{\zeta'}$ is either $q_{heqn'} := hname((q_r)^{-con}_{vars^-})$ or equivalent to $(q_r)^{-con}$. In both cases it is equivalent to $hname((q_r)^{-con}_{vars^+})$.
\item It is $\epsilon_i = \epsilon'_i$ for $i \in \{1, ..., n-1\}$, thus for these the property follows from the induction hypothesis. It is $t_{\epsilon_n} = t_{\zeta'} = hname((q_r)^{-con}_{vars^+})$, thus all of its immediate subterms are variables. Consider a term $t$ with only irreducible immediate subterms that matches $q_{\epsilon_n}$; it is $t = q_{\epsilon_n}[\sigma]$ for a $\sigma$ that substitutes only with values. Thus $hname((q_r)^{-con}_{vars^+})[\sigma]$ only has irreducible immediate subterms, as well.
\item It is $\epsilon_i = \epsilon'_i$ for $i \in \{1, ..., n-1\}$, thus for these the property follows from the induction hypothesis. It is $\epsilon_n = \zeta'$, and by the induction hypothesis, it is $q_{\zeta'} = hname(((q_r)^{-con})^{-con}_{vars^-})$ and $t_{\zeta'} = hname((q_r)^{-con}_{vars^+})$. Both sides have no destructors, and the right-hand side has no constructors, unlike the left-hand side.
\end{enumerate}

\item \underline{Kind `B': ``Constructor extraction":}
\begin{enumerate}
\item Set $\sigma'(x) = p_{con}[\sigma]$ for the variable $x$ replacing the left-most inner- most constructor pattern $p_{con}$, and $\sigma'(x) = \sigma(x)$ for other variables $x$. By the induction hypothesis, there is a $\sigma'^1_v$ with $(q_r)^{-con}[\sigma'] = q_{\epsilon'_1}[\sigma'^1_v]$. Choose $\sigma^1_v = \sigma'^1_v$. It is clear that $q_r[\sigma] = (q_r)^{-con}[\sigma'] = q_{\epsilon'_1}[\sigma'^1_v] = q_{\epsilon_1}[\sigma^1_v]$.

\item By the induction hypothesis, and since $\sigma'^1_v = \sigma^1_v$ and $\epsilon_i = \epsilon'_i$ for $i \in \{1, ..., n-1\}$, we have
\begin{equation*}
t_{\epsilon_1}[\sigma^1_v] = q_{\epsilon_2}[\sigma^2_v], t_{\epsilon_2}[\sigma^2_v] = q_{\epsilon_3}[\sigma^3_v], ..., t_{\epsilon_{n-2}}[\sigma^{n-2}_v] = q_{\epsilon_{n-1}}[\sigma^{n-1}_v].
\end{equation*}

Also by the induction hypothesis, it is $t_{\epsilon_{n-1}}[\sigma^{n-1}_v] = q_\zeta[\sigma'^{n' +1}_v] = q_{\epsilon_n}[\sigma'^{n}_v]$ for a $\sigma'^{n}_v$; thus choose $\sigma^{n}_v = \sigma'^{n}_v$ to gain $t_{\epsilon_{n-1}}[\sigma^{n-1}_v] = q_{\epsilon_n}[\sigma^{n}_v]$.

Finally, choose $\sigma^{n+1}_v$ as follows: Let $x^0$ be the variable at the front of $(q_r)^{-con}_{vars^+}$, and $p^0$ be the pattern at the front of $(q_r)^{-con}_{vars}$. Set $\sigma^{n+1}_v(x^0) = p^0[\sigma^n_v]$, and $\sigma^{n+1}_v(x) = \sigma^n_v(x)$ for $x \neq x^0$. Because $t_{\epsilon_n} = t_\zeta' = t_{heqn'} := hname(q^{-con}_{vars^+})$ by the strengthening of the induction hypothesis, it is $t_{\epsilon_n}[\sigma^n_v] = t_{heqn'}[\sigma^n_v] = hname(q^{-con}_{vars^-})[\sigma^{n+1}_v] = q_\zeta[\sigma^{n+1}_v]$.

\item Since $q_{\epsilon_i} = q_{\epsilon'_i}$, for $i \in \{2, ..., n-1\}$, these are hole patterns by the induction hypothesis. The same goes for $q_{\epsilon_n} = q_\zeta'$. Finally, $\zeta$ has been chosen such that its left-hand side is a hole pattern.
\end{enumerate}

\end{itemize}

\end{itemize}

\underline{Whole-program properties:} For every equation $r$ with $q_r = (...((q_{r'})^{-con})^{-con}...)^{-con}$ for an $r'$ of $prg$, it is shown that a term that matches an equation of $\langle r \rangle^e$ matches no other equation of $\langle prg \rangle$. The proof is by induction on the number of constructor patterns $n_c$ in $q_r$.

\begin{itemize}

\item $n_c = 0$.

Then $r$ is the only equation in $\langle r \rangle^e$. Consider another equation $r^*$ of $prg$ with its transformation result $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, all of these except $\epsilon^*_1$ have left-hand sides with function names not declared in $prg$, unlike $r$. $q_r$ has no constructors, as has $q_{\epsilon^*_1}$. If a term matched both, they thus would be the same, and thus $(...((q_{r'})^{-con})^{-con}...)^{-con} = q_r = q_{\epsilon^*_1} = (...((q_{r^*})^{-con})^{-con}...)^{-con}$. This means that $r'$ and $r^*$ would overlap, thus $prg$ would be nondeterministic, contrary to assumption.

If otherwise $n = 0$, it would be $\zeta^* = r^*$, and $\zeta^*$ would contain no constructors. If a term matched both $r$ and $\zeta^* = r^*$, they thus would be the same, contrary to assumption.

\item $n_c = n'_c + 1$. Then it is
\begin{equation*}
\langle r \rangle^{extract} = \langle `` (q_r)^{-con} = hname((q_r)^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \rangle^{extract}.
\end{equation*}
By the induction hypothesis, the equations in
\begin{equation*}
\langle `` (q_r)^{-con} = hname((q_r)^{-con}_{vars^+}) " \rangle^{extract}
\end{equation*}
have the desired property. It remains to be shown that a term $t$ that matches $heqn$ doesn't match another equation of $\langle prg \rangle$. Consider such an equation; it is contained in $\langle r^* \rangle^e$ for an $r^*$ of $prg$, that is, it is one of $\epsilon^*_1, ..., \epsilon^*_n, \zeta^*$.

If $n > 0$, the function name of $q_{\epsilon^*_1}$ is declared in $prg$, unlike that of $q_{heqn}$. Suppose a term matched both (a) one of $\epsilon^*_2, ..., \epsilon^*_n, \zeta^*$, and (b) $heqn$. Especially, this would mean that the function names of these two left-hand sides are the same, and this means that $(q_r)^{-con} = (...((q_{r^*})^{-con})^{-con}...)^{-con}$. But from this, since $q_r = (...((q_{r'})^{-con})^{-con}...)^{-con}$, it would follow that $q_{r'}$ and $q_{r^*}$ overlap, thus $prg$ would be nondeterministic, contrary to assumption.

If otherwise $n = 0$, it would be $\zeta^* = r^*$, and $q_{r^*}$ has a function name declared in $prg$, unlike $q_{heqn}$.

\end{itemize}

\end{proof}

\subsection{Proofs of (2)}

%%-- under construction

\begin{lemma}

For any term $t$ that reduces in $prg$, all terms equivalent to $t$ reduce in $\langle prg \rangle$.

\begin{proof}

The set of equations of $\langle prg \rangle$ is exactly the union of all sets of equations in $\langle r \rangle^e$, for all equations $r$ of $prg$. Consider a term $t$ that reduces in $prg$. By induction on the derivation of the reduction, it will be shown that any term $\widetilde{t} \sim t$ is reducible in $\langle prg \rangle$.

\begin{itemize}
\item \underline{Case 1:} $t$ reduces by the ``Subst" rule for an $r$.

If $t$ reduces in such a way, so does any term $\widetilde{t} \sim t$ by the ``Subst" rule for an equation of $\langle r \rangle^e$. It suffices to show it matches such an equation, because if a reducible subterm prevents the reduction of $\widetilde{t}$ by the ``Subst" rule, it is still the case that $\widetilde{t}$ is reducible, because of this subterm.

Now, this equation that $\widetilde{t}$ matches will be specified; the two kinds of extraction functions will be distinguished. In any case, the equations in $\langle r \rangle^e$ are $\epsilon_1, ..., \epsilon_n, \zeta$, with properties as given by the extraction function properties.

\begin{itemize}
\item \underline{Kind `A' (``Destructor extraction"):}

If $n = 0$, then $\zeta = r$. For terms $t$ that match such an equation, the set of equivalent terms consists only of $t$ itself (TODO: new property). Thus it is $\widetilde{t} = t$, and this matches $\zeta = r$, as we already know.

If otherwise $n > 0$, then there is an equation $\epsilon_i$ with $q_{\epsilon_i} < q_r$ ...

TODO

\end{itemize}

\item \underline{Case 2:} $t$ reduces by the ``Cong" rule.

TODO

\end{itemize}

\end{proof}

\end{lemma}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties. Then let $trans$ be a transformation which doesn't affect input terms, and for programs, is defined as $extract\_helpers(e)$.

Statement (2) holds for $trans$.

\begin{proof} By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

By the extraction function properties, since $s \not\sim t$, it can only be the case that $`` q = s' " = \zeta$ for the $\zeta$ in $\langle r \rangle^e$. Choose $\widetilde{s} := q_r[\sigma]$ and $\widetilde{t} := t_r[\sigma]$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$. Because $\mathcal{E}[s'] \not\sim \mathcal{E}[t']$, it follows that $s' \not\sim t'$.

By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. Apply the congruence rule to get the desired
\begin{equation*}
s = \mathcal{E}[s'] \sim \widetilde{\mathcal{E}}[\widetilde{s'}] \longrightarrow_{prg} \widetilde{\mathcal{E}}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
\end{equation*}
for an $\widetilde{\mathcal{E}} \sim \mathcal{E}$ with all names declared in $prg$, which, for each extraction function, exists by the definition of its equivalence relation. Also by this definition, $\widetilde{\mathcal{E}}$ is unique, and for a $\mathcal{E}[s']$ of the form
\begin{equation*}
fun(t^0_1, ..., t^0_{n_0}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k})
\end{equation*}
$\widetilde{\mathcal{E}}[\widetilde{s'}]$ has the form
\begin{equation*}
fun'(s^0_1, ..., s^0_{n'_0}).des'_1(s^0_1, ..., s^0_{n'_1})...des'_{k'}(s^0_1, ..., s^0_{n'_{k'}}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k}),
\end{equation*}
where each of the $s^i_j$ is equivalent to exactly one of the $t^0_i$. Thus, it actually is an evaluation context in $prg$, i.e., all of its immediate subterms left of the hole are irreducible in $prg$. To see this, consider such the highest-level subterms that can be possibly be reduced (Note: this is possible under the first proposed change, because then prefixes can't be reduced using the congruence rule); those are precisely the $s^i_j$. Suppose it reduced in $prg$, then, by Lemma 4 (TODO: prove such a lemma), the equivalent term among the $t^0_i$ would reduce in $\langle prg \rangle$, contrary to the fact that it is a value in $prg$ because it is to the left of the hole in $\mathcal{E}$.

\end{enumerate}

\end{proof}

\end{proposition}

%%--

%TODO: momentarily contains the old versions of some proofs of (1a), (1b) and other old versions that all still need to be reworked
%
%\subsubsection{Eliminate multiple destructors}
%
%\begin{proof}[Proof of (2)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%Since $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract\_outer\_des}$ contains $`` q = s' "$.
%
%$extract\_outer\_des$ fulfils the extraction function properties, as shown in the proof of (1a). By the first property it is either $q \sim s'$ or ($q_r \sim q$ and $t_r \sim s'$). In the first case, it follows that $s \sim s'[\sigma] = t$, contrary to the assumption.
%
%Now, consider the second case. The desired reduction step can be derived as follows:
%\begin{prooftree}
%\AxiomC{$q_r[\sigma] =^? q_r \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q_r, t_r)$}
%\UnaryInfC{$q_r[\sigma] \longrightarrow_{prg} t_r[\sigma]$}
%\end{prooftree}
%It is clear that $\widetilde{t} := t_r[\sigma] \sim s'[\sigma] = t$. It is $\widetilde{s} := q_r[\sigma] \sim q[\sigma] = s$.
%
%It remains to be shown that the immediate subterms of $q_r[\sigma]$ are values in $prg$. Suppose that such a subterm $s^0$ reduces to some term in $prg$; this resulting term cannot be equivalent to $s^0$ unless it is identical to $s^0$. It will be shown that this leads to a contradiction.
%
%First, note that if $s^0$ reduces in $prg$, it does so in $\langle prg \rangle$, as well.
%$s^0$ can either reduce by the ``Cong" rule, or by the ``Subst" rule. If it reduces by the ``Subst" rule, then, by Lemma 2.1, it also reduces to some term in $\langle prg \rangle$. If it reduces by the ``Cong" rule, a subterm of $s^0$ reduces by the ``Subst" rule in $prg$ and by Lemma 2.1 it does so in $\langle prg \rangle$, as well. But then either (a) the ``Cong" rule can be applied, and $s^0$ reduces by this rule in $\langle prg \rangle$, or (b) there is some non-value term left of the subterm of $s^0$ which reduces in $\langle prg \rangle$, and the ``Cong" rule can be applied, to the reduction of the left-most such subterm, to reduce $s^0$.
%
%The contradiction can be shown as follows. If $s^0$ reduces to some term in $prg$, then there is a non-value immediate subterm of $s = q[\sigma]$, contrary to the assumption. In turn, this follows from the more general statement for any copatterns $q_r, q$ with $q_r \sim q$, substitutions $\sigma$, and immediate subterms $s^0$ of $q_r[\sigma]$:
%
%If $s^0$ reduces to some term in $prg$, then there is a non-value immediate subterm of $q[\sigma]$ in $\langle prg \rangle$.
%
%This is now shown by induction on the structure of $q_r$.
%
%\begin{itemize}
%
%\item $q_r = fun(p_1, ..., p_n)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = fun(\widetilde{p_1}, ..., \widetilde{p_n})$ with $p_i \sim \widetilde{p_i}$ for $i = 1, ..., n$.
%
%Since the patterns $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus it is $q_r = q$ and $q_r[\sigma] = q[\sigma]$ and thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $s = q[\sigma]$ contains a non-value immediate subterm.
%
%\item $q = \langle \textrm{extract}, \langle q_r \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle q_r \rangle^{vars})$.
%
%The patterns $p_i$ of $q_r$ are made up only of constructor calls and variables. It follows that a reduction of $s^0$ needs to contain a step in its derivation that starts with a term that $\sigma$ substitutes one of its variables with. But this term is also a subterm of $s = q[\sigma]$, since $q$ contains (by definition) all variables of $q_r$. By the above it follows that this subterm of $s$ reduces to some term in $\langle prg \rangle$. Thus $s$ contains a non-value subterm and consequently a non-value immediate subterm.
%
%\end{itemize}
%
%\item $q_r = q'.des(p_1, ..., p_k)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = \widetilde{q'}.des(\widetilde{p_1}, ..., \widetilde{p_k})$ with $q' \sim \widetilde{q'}$ and $p_i \sim \widetilde{p_i}$ for $i \in \{1, ... k\}$.
%
%First, suppose that $s^0 = q'[\sigma]$. By the induction hypothesis, we have a non-value immediate subterm of $\widetilde{q'}[\sigma]$ in $\langle prg \rangle$. It follows that $\widetilde{q'}[\sigma]$ also is not a value in $\langle prg \rangle$. Thus we have $\widetilde{q'}[\sigma]$ as the desired non-value immediate subterm of $q[\sigma] = \widetilde{q'}[\sigma].des(\widetilde{p_1}[\sigma], ..., \widetilde{p_k}[\sigma])$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. Since the $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $q[\sigma]$ contains a non-value immediate subterm.
%
%\item $q = \langle \textrm{extract}, \langle q_r \rangle^{name\_pattern}, prg \rangle^{autogen}(\langle q_r \rangle^{vars})$.
%
%First, suppose that $s^0 = q'[\sigma]$. But this would mean that the rule of which $q_r$ is the left-hand side can never be used. This is because any term that matches it has to contain a subterm (the term the destructor is called upon) that reduces by the rule by which $s^0$ reduces. The rule of which $q_r$ is the left-hand side thus is a ``dead" rule, and these were disallowed in the preconditions for $prg$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. The argument proceeds like in this case for $q_r = fun(p_1, ..., p_n)$.
%
%\end{itemize}
%
%\end{itemize}
%
%\item \textbf{``Cong" case}:
%
%\begin{prooftree}
%\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
%\RightLabel{Cong}
%\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
%\end{prooftree}
%
%with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.
%
%By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. By applying the congruence rule we get the desired
%\begin{equation*}
%s = \mathcal{E}[s'] \sim \mathcal{E}[\widetilde{s'}] \longrightarrow_{prg} \mathcal{E}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
%\end{equation*}
%because the subterms of $\mathcal{E}$ that are values in $\langle prg \rangle$ are values in $prg$, as well. Too see this, suppose that such a subterm $s^0$ reduces to some term in $prg$. It can either do so by the ``Cong" rule, or by the ``Subst" rule. If it reduces by the ``Subst" rule, then, by Lemma 2, $s^0$ reduces to a term in $\langle prg \rangle$, as well. But this contradicts the fact that $s^0$ is a value in $\langle prg \rangle$. If it reduces by the ``Cong" rule, there is some subterm of $s^0$ that reduces by the ``Subst" rule in $prg$, and by Lemma 2 it also reduces to some term in $\langle prg \rangle$. Thus this subterm of $s^0$ is not a value in $\langle prg \rangle$. It follows that neither is $s^0$, contrary to fact.
%
%\end{enumerate}
%
%\end{proof}
%
%\subsubsection{Unmix (defunc.)}
%
%For step $unmix_d$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%\begin{itemize}
%
%\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.
%
%Then, since $unmix_d$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.
%
%\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.
%
%It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_des}$. Using Lemma 2.1, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_d$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.
%
%What follows is the proof for the above statement. From the precondition of the ``Subst" case we have that $s$ reduces to $t$ using only $`` q = s' "$. Using Lemma 3 we have the desired sequence from $s$ to $t$ using only the rules from $\langle `` q = s' " \rangle^{extract\_des}$.
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (2)] By inspecting the proof of (1).
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (3)]
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (4)] As with $elim\_multi\_des$, all equations used in the sequence are created by destructor extraction via $extract\_des$. Again, a one-step reduction using such an equation has the property of decreasing the number of destructors embedded into the term. It follows that all terms appearing in the sequence are different and thus the sequence is not infinite.
%
%\end{proof}
%
%\subsubsection{Disentangle (defunc.)}
%
%\begin{proof}[Proof of (2)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%Since $disentangle_d = extract\_helpers(extract\_patterns)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract\_patterns}$ contains $`` q = s' "$.
%
%$extract\_patterns$ fulfils the extraction function properties, as shown in the proof of (1a). By the first property it is either $q \sim s'$ or ($q_r \sim q$ and $t_r \sim s'$). In the first case, it follows that $s \sim s'[\sigma] = t$, contrary to the assumption.
%
%Now, consider the second case. From this point, the proof proceeds like that for $elim\_multi\_des$, with the following exceptions in the proof by induction on the structure of $q_r$ (identical parts are denoted by ellipses [...]):
%
%\begin{itemize}
%
%\item $q_r = fun(p_1, ..., p_n)$. $q \sim q_r$ holds only when:
%
%$q = fun(\widetilde{p_1}, ..., \widetilde{p_n})$ with $p_i \sim \widetilde{p_i}$ for $i = 1, ..., n$.
%
%[...]
%
%\item $q_r = q'.des(p_1, ..., p_k)$. There are two possible cases in which $q \sim q_r$ holds:
%
%\begin{itemize}
%
%\item $q = \widetilde{q'}.des(\widetilde{p_1}, ..., \widetilde{p_k})$ with $q' \sim \widetilde{q'}$ and $p_i \sim \widetilde{p_i}$ for $i \in \{1, ... k\}$.
%
%[...]
%
%\item $q = \langle fun, des, prg \rangle^{autogen}(p'_1, ..., p'_n, p_1, ..., p_k)$, where $\widetilde{p'_i} \sim p'_i$ for $i \in \{1, ..., n\}$, $\widetilde{p_j} \sim p_j$ for $j \in \{1, ..., k\}$, and with $q' = fun(p'_1, ..., p'_n)$. ($q'$ has this form because it is the only form possible in the relevant input fragment for $disentangle_d$.)
%
%First, suppose that $s^0 = q'[\sigma]$. But this would mean that the rule of which $q_r$ is the left-hand side can never be used. This is because any term that matches it has to contain a subterm (the term the destructor is called upon) that reduces by the rule by which $s^0$ reduces. The rule of which $q_r$ is the left-hand side thus is a ``dead" rule, and these were disallowed in the preconditions for $prg$.
%
%On the other hand, suppose that $s^0$ is $p_i[\sigma]$ for an $i \in \{1, ..., k\}$. Since the $p_i$ are made up only of constructor calls and variables, it follows that $p_i = \widetilde{p_i}$. Thus $s^0$ is also an immediate subterm of $q[\sigma]$. By the above, since $s^0$ reduces to some term in $prg$, it also reduces to some term in $\langle prg \rangle$. But then $q[\sigma]$ contains a non-value immediate subterm.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\subsubsection{Unmix (refunc.)}
%
%For step $unmix_r$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1a)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%TODO: Change $unmix_r$ such that this case distinction becomes unnecessary. Result should be: $unmix_r = extract\_helpers(extract\_all\_des)$, and this makes it necessary to change $extract\_all\_des$ to distinguish between rule from mixed and such from not-mixed function definitions. It can access the entire program and with this determine which of the two is the case.
%
%\begin{itemize}
%
%\item \underline{Case 1:} $`` q = s' "$ is from a not-mixed function definition.
%
%Then, since $unmix_r$ doesn't touch such function definitions, as can be seen directly in its definition, $(q, s') \in \textrm{Rules}(\langle prg \rangle)$ and thus $s \longrightarrow_{\langle prg \rangle} t$.
%
%\item \underline{Case 2:} $`` q = s' "$ is from a mixed function definition.
%
%It will be shown: There exists a reduction sequence from $s$ to $t$ which uses only the rules from $\langle `` q = s' " \rangle^{extract\_all\_des}$. Using Lemma 2.1, this gives us $s \longrightarrow^*_{prg'} t$ for $prg' = \langle \{ def \in prg | prg \textrm{ is (co)data def. or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)}$. Since $prg' \subseteq \langle prg \rangle$, as can be seen directly in the definition of $unmix_r$, it follows that $s \longrightarrow^*_{\langle prg \rangle} t$.
%
%What follows is the proof for the above statement. By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and by setting $H = \emptyset$, the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the structure of $q$:
%
%If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_all\_des}$.
%
%Note the similarity between the definitions of $extract\_outer\_des$ and $extract\_all\_des$: The only difference is the distinction between outer and single destructor calls in $extract\_outer\_des$. This similarity will be used in the proof below.
%
%Proof by induction:
%
%\begin{itemize}
%
%\item \underline{Case 1}: $q$ is hole pattern:
%
%$\langle `` q = s' ", H \rangle^{extract\_all\_des} = \big\langle `` q = s' ", H \big\rangle$
%
%Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.
%
%\item \underline{Case 2}: $q = q'.des(p_1, ..., p_k)$:
%
%The argument here is identical to that of Case 3 in the induction concerning $extract\_outer\_des$, inside the ``Subst" case of the proof of (1) for $elim\_multi\_des$, with $extract\_all\_des$ substituted for $extract\_outer\_des$.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\subsubsection{Disentangle (refunc.)}
%
%For step $disentangle_r$, the described kind of weak bisimulation holds.
%
%\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
%\UnaryInfC{$s \longrightarrow s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%It will be shown: there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\langle `` q = s' " \rangle^{extract}$. Using Lemma 2.1 for $e = extract$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $disentangle_r = extract\_helpers(extract)$.
%
%By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and by setting $H = \emptyset$, the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the number of constructor patterns appearing in $q$.
%
%If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract}$.
%
%Proof by induction:
%
%\begin{itemize}
%
%\item \underline{Case 1:} 0 constructor patterns appear in $q$:
%
%Then the first two cases of the definition of $extract$ are not effective, since they depend upon the presence of at least one constructor pattern in $q$. It follows that the third case (``otherwise") of the definition is effective:
%
%$\langle `` q = s' ", H \rangle^{extract} = \big\langle `` q = s' ", H \big\rangle$
%
%Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.
%
%\item \underline{Case 2:} $n+1$ constructor pattern appear in $q$, with $n \geq 0$:
%
%\begin{itemize}
%
%\item \underline{Case 2.1}: $q = fun(p^0_1, ..., p^0_n).des_1(p^1_1, ..., p^1_{n_1})...des_k(p^k_1, ..., p^k_{n_k})$, $k \geq 1$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:
%
%$\langle `` q = s' ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}$
%
%with $hname, hsig, heqn$ as in the definition of $extract$.
%
%Compared to $q$, $q^{-con}$ has one less constructor pattern. Thus we can apply the induction hypothesis to $q^{-con}$, yielding a reduction sequence from $s$ to $t$ using only the equations within $\langle `` q = s' ", H \rangle^{extract}$ if there is one with respect to $\big\langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle$.
%
%This last sequence can be constructed as in the following steps, somewhat analogous to the construction in Lemma 3. The construction starts from the known original sequence with respect to $\big\langle `` q = s' ", H \big\rangle$; let this sequence be:
%
%$t_1 \longrightarrow t_2 \longrightarrow ... \longrightarrow t_{n-1} \longrightarrow t$
%
%with $t_1 = s$, $t_n = t$. Also, let $r := (q, s')$.
%
%\begin{enumerate}
%
%\item Let $I \subseteq \{1, ..., n - 1\}$ be the set of indices $j$ where $t_j \longrightarrow t_{j+1}$ contains an application of the ``Subst" rule for $r$. For all indices $k \not\in I$, $t_k \longrightarrow t_{k+1}$ is with respect to the equations within $H$.
%
%\item For a $j \in I$, by inversion, we know the derivation of $t_j \longrightarrow t_{j+1}$ looks as follows:
%
%\begin{prooftree}
%\AxiomC{\vdots}
%\RightLabel{\scriptsize PM\textsubscript{Des}}
%\UnaryInfC{$t^0_j =^? q \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q, s')$}
%\UnaryInfC{$t^0_j \longrightarrow s'[\sigma]$}
%\UnaryInfC{$\mathcal{D'}$}
%\UnaryInfC{$t_j \longrightarrow t_{j+1}$}
%\end{prooftree}
%
%for some substitution $\sigma$, some intermediate derivation $\mathcal{D'}$ and a subterm $t^0_j$ of $t_j$.
%
%\item In the original sequence above, for every $j \in I$, replace $t_j \longrightarrow t_{j+1}$ with the two reduction steps $t_j \longrightarrow t'_j$, $t'_j \longrightarrow t_{j+1}$, in this order, with the following derivations:
%
%Derivation for $t_j \longrightarrow t'_j$:
%\begin{prooftree}
%\AxiomC{\vdots}
%\UnaryInfC{$t^0_j =^? q^{-con} \searrow \sigma'$}
%\RightLabel{\scriptsize Subst with $(q^{-con}, `` hname(q^{-con}_{vars^+}) ")$}
%\UnaryInfC{$t^0_j \longrightarrow t_h$}
%\UnaryInfC{$\mathcal{D'}_1$}
%\UnaryInfC{$t_j \longrightarrow t'_j$}
%\end{prooftree}
%
%The derivation for $t^0_j =^? q^{-con} \searrow \sigma'$, for some substitution $\sigma'$ has been omitted. We know from above that $t^0_j$ matches against $q$ returning $\sigma$. $q^{-con}$ is simply $q$ with one of its patterns $p$ replaced by a variable $x_p$, thus it catches at least all terms which are caught by $q$. $\sigma'$ is $\sigma$ where the part $\sigma_p$ of the substitution returned by matching the relevant subterm $t_p$ against $p$ is replaced by $t_p / x_p$. Let $x_1, ..., x_n$ be the variables in $q^{-con}$. It is $\sigma = \sigma_p, \sigma'[\{ x_1, ..., x_n \} \setminus \{ x_p \}]$, where $\sigma'[S]$ for a set $S$ means the substitutions of $\sigma'$ limited to those for variables in $S$.
%
%$\mathcal{D'}_1$ is $\mathcal{D'}$ where all the occurrences of $s'[\sigma]$ that stem from the reduction by substitution of $t^0_j$ to it are replaced by
%
%$t_h := `` hname(q^{-con}_{vars^+}) "[\sigma']$.
%
%$t'_j$ is defined accordingly.
%
%For the next derivation, let $q_h = `` hname(q^{-con}_{vars^-}) "$. Thus it is $heqn = `` q_h = s'  "$. 
%
%Let $k$ be the index of $x_p$, that is $x_p = x_k$, and $(y_1, ..., y_m)$ be the list $(x_1, ..., x_{k-1}, x_{k+1}, ..., x_n)$ ($m = n-1$). The list $q^{-con}_{vars^+}$ is, by definition, $(x_p, y_1, ..., y_m)$. The list $q^{-con}_{vars^-}$ is $(p, y_1, ..., y_m)$. Note that for the $\sigma'$ described above, $x_p[\sigma'] = t_p$. In the derivation below, the derivation for $x_p[\sigma'] =^? p \searrow \sigma_p$, with $\sigma_p$ as described above, has thus been omitted.
%
%Derivation for $t'_j \longrightarrow t_{j+1}$:
%
%{\setlength{\parindent}{-\leftmargin}
%\AxiomC{\vdots}
%\UnaryInfC{$x_p[\sigma'] =^? p \searrow \sigma_p$}
%\AxiomC{}
%\RightLabel{\scriptsize PM\textsubscript{Var}}
%\UnaryInfC{$y_1[\sigma'] =^? y_1 \searrow \sigma'[y_1]$}
%\AxiomC{...}
%\AxiomC{}
%\RightLabel{\scriptsize PM\textsubscript{Var}}
%\UnaryInfC{$y_m[\sigma'] =^? y_m \searrow \sigma'[y_m]$}
%\RightLabel{\scriptsize PM\textsubscript{App}}
%\QuaternaryInfC{$t_h =^? q_h \searrow \sigma$}
%\RightLabel{\scriptsize Subst with $(q_h,  s')$}
%\UnaryInfC{$t_h \longrightarrow s'[\sigma]$}
%\UnaryInfC{$\mathcal{D'}_2$}
%\UnaryInfC{$t'_j \longrightarrow t_{j+1}$}
%\DisplayProof
%}
%
%where $\mathcal{D'}_2$ is $\mathcal{D'}$ where all the occurrences of $t^0_j$ that stem from its reduction by substitution to $s'[\sigma]$ are replaced by $t_h$.
%
%
%
%\end{enumerate}
%
%\item \underline{Case 2.2}: $q = fun(con(p^0_1, ..., p^0_n), p^1_1, ..., p^1_n)$, $\exists p^j_i:$ $p^j_i$ is constructor pattern:
%
%This case proceeds completely analogous to Case 2.1, where a left-most outer constructor pattern is skipped over. This is possible since second case of the definition of $extract$, which is effective in this case, is only different in exactly this way: All relevant definitions are precisely analogous to the respective other definitions.
%
%\item \underline{Case 2.3}: otherwise:
%
%Since neither the first (as in Case 2.1) nor the second (as in Case 2.2) case of the definition of $extract$ is effective, it follows that the third case (``otherwise") is effective. Thus, proceed as in Case 1.
%
%\end{itemize}
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (2)] By inspecting the proof of (1).
%
%TODO
%
%\end{proof}
%
%\begin{proof}[Proof of (3)] By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ ($s,t$ typecheck against $prg$)
%
%\begin{enumerate}
%\item \textbf{``Subst" case}:
%
%\begin{prooftree}
%\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
%\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
%\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
%\end{prooftree}
%
%with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.
%
%When $(q, s') \in \textrm{Rules}(prg)$, so, by the ``Subst" rule, $s \longrightarrow_{prg} t$. It remains to be shown that $(q, s') \in \textrm{Rules}(prg)$.
%
%Since $disentangle_r = extract\_helpers(extract)$, by Lemma 2.2 there is an equation $r$ of $prg$ such that $\langle r \rangle^{extract}$ contains $`` q = s' "$.
%
%\begin{itemize}
%
%\item \underline{Case 1}: $r = `` fun(p^0_1, ..., p^0_n).des_1(p'_1, ..., p'_{n_1})...des_k(p^k_1, ..., p^k_{n_k}) = t' " $, $k \geq 1$, $\exists p^j_i: p^j_i \textrm{ is constructor pattern}$:
%
%It will be shown that this case contradicts the fact that $\langle r \rangle^{extract}$ contains $`` q = s' "$. This is done by showing, by induction on the number $n_c$ of constructor patterns contained in $q'$, for any $r := `` q' = t' "$ that has the above form and any helpers set $H$ (including the empty one):
%
%$\langle r , H \rangle^{extract}$ doesn't contain $`` q = s' "$ unless it is already within $H$
%
%\begin{enumerate}
%
%\item $n_c = 1$:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}
%\end{equation*}
%with $hname, hsig, heqn$ as in the definition of $extract$. Since $q'$ contains only one constructor pattern, $q'^{-con}$ contains no constructor pattern. It follows that:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \big\langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle
%\end{equation*}
% Neither of the two equations outside of $H$ in $\langle r, H \rangle^{extract}$ is $`` q = s' "$, since they both contain function names not present in $prg$.
%
%\item $n_c = n'_c + 1$, $n'_c \geq 0$:
%\begin{equation*}
%\langle `` q' = t' ", H \rangle^{extract} = \langle `` q'^{-con} = hname (q'^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract}
%\end{equation*}
%with $hname, hsig, heqn$ as in the definition of $extract$. Since $q'^{-con}$ contains one less constructor pattern than $q'$, it contains $n'_c$ such patterns. Applying the induction hypothesis we have that $\langle r, H \rangle^{extract}$ doesn't contain $`` q = s' "$ outside of $\{ \big\langle hsig, heqn \big\rangle \} \cup H$. The only remaining equation outside of $H$ that could be $`` q = s' "$ is defined by $heqn$ to contain a function name not present in $prg$. Thus this equation can't be $`` q = s' "$, either.
%
%\end{enumerate}
%
%\item \underline{Case 2}:  $r = `` fun(con(p^0_1, ..., p^0_k), p^1_1, ..., p^1_n) = t' " $, $\exists p^j_i: p^j_i \textrm{ is constructor pattern}$:
%
%This case can be shown analogously to Case 1, by using instead this other form of $r$ and the respective analogues $q^{-con'}, q^{-con'}_{vars^+}$ etc. in the places of $q^{-con}, q^{-con}_{vars^+}$ etc.
%
%\item \underline{Case 3}: otherwise:
%\begin{equation*}
%\langle r \rangle^{extract} = \big\langle r \big\rangle
%\end{equation*}
%Thus it must be $r = `` q = s' "$ and therefore $(q, s') \in \textrm{Rules}(prg)$.
%
%\end{itemize}
%
%\end{enumerate}
%
%For the ``Cong" case, proceed as with $elim\_multi\_des$.
%
%\end{proof}
%
%\begin{proof}[Proof of (4)]
%
%TODO
%
%\end{proof}

\subsection{Proofs of strong bisimulation}

Strong bisimulation holds for $split$, actual defunctionalization, and actual refunctionalization.

\subsubsection{Split}

\begin{proof}[Proof of strong bisimulation, ``$\Rightarrow$"] ~

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_1$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$; it is $\langle s \rangle = s$ and $\langle t \rangle = t$ ($split$ doesn't change input terms).

For this, define $\mathcal{D}_1$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(\langle prg \rangle)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(\langle prg \rangle)$ as well as in Rules$(prg)$, since $split$ doesn't change rules where the copattern has this form. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(con(x_1, ..., x_k), y_1, ..., y_n)$:

The argument here is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(x_1, x_2, ..., x_n)$, where $x_1$ has codata type or $n = 0$:

The argument here is identical to that in Case 1.

\item \underline{Case 4}: $q = fun(x_1, x_2, ..., x_n)$, where $n > 0$, $x_1$ has data type:

Since $(q, s') \in \textrm{Rules}(prg)$ there exists a $(q_2, s_2') \in \textrm{Rules}(\langle prg \rangle)$ with $q_2 = fun(con(y_1, ..., y_k), x_2, ..., x_n)$ and $s'_2 = s'[con(y_1, ..., y_k) / x_1]$ for every constructor $con$ with the correct type (i.e. with return type equal to the type of the first argument of $fun$). This can also be seen directly in the definition of $split$. The concrete choice of $q_2$ depends upon the choice of $con$ -- below, $con$ will be chosen as needed.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 1}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 1}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:

\begin{prooftree}
\AxiomC{$t_1 =^? x_1 \searrow t_1 / x_1$}
\AxiomC{...}
\AxiomC{$t_n =^? x_n \searrow t_n / x_n$}
\TrinaryInfC{$fun(t_1, ..., t_n) =^? q \searrow t_1 / x_1, ..., t_n / x_n$}
\end{prooftree}

With that, we also know the form of $s$: $s = fun(t_1, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 1}$ as follows:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t_1^1 =^? y_1 \searrow t_1^1 / y_1$}
\AxiomC{...}
\AxiomC{$t_k^1 =^? y_k \searrow t_k^1 / y_k$}
\TrinaryInfC{$t_1 =^? con(y_1, ..., y_k) \searrow t_1^1 / y_1, ..., t_k^1 / y_k$}
\AxiomC{$t_2 =^? x_2 \searrow t_2 / x_2$}
\AxiomC{...}
\AxiomC{$t_n =^? x_2 \searrow t_n / x_n$}
\QuaternaryInfC{$fun(t_1, ..., t_n) =^? q_2 \searrow t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  
t_n / x_n$}
\DisplayProof
}

Remember that the choice of $con$ and, depending upon that, $q_2$, was left open until needed. This is now the place where $con$ needs to be chosen such that $t_1 = con(t^1_1, ..., t^1_k)$, with the result that the derivation $\mathcal{D}_{\textrm{PM}, 1}$ given above is correct.

It is still open why $t_1$ can be chosen that way at all. To see this, consider the following cases: If $t_1$ is a variable, $s$ isn't a closed term, which is excluded by definition. If $t_1$ isn't a variable but also not a value, then the ``Subst" rule wouldn't even apply. The only case that remains is that $t_1$ is a value that has data type. By inversion (TODO: prove lemma of inversion for values) we know that $t_1$ is a constructor application of a constructor $con$. Since $t_1$ has the correct type, this same constructor $con$ can simply be chosen, as stated above.

In the derivation above, $\sigma_2 = t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  t_n / x_n$ and thus:

$s'_2[\sigma_2] = s'[con(y_1, ..., y_k) / x_1][\sigma_2] \\
= s'[con(t_1^1, ... t_k^1) / x_1, t_2 / x_2, ..., t_n / x_n] = s'[t_1 / x_1, t_2 / x_2, ..., t_n / x_n] = s'[\sigma] = t$

There is no conflict between the substitutions for, e.g., $x_2$ and $y_1$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

Other cases for $q$ are outside the relevant input fragment for $split$. This concludes the proof for the ``Subst" case.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $s' \longrightarrow_{\langle prg \rangle} t'$. By applying the congruence rule we get $\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$.

\end{enumerate}

\end{proof}

\begin{proof}[Proof of strong bisimulation, ``$\Leftarrow$"] ~

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$ ($\langle s \rangle = s, \langle t \rangle = t$); the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_1$ for $s \longrightarrow_{prg} t$.

For this, define $\mathcal{D}_1$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow_{prg} s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(prg)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(prg)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(prg)$ as well as in Rules$(\langle prg \rangle)$, since the result of $split$ doesn't contain a rule where the left-hand side copattern has this form unless the input of $split$ already contains this rule. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(x_1, ..., x_n)$:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(con(x_1, ..., x_k), y_2, ..., y_n)$:

Then there either exists $(q, s')$ in Rules($prg$) as well, in this case proceed as in Case 1, or there exists $q_2 := fun(y_1, y_2, ..., y_n)$, ($q_2, s'_2) \in \textrm{Rules}(prg)$, $s' = s'_2[con(x_1, ..., x_k) / y_1]$. This is because these are the only cases in which a rule with left-hand side copattern $q$ of this form is present in Rules($\langle prg \rangle$), as can be seen directly in the definition of $split$.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 1}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 1}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t^1_1 =^? x_1 \searrow t^1_1 / x_1$}
\AxiomC{...}
\AxiomC{$t^1_k =^? x_k \searrow t^1_k / x_k$}
\TrinaryInfC{$con(t^1_1, ..., t^1_k) =^? con(x_1, ..., x_k) \searrow t^1_1 / x_1, ..., t^1_k / x_k$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2 ..., t_n) =^? q \searrow t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$}
\DisplayProof
}

With that, $\sigma = t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$ and we also know the form of $s$: $s = fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 1}$ as follows:

\begin{prooftree}
\AxiomC{$con(t^1_1, ..., t^1_k) =^? y_1 \searrow con(t^1_1, ..., t^1_k) / y_1$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n) =^? q_2 \searrow \sigma_2$}
\end{prooftree}

In the derivation above, $\sigma_2 = con(t_1^1 ..., t_k^1) / y_1,  t_2 / y_2, ...,  t_n / y_n$ and thus:

$t = s'[\sigma] = s'_2[con(x_1, ..., x_k) / y_1][\sigma] = s'_2[con(t^1_1, ..., t^1_k) / y_1, t_2 / y_2, ..., t_n / y_n] = s'_2[\sigma_2]$

There is no conflict between the substitutions for, e.g., $x_1$ and $y_2$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

This concludes the proof for the ``Subst" case.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $s' \longrightarrow_{prg} t'$. By applying the congruence rule we get $\mathcal{E}[s'] \longrightarrow_{prg} \mathcal{E}[t']$.

\end{enumerate}

\end{proof}

\subsubsection{Actual defunctionalization}

For the actual defunctionalization, $d''$, strong bisimulation holds. The proof relies on properties of the automatic defunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $d^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $d^{core}$, the Codata Fragment, and, analogously, when restricted to the domain of their refunctionalization, the Data Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $d^{core}$.

\begin{proof}[Proof of strong bisimulation for $d''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$). Such equations (and indeed the function definitions) are left unchanged by $d''$ except for defunctionalizing the right-hand term, as can be seen directly in the definition of $d''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

By inversion, we have from $s =^? q \searrow \sigma$ that $s$ has the form $fun(v_1, ..., v_n)$ for some values $v_1, ..., v_n$, thus $\langle s \rangle = fun(\langle v_1 \rangle, ..., \langle v_n \rangle)$. By inversion for values, we have that each $v_i$ is either a constructor application or a value of codata type. If it is a value of codata type, by inversion on pattern matching, the relevant subpattern of $q$ can only be a variable, thus it is also matched by $\langle v_i \rangle$. If it is a constructor application, the relevant subpattern of $q$ is either a variable, and the same holds, or it is a constructor pattern, and by recursively descending into its subpatterns we still get that $\langle v_i \rangle = con(\langle v^1_i \rangle, ..., \langle v^m_n \rangle)$ matches against the subpattern of $q$.

By carrying the substitutions returned from the matchings along in the above recursive argument, we get a substitution $\sigma'$ such that $\langle s \rangle =^? q \searrow \sigma'$ and, by distributing over $\langle s' \rangle$, $\langle s' \rangle [\sigma'] = \langle s'[\sigma] \rangle = \langle t \rangle$. It follows that $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $d''$). Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $d^{core}$, as specified in the definition of $d''$. Let this part, amended by the ``constructor subsumption" noted for the definition of $d''$, be $prg'$; it is: $s \longrightarrow_{prg'} t$

By (*) we would have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. 

For the coverage, bear in mind that the equation $`` q = s' "$ enabling the reduction of $s$ by the ``Subst" rule is part of $prg'$ by the precondition of Case 2. As $s$ matches against $q$, copattern coverage for $s$ is trivially fulfilled in $prg'$. The immediate subterms of $s$ are values with respect to $prg$ and, by inversion, their immediate subterms and so forth, which especially means that there is no rule in $prg$ against which they match. But $prg$ has copattern coverage for such a subterm (TODO: make this a general precondition) and there is already no rule for it in $prg$. It follows that $prg'$ still has copattern coverage for the subterm even though there is no rule for it in $prg'$. This is because, either (1) the subterm is a destructor call, then it can only be covered by destructor copatterns (as it matches against a destructor copattern) and those only occur within $prg'$, or (2) it is a constructor call, which doesn't need to be matched for coverage. It can't be a function call, since these can only be covered by directly matching the call, which isn't the case even in $prg$, for which coverage is assumed. Thus coverage holds for $prg'$.

For well-typedness, simply treat the missing types temporarily, that is, for the sake of (*), as codata types. This is no problem for the restriction to the domain of $d^{core}$, since such types could be introduced inside the Codata Fragment with codata definitions. To be more precise, empty function definitions can be added for missing ones and empty codata definitions for missing types, and removed again after using (*), without adding or removing possible reductions, respectively. All in all, we have by (*):
\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle
\end{equation*}

But this program $\langle prg' \rangle^{d^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $d''$. This implies the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

Other cases are excluded by the relevant input fragment.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $\langle s' \rangle \longrightarrow_{\langle prg \rangle} \langle t' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$, defined analogously to the transformation of terms by transforming the terms in $\mathcal{E}$ and by setting $\langle [] \rangle = []$. By applying the congruence rule we get $\langle \mathcal{E} \rangle[\langle s' \rangle] \longrightarrow_{\langle prg \rangle} \langle \mathcal{E} \rangle[\langle t' \rangle]$. It is clear that $\langle \mathcal{E} \rangle[\langle s' \rangle] = \langle \mathcal{E}[s'] \rangle = \langle s \rangle$ and $\langle \mathcal{E} \rangle[\langle t' \rangle] = \langle \mathcal{E}[t'] \rangle = \langle t \rangle$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part of $prg$, as specified in the definition of $d''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $d''$, this other part is taken over unchanged from $prg$ except for defunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle$.

By (*) we would have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle \iff s \longrightarrow_{prg'} t,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. Both of those properties can be shown or simulated similarly to the way they are in the $`` \Rightarrow "$ part.

But it is $prg' \subseteq prg$, as can be seen in the definition of $d''$. This implies the desired $s \longrightarrow_{prg} t$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = \langle s \rangle$ and $\mathcal{E}[t'] = \langle t \rangle$.

By the induction hypothesis we have $s'' \longrightarrow_{prg} t''$ with $s' = \langle s'' \rangle$, $t' = \langle t'' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$ (defined as in the $`` \Rightarrow "$ part). Apply the congruence rule to get $\mathcal{E}'[s''] \longrightarrow_{prg} \mathcal{E}'[t'']$ with $\mathcal{E} = \langle \mathcal{E}' \rangle$. That is, $\mathcal{E}'$ is the result of applying the inverse of $\langle \cdot \rangle$ to $\mathcal{E}$, which is possible, since, for instance, $\mathcal{E}[s'] = \langle s \rangle$. It is $\langle \mathcal{E}'[s''] \rangle = \langle \mathcal{E}' \rangle[\langle s'' \rangle] = \mathcal{E}[s'] = \langle s \rangle$ and $\langle \mathcal{E}'[t''] \rangle = \langle \mathcal{E}' \rangle[\langle t'' \rangle] = \mathcal{E}[t'] = \langle t \rangle$ and thus we have the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\end{proof}

\subsubsection{Actual refunctionalization}

For the actual refunctionalization, $r''$, strong bisimulation holds. The proof relies on properties of the automatic refunctionalization of Uroboro in the paper of Rendel, Trieflinger, and Ostermann, in here called $r^{core}$. As stated in section 7, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $r^{core}$, the Data Fragment, and, analogously, when restricted to the domain of their defunctionalization, the Codata Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $r^{core}$.

\begin{proof}[Proof of strong bisimulation for $r''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2 (it is omitted that $prg$ is passed to $r$ as well). This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is destructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $r''$). Such equations (and indeed the function definitions) are left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

From here, the argument proceeds analogously to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

\item \underline{Case 2}: $q$ is hole pattern without arguments or where the first argument has codata type:

Then the equation is left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Proceed as in Case 1.

\item \underline{Case 3}: $q$ is hole pattern and has a first argument with data type:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$), and it has a first argument with data type. Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $des\_conv$, and then the result of this to $r^{core}$, as specified in the definition of $r''$. Let the part passed to $des\_conv$ be $prg'$; it is: $s \longrightarrow_{prg'} t$.

By (*) we have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{r^{core}}} \langle t \rangle,
\end{equation*}

But this program $\langle prg' \rangle^{r^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $r''$. Thus we have the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2. This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part of $prg$, as specified in the definition of $r''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $r''$, this other part is taken over unchanged from $prg$ except for refunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle$.

By (*) we have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle \iff s \longrightarrow_{\langle prg' \rangle^{des\_conv}} t.
\end{equation*}

In the result of $des\_conv$, no new matching left-hand sides are added. That is, $prg'$ contains at least all the matching left-hand sides that $\langle prg' \rangle^{des\_conv}$ has. Thus any reduction that is possible with respect to $\langle prg' \rangle^{des\_conv}$ is already possible with respect to $prg'$.

But it is $prg' \subseteq prg$, as can be seen in the definition of $r''$. This implies the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{proof}

\pagebreak
%%-- under construction
\begin{framed}
\textbf{Under Construction}

\subsection*{Extraction function properties}

Write $\langle prg \rangle$ for $\langle prg \rangle^{extract\_helpers(e, funs)}$ when $e, funs$ are arbitrary or clear from the context. Write $\epsilon_r, \zeta_r$ for the transformed original and the auxiliary equation in $\langle r \rangle^e$ whenever there is such an auxiliary equation. Otherwise, it is always the case that $\langle r \rangle^e$ contains only $r$ itself.

\begin{definition*}[Extraction function properties]
An extraction function $e$ is said to satisfy the extraction function properties iff

\begin{enumerate}
\item $\forall r \not\in Rules(\langle prg \rangle): s \longrightarrow^{\textrm{Subst}_r}_{prg} t \implies s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \sim t$.

\item If $s$ reduces in $prg$, so does every $\widetilde{s} \sim s$ in $\langle prg \rangle$.

\item For every equation $r$ of $prg$:
\begin{enumerate}
\item A possible $\epsilon_r$ reduces (non-strictly) the number of constructors and that of destructors, and reduces strictly either the number of constructors or that of destructors, or both.

\item The equations in $\langle r \rangle^e$ preserve the property of a term that all of its reduction-relevant subterms are values.
\end{enumerate}

\end{enumerate}

\end{definition*}

\subsection*{extract\_des:}

\begin{lemma*}

$extract\_des$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. From the definition of $extract\_helpers$ and $extract\_des$ we thus know that $q_r$ is a destructor copattern. By inversion, we know the form of $s$ is $s^0.des(\overline{t})$ The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s^0_{subv}.des(\overline{t}) = q_{\epsilon_r}[\sigma_\epsilon].des(\overline{t})\\
&\longrightarrow &t_{\epsilon_r}.des(\overline{t})\\
&\longrightarrow^*  &t_{\epsilon_r}.des(\overline{t_v}) = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r} =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s^0$ to equivalent values. We have such a sequence by Lemma ?, because $s^0$ matches $q_{\epsilon_r}$, by the definition of $\epsilon_r$ and because $s = s^0.des(\overline{t})$ and $s$ matches $q_r$.

Similarly, the second multi-step part is concerned with reducing the $\overline{t}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.
\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s^0_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s^0_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0_{subv}] \longrightarrow \mathcal{E}[t_{\epsilon_r}[\sigma_\epsilon]]$}
\end{prooftree}
with $\mathcal{E} = [].des(\overline{t})$. $s^0_{subv}$ matches $q_{\epsilon_r}$ because $s = s^0.des(\overline{t})$ and $q_r = q_{\epsilon_r}.des(\overline{p})$ and $s$ matches $q_r$. It remains to be shown (a) why $\mathcal{E}$ is actually an evaluation context, and (b) why no ``Subst" rule can take precedence over the ``Cong" rule as used in the derivation.

\begin{enumerate}
\item $\mathcal{E}$ is derived as given below.
\begin{prooftree}
\AxiomC{}
\RightLabel{\scriptsize Hole}
\UnaryInfC{$[]$}
\RightLabel{\scriptsize Frame/Des}
\UnaryInfC{$[].des(\overline{t})$}
\end{prooftree}

\item The only extension of $s^0_{subv}$ within $s^0_{subv}.des(\overline{t})$ is $s^0_{subv}.des(\overline{t})$ itself. Suppose this term matched a lhs of $\langle prg \rangle$. Each equation of $\langle prg \rangle$ either appears identical in $prg$, or there are $\epsilon_{r'}$ and $\zeta_{r'}$ in a $\langle r' \rangle^e$ for an $r'$ of $prg$.

The first case can be excluded, since (a) the function definition of $r'$ is the same as that of $r$, and this function definition has been affected since $r$ was actually transformed, and (b) $r'$ is transformed to $\epsilon_{r'}$ and $\zeta_{r'}$ because $q_{r'}$ is a destructor copattern since it is a matched by $s^0_{subv}.des(\overline{t})$.

The second case can also be excluded, because this would mean that there are overlapping patterns in the function definition, but these were eliminated by the pre-transformation.

\end{enumerate}

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
The relevant subterms of $s^0_{subv}$ were values, thus also the terms that $\sigma_\epsilon$ substituted with. And $t_{\epsilon_r}[\sigma_\epsilon]$ contains no reduction-relevant subterms, as well. $t_[\epsilon_r]$ matches $q_{\zeta_r}$ by the definition of $\epsilon_r$ and $\zeta_r$.

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_des$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg^0 \rangle^{autogen}(\langle q \rangle^{vars})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has exactly one top-level destructor call ($des_1$).

If it has more than one top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a  possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

Finally, if $\widetilde{s}$ had no top-level destructor calls, i.e., it is an application of the helper function, then there would exist equations in $prg$ which overlap. To see this, consider the form of $s \sim \widetilde{s}$: It matches a $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, as stated above. As a consequence, $q$ and $q.des_1(\overline{p})$ overlap. But this is prevented by the pre-transformation.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_des$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract\_des$.

\end{proof}

\end{lemma*}

\begin{lemma*}

Let $prg$ and all programs $prg^i$ in the intermediate transformation steps from $prg^0$ to $prg$ don't contain lhss with overlapping prefixes, especially, this means these programs are deterministic. Then neither does $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(e, funs)}$, for arbitrary $funs$, $e = extract\_des^s$ with $s$ as $`` >1 "$ or $`` >0 "$.

\begin{proof}

Consider an atomic step of the extraction, i.e, the extraction out of a single equation. The lemma follows by combining the proofs for the atomic steps. It suffices to consider such steps which actually change the equations, i.e., they replace an equation $r$ of $prg$ with $\epsilon_r$ and $\zeta_r$. The lhss of $\epsilon_r$ and $\zeta_r$, and their prefixes, can't overlap, since they have different function names by definition. Now, consider another equation $r'$, contained in both the program before the atomic step transformation and afterwards.

First, compare $q_{r'}$ to $q_{\epsilon_r} < q_r$: Any two of their respective prefixes are also prefixes of $q_{r'}$ and $q_{\epsilon_r}$, respectively, which by assumption don't overlap.

Second, compare $q_{r'}$ to $q_{\zeta_r}$. If any of their respective prefixes overlap, $r'$ and $\zeta_r$ are in the same function definition, thus the lhs of $r'$ results from the extraction of a destructor out of some $r^*$ contained in a predecessor $prg^i$ of $prg$. This $prg^i$ also contains a lhs $q_{r^\#}$ of which $q_{r'}$ is a prefix. If a prefix of $q_{r'}$ overlaps with one of $q_{\zeta_r}$, so does a prefix of $q_{r'}$, which is also a prefix of $q_{r^\#}$, with one of $q_{r^*}$, contrary to assumption.

\end{proof}

\end{lemma*}

\subsection*{extract\_patterns:}

\begin{lemma*}

$extract\_patterns$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by Lemma ?.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with all patterns replaced by variables.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with all variables replaced by the patterns of $q_r$.

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_patterns$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle fun, \overline{des}, prg^0 \rangle^{autogen}(\overline{x}, \overline{x'})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q_r = fun(\overline{x}.\overline{des(\overline{x'})}$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract\_patterns$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract\_patterns$.

\end{proof}

\end{lemma*}

\subsection*{extract:}

\begin{lemma*}

$extract$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by Lemma ?.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with one pattern replaced by a variable and put in front of the other patterns.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with the variable in front replaced by the respective pattern of $q_r$ (that, in $q_{\epsilon_r}$, was replaced by a variable and put in front).

\end{enumerate}

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle \langle (q_r)^{-con} \rangle^{name\_pattern} \rangle^{autogen}((q_r)^{-con}_{vars^+})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q_r$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma*}

\begin{lemma*}

$extract$ satisfies the third extraction function property.

\begin{proof}

Both (a) and (b) can be easily seen in the definition of $extract$.

\end{proof}

\end{lemma*}

\subsection*{Proofs of bisimulation}

\begin{proposition*}

Let $e$ be any helper extraction function with the extraction function properties. Then let $trans$ be a transformation which doesn't affect input terms, and for programs, is defined as $extract\_helpers(e)$.

Statement (1) holds for $trans$.

\begin{proof}

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$s =^? q_r \searrow \sigma$}
\RightLabel{\scriptsize Subst with $r \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow t_r[\sigma]$}
\end{prooftree}

with $t_r[\sigma] = t$; the reduction-relevant subterms of $s$ are values. The transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

When $r$ is also an equation of $\langle prg \rangle$, it suffices to (a) by Lemma ?, reduce the reduction-relevant subterms of $s$ to equivalent values, and then (b) apply the ``Subst" rule for $r$ to get a reduction to a term equivalent to $t$.

When, otherwise, $r$ is not an equation of $\langle prg \rangle$, we have the desired sequence by the first extraction function property.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s^0 \longrightarrow t^0$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0] \longrightarrow \mathcal{E}[t^0]$}
\end{prooftree}

with $\mathcal{E}[s^0] = s$ and $\mathcal{E}[t^0] = t$. By the induction hypothesis, we have a reduction sequence $s^0 \longrightarrow_{\langle prg \rangle} \widetilde{t^0} \sim t^0$.

It suffices to (a) by Lemma ?, reduce the reduction-relevant subterms of $\mathcal{E}[s^0]$ left of $s^0$ to equivalent values, and then (b) use the ``Cong" rule, with the new context $\widetilde{\mathcal{E}}$ (around $s^0$) yielded by this, on the reduction sequence obtained from the induction hypothesis.

\end{enumerate}

\end{proof}

\end{proposition*}

\end{framed}

\end{document}
