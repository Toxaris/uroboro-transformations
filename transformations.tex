% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{fixltx2e}

\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\lstset{
frame = single
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Uroboro Transformations}
\author{Julian Jabs}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

Note: More detailed notes are available in a separate file.

\section{Preliminaries}

\begin{itemize}

\item In the following, when a function $f1$ is defined like this

$\langle prg \rangle^{f1} = ... \langle ... \rangle^{f2}$ ...

it is always assumed (without explicitly placing an argument for $prg$) that the arguments of $f2$ will include the whole program $prg$ if $f2$ needs it

\item \textbf{Helper extraction:} For a function $e$ that takes (along with the whole program $prg$, which will be omitted for brevity) an equation $eqn$ and a set $H$, that contains pairs of helper equations and signatures, and returns $\langle eqn, H \rangle^e := \big\langle eqn', H' \big\rangle$, with $eqn'$ the changed equation and $H'$ the changed helpers set, define $extract\_helpers(e)$ as follows:

\begin{alignat*}{4}
\langle prg \rangle^{extract\_helpers(e)} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ eqn' \textrm{ with } \langle eqn \rangle^{e} = \big\langle eqn', H \big\rangle ~ | ~ eqn \in eqns \} \} \\
& && && \cup && \{ \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \\
& && && &&\quad \{ heqn ~ | ~ \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && && | ~  \big\langle sig, heqn \big\rangle \in H_{eqns} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}

where
\begin{itemize}
\item $H_{eqns} = \{ \big\langle hsig, heqn \big\rangle \in H \textrm{ with } \big\langle eqn, H \big\rangle = \langle eqn \rangle^{e} ~ | ~ eqn \in eqns \}$

\item $\langle eqn \rangle^{e}$ is short for $\langle eqn, \emptyset \rangle^{e}$
\end{itemize}

\item In the following, a function definition (or its equations) is called mixed if it contains a rule where the copattern is a destructor pattern and another rule where the copattern is a hole pattern.

\item $\langle arg^*, prg \rangle^{autogen}$ simply maps $arg^*$ uniquely to a fresh (in $prg$) identifier.

\item $\langle q \rangle^{name\_pattern}$ gives a (co)pattern a unique name, unique modulo the variable names.

\item $\langle q \rangle^{vars}$ gives all variables appearing in the (co)pattern (from left to right) as a list.

\item $\langle q, \tau \rangle^{vartypes}$ gives the types of the variables appearing in the copattern (from left to right) by going recursively through the pattern's constructor and destructor calls. If the pattern $q$ is a variable itself, returns only $\tau$. This second argument is optional if unnecessary (when $q$ can't be a variable).

\item $\langle fun \rangle^{sig}, \langle con \rangle^{sig}, \langle des \rangle^{sig}$ give the signatures of the function $fun$, the constructor $con$ and the destructor $des$, respectively (as defined in the whole program that is assumed as an argument)

\item Define the extraction of the final destructor in the given copattern as follows:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars})  ", \{ \big\langle hsig, heqn \big\rangle \} \cup H \big\rangle \span\span \\
&\quad \textrm{with } hname = \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}, \span\span \\
&\quad hsig = hname(\tau_1, ..., \tau_n): \sigma \span\span \\
&\quad \textrm{ where } && fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig} \textrm{ if } q = fun(...)\\
&\quad && \tau.des(\tau_1, ..., \tau_k) : \sigma = \langle des \rangle^{sig} \textrm{ if } q = q'.des(...) \\
&\quad heqn = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) = t  " \span\span \\
& \langle `` q = t ", H \rangle^{extract\_des} = \big\langle `` q = t ", H \big\rangle, \textrm{if $q$ is hole pattern} \span\span
\end{alignat*}

\item For the examples below the following data types will be used (as if they were in a standard library):
\begin{lstlisting}

data Nat where
  zero(): Nat
  succ(Nat): Nat

data Bool where
  true(): Bool
  false(): Bool

\end{lstlisting}

\end{itemize}

\section{Defunctionalization of Uroboro}

\begin{itemize}
\item Can defunc. \texttt{eval1.uro} into something very similar to \texttt{eval3.uro}. The only difference between the result and \texttt{eval3.uro} is that the function \texttt{nil} is treated as already defunctionalized. This is because all functions with empty definitions are treated as defunctionalized.

\item Implemented in \texttt{UroboroTransformations.defunc}. (But see the comments before \texttt{UroboroTransformations.Util.namePattern} and \texttt{constructorTypes} for limitations.)

\end{itemize}

Defunctionalizing programs: $\langle prg \rangle^d = \langle \langle \langle prg \rangle^{elim\_multi\_des} \rangle^{unmix_d} \rangle^{d'}$

Eliminate multiple destructor calls: $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$

Extract outer destructor calls of a single equation (a destructor call after a destructor call) into helper functions:
\begin{alignat*}{2}
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \langle \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des} \\
&\quad \textrm{if $q$ is destructor pattern } \\
& \langle `` q.des(p_1, ..., p_k) = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q.des(p_1, ..., p_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
& \langle `` q = t ", H \rangle^{extract\_outer\_des} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_d} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Example:

\begin{lstlisting}  

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero())) = bar()
  foo(succ(succ(n))).elemAt(m) = n

function bar(): List where
  bar().elemAt(n) = zero()
  bar().isEmpty() = true()

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function foo(Nat): List where
  foo(zero()) = bar()
  foo(succ(zero)) = bar()
  foo(succ(succ(n))) = $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n)

function $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(Nat): List where
  $\langle foo(succ(succ(\_))) \rangle^{name\_pattern}$(n).elemAt(m) = n

function bar(): List where
  ...

\end{lstlisting}

Defunctionalizing programs without mixed function defs: $\langle prg \rangle^{d'} = \langle \langle prg \rangle^{disentangle_d} \rangle^{d''}$

Disentangling (extract undesired pattern matching into helper functions):

$\langle prg \rangle^{disentangle_d} = \langle prg \rangle^{extract\_helpers(extract\_patterns)}$

Extract undesired pattern matching of a single equation into a helper function:
\begin{alignat*}{3}
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} \\
&\quad = \big\langle `` fun(x_1, ..., x_n).des(x'_1, ..., x'_k) = hname(x_1, ..., x_n, x'_1, ..., x'_k) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle \\
&\quad \textrm{with } hname= \langle fun, des, prg \rangle^{autogen}, \\
&\quad hsig = hname(\tau_1, ..., \tau_n, \tau'_1, ..., \tau'_k): \tau \textrm{ where } fun(\tau_1, ..., \tau_n): \sigma = \langle fun \rangle^{sig}, \sigma.des(\tau'_1, ..., \tau'_k): \tau = \langle des \rangle^{sig} \\
&\quad heqn = `` hname(p_1, ..., p_n, p'_1, ..., p'_k) = t ", \\
&\quad \textrm{if } \exists p \in \{p_1, ..., p_n, p'_1, ..., p'_k\}: p \textrm{ is constructor application} \\
&\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \rangle^{extract\_patterns} = \big\langle `` fun(p_1, ..., p_n).des(p'_1, ..., p'_k) = t ", H \big\rangle, \\
&\quad \textrm{otherwise} \\
&\langle `` q = t ", H \rangle^{extract\_patterns} = \big\langle `` q = t ", H \big\rangle, \\
&\quad \textrm{if $q$ is hole pattern}
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(zero()).elemAt(n) = zero()
  repeat(succ(m)).elemAt(n) = succ(m)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}[mathescape]

codata List where
  ...

function repeat(Nat): List where
  repeat(x0).elemAt(x1) = $\langle repeat, elemAt \rangle^{autogen}$(x0, x1)

function $\langle repeat, elemAt \rangle^{autogen}$(Nat, Nat): Nat
  $\langle repeat, elemAt \rangle^{autogen}$(zero(), n) = zero()
  $\langle repeat, elemAt \rangle^{autogen}$(succ(m), n) = succ(m)

\end{lstlisting}

Actual defunctionalization (for programs without mixed function defs and without constructor applications in destructor patterns):
\begin{alignat*}{3}
\langle prg \rangle^{d''} & = ~&& \{ ~&& \textrm{\textbf{data }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle fun \rangle^d (\tau_1, ..., \tau_n): \sigma \\
& && && | ~ `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has destructor pattern }  \} \\
& && | && "\textrm{\textbf{codata }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle des \rangle^d (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} \\
& && && \{ \langle des \rangle^d ( \langle fun \rangle^d (x_1, ..., x_n), y_1, ..., y_k) = \langle t \rangle^d \\
& && && | ~ `` fun(x_1, ..., x_n).des(y_1, ..., y_k) = t " \in prg \} \\
& && | && `` \sigma.des(\tau_1, ... \tau_n): \tau " \in prg \} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Example:

\begin{lstlisting}

codata List where
  List.elemAt(Nat): Nat
  List.isEmpty(): Bool

function repeat(Nat): List where
  repeat(n).elemAt(m) = n
  repeat(n).isEmpty() = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = ls.elemAt(n)

\end{lstlisting}

... is transformed to:

\begin{lstlisting}

data List where
  repeat(Nat): List

function elemAt(List, Nat): Nat
  elemAt(repeat(n), m) = n

function isEmpty(List): Bool
  isEmpty(repeat(n)) = false()

function retrieve(List, Nat) where
  retrieve(ls, n) = elemAt(ls, n)

\end{lstlisting}

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\section{Refunctionalization of Uroboro}

Refunctionalizing programs: $\langle prg \rangle^r = \langle \langle prg \rangle^{unmix_r} \rangle^{r'}$

Extract destructor calls from mixed function defs into helper functions:
\begin{alignat*}{3}
\langle prg \rangle^{unmix_r} & = ~&& \langle \{ && def \in prg ~ | ~ def \textrm{ is (co)data definition or mixed function def.} \} \rangle^{extract\_helpers(extract\_all\_des)} \\
&\cup && \{ && def \in prg ~ | ~ def \textrm{ is non-mixed function def. } \}
\end{alignat*}

Here $extract\_all\_des$ is simply the iterated version of $extract\_des$:

\begin{alignat*}{2}
\langle `` q.des(...) = t ", H \rangle^{extract\_all\_des} & = \langle \langle `` q.des(...) = t ", H \rangle^{extract\_des} \rangle^{extract\_all\_des} \\
\langle `` q = t ", H \rangle^{extract\_all\_des} & = \big\langle `` q = t ", H \big\rangle, \textrm{ if $q$ is hole pattern}
\end{alignat*}

Refunctionalizing programs without mixed function defs: $\langle prg \rangle^{r'} = \langle \langle \langle prg \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

Disentangling (extract undesired pattern matching into helper functions):

$disentangle_r = extract\_helpers(extract)$

Extraction from one equation into helper functions (returns a pair of the changed original equation and the set of the helper functions):

Define the following for a copattern $q$:

\begin{itemize}
\item $q^{-con}$ means $q$ with its left-most inner-most constructor pattern occurrence replaced by a variable;
\item $q^{-con}_{vars^-}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and this pattern in front of them;
\item $q^{-con}_{vars^+}$ gives the following patterns: the variables in $q$ minus those occuring in the left-most inner-most constructor pattern, and the variable replacing this pattern in front of them;
\item $q^{-con'}$ is the same as $q^{-con}$, but ignores a left-most outer constructor pattern;
\item $q^{-con'}_{vars^-}$ and $q^{-con'}_{vars^+}$ are in the same way analogous to $q^{-con}_{vars^-}$ and $q^{-con}_{vars^+}$
\end{itemize}

\begin{alignat*}{3}
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con} = hname (q^{-con}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con}_{vars^-}) = t ", \\
&\quad && `` \tau.des_k(...): \sigma " = \langle des_k \rangle^{sig}, \\
&\quad \textrm{if } q = fun(p_1^0, ..., p_n^0).des_1(p_1^1, ..., p_{n_1}^1)...des_k(p_1^k, ..., p_{n_k}^k), k \geq 1 \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \langle `` q^{-con'} = hname (q^{-con'}_{vars^+}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \rangle^{extract} \span\span \\
&\quad \textrm{with } && hname = \langle \langle q^{-con'} \rangle^{name\_pattern} \rangle^{autogen}, \\
&\quad && hsig = `` hname(\langle q^{-con'}_{vars^+} \rangle^{vartypes}): \sigma ", \\
&\quad && heqn = `` hname(q^{-con'}_{vars^-}) = t ", \\
&\quad && `` fun(...): \sigma " = \langle fun \rangle^{sig}, \\
&\quad \textrm{if } q = fun(con(p_1^0, ..., p_k^0), p^1_1, ..., p^1_n) \textrm{ and } \exists p_i^j: p_i^j \textrm{ is constructor pattern} \span\span \\
&\langle `` q = t ", H \rangle^{extract} = \big\langle `` q = t ", H \big\rangle, \span\span \\
&\quad \textrm{otherwise} \span\span
\end{alignat*}

Splitting of the first argument in hole patterns

(as in $fun(x,...) = t \rightarrow \{fun(con_1(...),...) = t, fun(con_2(...),...) = t\}$):

\begin{alignat*}{5}
\langle prg \rangle^{split} & = ~&& \{ ~&& \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \span\span\span\span \\
& && && \bigcup && \{ && \{ fun(con(y_1, ..., y_k), x_2, ..., x_n) = t[con(y_1, ..., y_k)/x_1] \\
& && && && && | ~ `` con(\sigma_1, ..., \sigma_k): \tau_1 " \in prg; ~ y_1, ..., y_k, x_2, ..., x_n \textrm{ all distinct} \} \\
& && && && | ~ `` fun(x_1, x_2, ..., x_n) = t " \in eqns \} \span\span \\
& && && \cup \{ fun(con(...), ...) = t ~ | ~ `` fun(con(...), ...) = t " \in eqns \} \span\span\span\span \\
& && && \cup \{ q.des(...) = t ~ | ~ `` q.des(...) = t " \in eqns \} \span\span\span\span \\
& && | `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg, n > 0 \textrm{ and } \tau_1 \textrm{ is data type} \} \span\span\span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is function def. with signature } fun(\tau_1, ..., \tau_n): \sigma, \span\span\span\span \\
& && &&\quad \textrm{ with } n = 0 \textrm{ or } \tau_1 \textrm{ is codata type} \} \span\span\span\span \\
& \cup && \{ && def \in prg ~ | ~ def \textrm{ is (co)data def.} \} \span\span\span\span
\end{alignat*}

Actual refunctionalization (for programs without mixed function defs and with constructor applications only in the first data type argument of a hole pattern):
\begin{alignat*}{3}
\langle prg \rangle^{r''} & = ~&& \{ ~&& \textrm{\textbf{codata }} \sigma \textrm{\textbf{ where }} \\
& && && \{ \sigma .\langle fun, prg \rangle^r (\tau_1, ..., \tau_n): \tau \\
& && && | ~ `` fun (\sigma, \tau_1, ..., \tau_n): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } eqns \neq \emptyset \textrm{ and } \\
& && &&\quad \forall e \in eqns: e \textrm{ has no destructor pattern and } \sigma \textrm{ is data type}  \} \\
& && | && "\textrm{\textbf{data }} \sigma ..." \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} \langle con \rangle^r (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && \{ \langle con \rangle^r (x_1, ..., x_n) .\langle fun \rangle^r (y_1, ..., y_k) = \langle t, prg \rangle^r \\
& && && | ~ `` fun(con(x_1, ..., x_n), y_1, ..., y_k) = t " \in prg \} \\
& && | && `` con(\tau_1, ... \tau_n): \sigma " \in prg \} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern} \\
& && &&\quad \textrm{or where } n = 0 \textrm{ or where } \tau_1 \textrm{ is codata type} \} 
\end{alignat*}

TODO: Implement the changes to $split$ and $r''$

(see commit 862dd968ff41eaadc5196605652b04eef6e8a047)

Refunctionalizing terms: \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern or where $n = 0$ or where $\tau_1$ is codata type  \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note: the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$)

\section{Symmetries and alternative transformations}

A certain symmetry can be observed by laying the compositional sequences of the operations comprising defunctionalization and refunctionalization (preprocessing steps, then $d''$ or $r''$, respectively) next to each other:

\begin{alignat*}{4}
&\textrm{defunc.: } &&\textrm{ALL} \rightarrow  elim\_outer\_des \rightarrow && unmix_d \rightarrow disentangle_d && \rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{refunc.: } &&\textrm{ALL} \rightarrow && unmix_r \rightarrow disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

ALL stands for all of Uroboro, DEFUNC'ED and REFUNC'ED stand for the fragments of Uroboro the respective transformation results in. These two fragments can be transformed into one another as follows:

\begin{alignat*}{3}
&\textrm{REFUNC'ED} \rightarrow && elim\_outer\_des &&\rightarrow d'' \rightarrow \textrm{DEFUNC'ED} \\
&\textrm{DEFUNC'ED} \rightarrow && disentangle_r \rightarrow split && \rightarrow r'' \rightarrow \textrm{REFUNC'ED}
\end{alignat*}

Observe that, when defunctionalizing REFUNC'EDs, only the first step $elim\_outer\_des$ of the preprocessing steps above is needed. Symmetrically, the first step $unmix_r$ of the preprocessing steps can be omitted when refunctionalizing DEFUNC'EDs.

From this symmetry one can derive an alternative defunctionalization and refunctionalization by using the respective other transformation:

$\langle prg \rangle^{d_{alt}} = \langle \langle prg \rangle^r \rangle^{elim\_outer\_des} \rangle^{d''}$

$\langle prg \rangle^{r_{alt}} = \langle \langle \langle prg \rangle^d \rangle^{disentangle_r} \rangle^{split} \rangle^{r''}$

In both cases, one step of the original transformation can be saved by the above observed connection between REFUNC'ED and DEFUNC'ED. But this comes at the expense of having to run the entire refunctionalization before defunctionalizing and vice versa.

\section{Fragments for transformations}

This section identifies the relevant input fragments for the transformation steps given in section 2 and 3. Those are chosen such that the image of one step (under its relevant input fragment) is a subset of the input fragment for the next step. For each respective follow-up fragment, this can be seen directly in the definition of the previous transformation.

It can therefore be presumed that the input of a certain step comes only from its respective relevant input fragment. This will be used in the proofs of semantic preservation for the transformations steps in section 7.

Common syntax for the fragments:\\
$\sigma, \sigma_i, \tau, \tau_j = $ type names\\
$con = $ constructor names\\
$des = $ destructor names\\
$fun = $ function names\\
$x, y, x_i, y_j = $ variable names\\
$prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*$\\
$ddef ::= \textbf{data } \sigma \textbf{ where } csig^*$\\
$coddef ::= \textbf{codata } \sigma \textbf{ where } dsig^*$\\
$csig ::= con(\tau^*): \tau$
$dsig ::= \sigma.des(\tau^*): \tau$
$s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)$\\

A fragment will be defined by giving the respective EBNF rule for $fdef$, which stands for function definitions.

\subsection{Fragments for defunc.}

This subsection gives the relevant input fragments for the defunctionalization steps. The domain for the first step, $elim\_multi\_des$, is simply the set of all Uroboro programs. Thus the entire defunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Mixed fragment}

This is the input fragment for $unmix_d$. Informally, it consists of (co)data definitions and function definitions that may not contain multiple destructor calls in their copatterns but are otherwise unrestricted. 

Formal rules for function definitions:\\
$fdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*$\\
$eqn ::= q = t$\\
$q ::= fun(p^*) ~ | ~ fun(p^*).des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_d$. Informally, it consists of (co)data definitions and function definitions that may neither contain multiple destructor calls nor be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(p^*).des(p^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Actual defunc. fragment}

This is the input fragment for actual defunctionalization, i.e. $d''$. Informally, it consists of (co)data definitions and function definitions where each satisfies the following property: It either is (1) in already defunctionalized form, i.e. the left-hand sides of its rules all are hole copatterns, or (2) are in the form that the core defunctionalization from the paper of Rendel, Trieflinger, and Ostermann can be applied to, i.e. the left-hand sides of its rules all are destructor copatterns, and these copatterns do not contain any constructor pattern matching.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= fun(x^*).des(y^*) = t$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsection{Fragments for refunc.}

This subsection gives the relevant input fragments for the refunctionalization steps. The domain for the first step, $unmix_r$, is simply the set of all Uroboro programs. Thus the entire refunc. transformation is indeed applicable to any Uroboro program.

\subsubsection{Entangled fragment}

This is the input fragment for $disentangle_r$. Informally, it consists of (co)data definitions and function definitions that may not be mixed, but are otherwise unrestricted.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(p^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(p^*) = t$\\
$q ::= fun(p^*) ~ | ~ q.des(p^*)$\\
$p ::= x ~ | ~ con(p^*) $\\

\subsubsection{Unsplit fragment}

This is the input fragment for $split$. Informally, it consists of (co)data definitions and function definitions where each may not be mixed and must satisfy the following property: For every copattern $q$ that is the left-hand side of one of its rules it holds that: Either $q$ is (1) a hole pattern, then it may contain at maximum one constructor application, and this at the left-most outer-most position, or $q$ is (2) a destructor pattern, then it must not contain any constructor applications.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef$\\
$dfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } dfeqn^*$\\
$defeqn ::= dfeqn1 ~ | ~ dfeqn0$\\
$dfeqn1 ::= fun(con(x), y^*) = t$\\
$dfeqn0 ::= fun(x^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } codfeqn^*$\\
$codfeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$

\subsubsection{Actual refunc. fragment}

This is the input fragment for actual refunctionalization, i.e. $r''$. Informally, it is identical to the last fragment with the following difference: Where it said ``at maximum one constructor application" in the last section, for this fragment ``exactly one constructor application" has to hold. As such, every one of its function definitions is either (1) already in refunctionalized form, i.e. the left-hand sides of its rules contain no constructor applications and they are either all destructor patterns or the function has no arguments or its first argument has codata type, or (2) core refunctionalization (Rendel, Trieflinger, Ostermann) can be applied to it.

Formal rules for function definitions:\\
$fdef ::= dfdef ~ | ~ codfdef $\\
$dfdef ::= \textbf{function } fun(\sigma, \tau^*): \tau \textbf{ where } dfeqn^*$\\
$dfeqn ::= fun(con(x), y^*) = t$\\
$codfdef ::= \textbf{function } fun(\tau^*): \tau \textbf{ where } copeqn^* ~ | ~ nopeqn^*$\\
$copeqn ::= q.des(x^*) = t$\\
$q ::= fun(x^*) ~ | ~ q.des(x^*)$\\
$nopeqn ::= fun(x^*) = t$

\section{Values}

This section formalizes the notion of value for Uroboro. Unlike in the usual case, but not unlike other languages with copattern such as that of Abel et al., some values can be reduced. Not all reductions of values are preserved by the transformations above. 

As is the case with the language of Abel et al., whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from `Copatterns" (Abel et al.), section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

$\vdash_v t$ if $t$ has codata type (V\textsubscript{CodT})

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\section{Small-step Operational Semantics}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule).

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Con}}
\UnaryInfC{$con(t_1, ... t_j, ..., t_n) \longrightarrow con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Fun}}
\UnaryInfC{$fun(t_1, ... t_j, ..., t_n) \longrightarrow fun(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_j \longrightarrow t'_j$}
\RightLabel{$\longrightarrow$\textsubscript{Des\textsubscript{P}}}
\UnaryInfC{$t.des(t_1, ... t_j, ..., t_n) \longrightarrow t.des(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \longrightarrow t'$}
\RightLabel{$\longrightarrow$\textsubscript{Des\textsubscript{Args}}}
\UnaryInfC{$t.des(t_1, ..., t_n) \longrightarrow t'.des(t_1, ..., t_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \longrightarrow t'[\sigma]$}
\end{prooftree}

where the following holds: If $t = fun(t_1, ..., t_n)$ or $t = con(t_1, ..., t_n)$, then $\vdash_v t_i$ for $i = 1,...,n$. If $t = t_0.des(t_1, ..., t_n)$, then $\vdash_v t_i$ for $i = 0,1,...,n$.

Write $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

\section{Semantics preservation}

In this section it is shown that the transformations above preserve the semantics of programs. That is, for a transformation indicated by angular brackets, it holds for all closed input terms $s, t$ and all programs $prg$ that:

$s \longrightarrow_{prg}^* t ~ \Leftrightarrow ~ \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle $

This will be shown for each transformation by showing

$s \longrightarrow_{prg} t \Rightarrow \langle s \rangle \longrightarrow_{\langle prg \rangle}^* \langle t \rangle$ (1)

and

$\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle \Rightarrow s \longrightarrow_{prg}^* t$ (2)

It's always assumed that the program that is transformed is well-typed. It also is assumed that no term is stuck, i.e., it can either be reduced or is a value.

Note/TODO: The well-typedness of the transformed program will be shown in a separate section.

(1) is always shown in the following way:

Suppose that: $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, \\
show that: there exist derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} t_1, t_1 \longrightarrow_{\langle prg \rangle} t_2, ..., t_{n-1} \longrightarrow_{\langle prg \rangle} \langle t \rangle$, respectively

(2) is always shown analogously.

For the proofs of these properties the following lemmas will be needed:

\begin{lemma}[Inversion lemma for pattern matching]

Let $\mathcal{D}$ be a derivation of $t =^? q \searrow \sigma$.

\begin{enumerate}

\item If $q = x$ then $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\item If $q = con(p_1, ..., p_n)$ then $t = con(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = fun(p_1, ..., p_n)$ then $t = fun(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\item If $q = q'.des(p_1, ..., p_n)$ then $t = t'.des(t_1, ..., t_n)$, and $\mathcal{D}$ has this form:

\begin{prooftree}
\AxiomC{\vdots}
\UnaryInfC{$t =^? q \searrow \sigma$}
\AxiomC{\vdots}
\UnaryInfC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\end{enumerate}

\begin{proof}~

\begin{enumerate}

\item A matched pattern that is a variable doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Var}. Thus the derivation can only be the result of the application of this single rule.

\item A matched pattern that is a constructor application doesn't appear in the conclusion of a rule for pattern matching except for the rule PM\textsubscript{Con}. Thus the derivation can only be the result of the application of this rule, and of the rules leading to the premises of this rule.

\item Analogous to 2.

\item Analogous to 2.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{definition}[Pattern matching chain] A pattern matching chain from a closed term $s$ to a closed term $t$ with respect to a set $R$ of rules of the form $`` q_i = s_i "$ with $q_i$ copattern, $s_i$ term, is a series $`` q_1 = s_1 ", ..., `` q_n = s_n "$ of rules in $R$ such that:

$s =^? q_1 \searrow \sigma_1$, $s_1[\sigma_1] =^? q_2 \searrow \sigma_2$, ..., $s_{n-1}[\sigma_{n-1}] =^? q_n \searrow \sigma_n$, $s_n[\sigma_n] = t$

\end{definition}

Note that it follows directly from the definitions of pattern matching chains and pattern matching that if there is a pattern matching chain from $s$ to $t$, then $s \longrightarrow^* t$ with respect to any program containing at least the rules of the chain.

\begin{lemma} Let $e$ be a helper extraction function, i.e. a function that can be an argument of $extract\_helpers$ as defined in section 1. For any program $prg$ and any two closed terms $s,t$ with $s =^? q \searrow \sigma$, $s'[\sigma] = t$ for a rule $(q, s') \in \textrm{Rules}(prg)$ it holds that:

If $\langle (q, s') \rangle^e = \big\langle r, H \big\rangle$ such that there is a reduction sequence from $s$ to $t$ with respect to $\{ r \} \cup \{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$,

then $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.

\begin{proof}

Let the conditions be satisfied. As we can see in the definition of $extract\_helpers$, for every equation $eqn$ in the original program, the transformed program contains the equation $r$ and the equations in the set $\{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$, with $\big\langle r, H \big\rangle = \langle eqn \rangle^e$. Thus there is a reduction sequence from $s$ to $t$ with respect to the equations of the transformed program: $s \longrightarrow_{\langle prg \rangle^{extract\_helpers(e)}}^* t$.

\end{proof}

\end{lemma}

\begin{lemma}

If there is a reduction sequence from $s$ to $t$ with respect to $\{ r \} \cup \{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$ for a pair $\big\langle r, H \big\rangle$,

then there is a reduction sequence from $s$ to $t$ with respect to $\langle r, H \rangle^{extract\_des}$.

\begin{proof}

\begin{itemize}

\item \underline{Case 1}: There exists a reduction sequence from $s$ to $t$ with respect to $\{ heqn ~ | ~ \big\langle hsig, heqn \big\rangle \in H \}$.

It is $\langle r, H \rangle^{extract\_des} = \big\langle r', H' \cup H \big\rangle$ for some (possibly empty) helpers set H' and some (possibly equal to r) equation r'. Thus the equations in this result are a superset of those within $H$. Since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the reduction sequence that exists with respect to the equations within H exists also with respect to this superset.

\item \underline{Case 2}: The reduction sequence from $s$ to $t$ depends upon the equation $r$. It therefore contains at least one reduction step where the derivation contains an application of the ``Subst" rule for $r$.

Let $r := `` q' = s' "$, and the reduction sequence be:

$t_1 \longrightarrow t_2 \longrightarrow ... \longrightarrow t_{n-1} \longrightarrow t$

with $t_1 = s$, $t_n = t$.

In the case where $\langle r, H \rangle^{extract\_des} = \big\langle r, H \big\rangle$, that is, $q'$ is hole pattern, the resulting equations have not changed and thus a reduction sequence trivially exists with respect to them: It is the same sequence as given above.

Next, consider the case where $q'$ is $q.des(p_1, ..., p_k)$, and thus $\langle r, H \rangle^{extract\_des} = \big\langle `` q = hname(\langle q \rangle^{vars}) ", \{\big\langle hsig, heqn \big\rangle\} \cup H \big\rangle$, with $hname$, $hsig$, $heqn$ as in the definition of $extract\_des$. Especially it is $heqn = `` q_h = s' "$, with $q_h$ defined as $hname(\langle q \rangle^{vars}).des(p_1, ..., p_k)$. The sequence with respect to the equations in this result can be constructed as follows:

\begin{enumerate}

\item Let $I \subseteq \{1, ..., n - 1\}$ be the set of indices $j$ where $t_j \longrightarrow t_{j+1}$ contains an application of the ``Subst" rule for $r$. For all indices $k \not\in I$, $t_k \longrightarrow t_{k+1}$ is with respect to the equations within $H$.

\item Without loss of generality, let there be only one application of the ``Subst" rule for $r$ in the derivation. When there is more than one such application, simply repeat this construction until they are all dealt with. For a $j \in I$, by inversion, we know the derivation of $t_j \longrightarrow t_{j+1}$ looks as follows:

\begin{prooftree}
\AxiomC{$t'^0_j =^? q \searrow \sigma_0$}
\AxiomC{$t^{1,1}_j =^? p_1 \searrow \sigma_1$}
\AxiomC{...}
\AxiomC{$t^{1,k}_j =^? p_k \searrow \sigma_k$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\QuaternaryInfC{$t^0_j =^? q' \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q', s')$}
\UnaryInfC{$t^0_j \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}$}
\UnaryInfC{$t_j \longrightarrow t_{j+1}$}
\end{prooftree}

with $\sigma = ?, \sigma_1, ..., \sigma_k$, for some intermediate derivation $\mathcal{D'}$ and a subterm $t^0_j$ of $t_j$. By inversion, we know that $t^0_j = t'^0_j.des(t^{1,1}_j, ..., t^{1,k}_j)$.

\item In the original sequence above, for every $j \in I$, replace $t_j \longrightarrow t_{j+1}$ with the two reduction steps $t_j \longrightarrow t'_j$, $t'_j \longrightarrow t_{j+1}$, in this order, with the following derivations:

Derivation for $t_j \longrightarrow t'_j$:
\begin{prooftree}
\AxiomC{$t'^0_j =^? q \searrow \sigma_0$}
\RightLabel{\scriptsize Subst with $(q, `` hname(\langle q \rangle^{vars}) ")$}
\UnaryInfC{$t'^0_j \longrightarrow `` hname(\langle q \rangle^{vars}) "[\sigma_0]$}
\RightLabel{\scriptsize $\longrightarrow$\textsubscript{Des\textsubscript{P}}}
\UnaryInfC{$t^0_j \longrightarrow t_h$}
\UnaryInfC{$\mathcal{D'}_1$}
\UnaryInfC{$t_j \longrightarrow t'_j$}
\end{prooftree}

where $\mathcal{D'}_1$ is $\mathcal{D'}$ where all the occurrences of $s'[\sigma]$ that stem from the reduction by substitution of $t^0_j$ to it are replaced by $t_h := `` hname(\langle q \rangle^{vars}) "[\sigma'].des(t^{1,1}_j, ..., t^{1,k}_j)$. $t'_j$ is defined accordingly.

For the next derivation, remember that $q_h = `` hname(\langle q \rangle^{vars}).des(p_1, ..., p_k) "$ and $heqn = `` q_h = s'  "$. 

Derivation for $t'_j \longrightarrow t_{j+1}$:
{\setlength{\parindent}{-\leftmargin}

\AxiomC{$`` hname(\langle q \rangle^{vars}) "[\sigma_0] =^? `` hname(\langle q \rangle^{vars}) " \searrow \sigma_0$}
\AxiomC{$t^{1,1}_j =^? p_1 \searrow \sigma_1$}
\AxiomC{...}
\AxiomC{$t^{1,k}_j =^? p_k \searrow \sigma_k$}
\RightLabel{\scriptsize PM\textsubscript{Des}}
\QuaternaryInfC{$t_h =^? q_h \searrow \sigma$}
\RightLabel{\scriptsize Subst with $(q_h, s')$}
\UnaryInfC{$t_h \longrightarrow s'[\sigma]$}
\UnaryInfC{$\mathcal{D'}_2$}
\UnaryInfC{$t'_j \longrightarrow t_{j+1}$}
\DisplayProof
}

where $\mathcal{D'}_2$ is $\mathcal{D'}$ where all the occurrences of $t^0_j$ that stem from its reduction by substitution to $s'[\sigma]$ are replaced by $t_h$.

\end{enumerate}

\end{itemize}

\end{proof}

\end{lemma}

Exemplary, the proof of (1) for the transformation $split$ is given below.

\subsection{Split}

\begin{proof}[Proof of (1)] This will be done by proving the following special case of (1) by induction on the structure of $\mathcal{D}$:

If $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, there exists a derivation $\mathcal{D}_2$ for $s \longrightarrow_{\langle prg \rangle} t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_2$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$; it is $\langle s \rangle = s$ and $\langle t \rangle = t$ ($split$ doesn't change input terms).

For this, define $\mathcal{D}_2$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(\langle prg \rangle)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(\langle prg \rangle)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(\langle prg \rangle)$ as well as in Rules$(prg)$, since $split$ doesn't change rules where the copattern has this form. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(con(x_1, ..., x_k), y_1, ..., y_n)$:

The argument here is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(x_1, x_2, ..., x_n)$, where $x_1$ has codata type or $n = 0$:

The argument here is identical to that in Case 1.

\item \underline{Case 4}: $q = fun(x_1, x_2, ..., x_n)$, where $n > 0$, $x_1$ has data type:

Since $(q, s') \in \textrm{Rules}(prg)$ there exists a $(q_2, s_2') \in \textrm{Rules}(\langle prg \rangle)$ with $q_2 = fun(con(y_1, ..., y_k), x_2, ..., x_n)$ and $s'_2 = s'[con(y_1, ..., y_k) / x_1]$ for every constructor $con$ with the correct type (i.e. with return type equal to the type of the first argument of $fun$). This can also be seen directly in the definition of $split$. The concrete choice of $q_2$ depends upon the choice of $con$ -- below, $con$ will be chosen as needed.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 2}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 2}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:

\begin{prooftree}
\AxiomC{$t_1 =^? x_1 \searrow t_1 / x_1$}
\AxiomC{...}
\AxiomC{$t_n =^? x_n \searrow t_n / x_n$}
\TrinaryInfC{$fun(t_1, ..., t_n) =^? q \searrow t_1 / x_1, ..., t_n / x_n$}
\end{prooftree}

With that, we also know the form of $s$: $s = fun(t_1, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 2}$ as follows:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t_1^1 =^? y_1 \searrow t_1^1 / y_1$}
\AxiomC{...}
\AxiomC{$t_k^1 =^? y_k \searrow t_k^1 / y_k$}
\TrinaryInfC{$t_1 =^? con(y_1, ..., y_k) \searrow t_1^1 / y_1, ..., t_k^1 / y_k$}
\AxiomC{$t_2 =^? x_2 \searrow t_2 / x_2$}
\AxiomC{...}
\AxiomC{$t_n =^? x_2 \searrow t_n / x_n$}
\QuaternaryInfC{$fun(t_1, ..., t_n) =^? q_2 \searrow t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  
t_n / x_n$}
\DisplayProof
}

Remember that the choice of $con$ and, depending upon that, $q_2$, was left open until needed. This is now the place where $con$ needs to be chosen such that $t_1 = con(t^1_1, ..., t^1_k)$, with the result that the derivation $\mathcal{D}_{\textrm{PM}}$ given above is correct.

It is still open why $t_1$ can be chosen that way at all. To see this, consider the following cases: If $t_1$ is a variable, $s$ isn't a closed term, which is excluded by definition. If $t_1$ isn't a variable but also not a value, then the ``Subst" rule wouldn't even apply. The only case that remains is that $t_1$ is a value that has data type. By inversion (TODO: prove lemma of inversion for values) we know that $t_1$ is a constructor application of a constructor $con$. Since $t_1$ has the correct type, this same constructor $con$ can simply be chosen, as stated above.

In the derivation above, $\sigma_2 = t_1^1 / y_1, ..., t_k^1 / y_k,  t_2 / x_2, ...,  t_n / x_n$ and thus:

$s'_2[\sigma_2] = s'[con(y_1, ..., y_k) / x_1][\sigma_2] \\
= s'[con(t_1^1, ... t_k^1) / x_1, t_2 / x_2, ..., t_n / x_n] = s'[t_1 / x_1, t_2 / x_2, ..., t_n / x_n] = s'[\sigma] = t$

There is no conflict between the substitutions for, e.g., $x_2$ and $y_1$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

Other cases for $q$ are outside the relevant input fragment for $split$. (TODO: Define this fragment and others and prove for every transformation: that the image of this transformation is a subset of the relevant input fragment of the next transformation.) This concludes the proof for the ``Subst" case.

\item \textbf{``Constructor" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$t_j \longrightarrow t'_j$}
\UnaryInfC{$con(t_1, ..., t_j, ..., t_n) \longrightarrow con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

with $s = con(t_1, ..., t_j, ..., t_n), t = con(t_1, ..., t'_j, ..., t_n)$.

It will be shown; there exists a derivation $\mathcal{D}_2$ for $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ (again, $\langle s \rangle = s, \langle t \rangle = t$).

From the induction hypothesis it follows that, since there is a derivation $\mathcal{D'}$ (see above), there exists a derivation $\mathcal{D'}_2$ for $\langle t_j \rangle \longrightarrow_{\langle prg \rangle} \langle t'_j \rangle$ ($\langle t_j \rangle = t_j, \langle t'_j \rangle = t'_j$).

Thus we can define $\mathcal{D}_2$ as follows:

\begin{prooftree}
\AxiomC{$\mathcal{D'}_2$}
\UnaryInfC{$t_j \longrightarrow_{\langle prg \rangle} t'_j$}
\UnaryInfC{$con(t_1, ..., t_j, ..., t_n) \longrightarrow_{\langle prg \rangle} con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\item \textbf{``Function" case}:

Completely analogous to ``Constructor" case, substitute $fun$ for $con$.

\item \textbf{``Destructor arguments" case}:

Analogous to ``Constructor" case, with the arguments (to the right) of the destructor as the $t_j$.

\item \textbf{``Destructor applied expression" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$t_0 \longrightarrow t_0'$}
\UnaryInfC{$t_0.des(t_1, ..., t_n) \longrightarrow t'_0.des(t_1, ..., t_n)$}
\end{prooftree}

Proceed with $t_0$ and $t'_0$ as in the ``Constructor" case with $t_j$ and $t'_j$.

\end{enumerate}

\end{proof}

\begin{proof}[Proof of (2)] This will be done by proving the following special case of (2) by induction on the structure of $\mathcal{D}$:

If $s \longrightarrow_{prg} t$ with a derivation $\mathcal{D}$, there exists a derivation $\mathcal{D}_2$ for $s \longrightarrow_{\langle prg \rangle} t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$ ($\langle s \rangle = s, \langle t \rangle = t$); the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching.

It will be shown: there exists a derivation $\mathcal{D}_2$ for $s \longrightarrow_{prg} t$.

For this, define $\mathcal{D}_2$ as follows:

\begin{prooftree}
\AxiomC{$s =^? q_2 \searrow \sigma_2$ with $(q_2, s'_2) \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow_{prg} s'_2[\sigma_2]$}
\end{prooftree}

with the rule $(q_2, s'_2) \in \textrm{Rules}(prg)$ such that $s'_2[\sigma_2] = t$. Next, it will be shown that such a rule exists in $\textrm{Rules}(prg)$.

\begin{itemize}
\item \underline{Case 1}: $q = q'.des(x_1, ..., x_k)$:

Then there is a $(q, s')$ in Rules$(prg)$ as well as in Rules$(\langle prg \rangle)$, since the result of $split$ doesn't contain a rule where the left-hand side copattern has this form unless the input of $split$ already contains this rule. This can be seen directly in the definition of $split$.

Thus, set $q_2 := q$. It follows that $s'_2 = s', \sigma_2 = \sigma$ and finally $s'_2[\sigma_2] = s'[\sigma] = t$.

\item \underline{Case 2}: $q = fun(x_1, ..., x_n)$:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = fun(con(x_1, ..., x_k), y_2, ..., y_n)$:

Then there either exists $(q, s')$ in Rules($prg$) as well, in this case proceed as in Case 1, or there exists $q_2 := fun(y_1, y_2, ..., y_n)$, ($q_2, s'_2) \in \textrm{Rules}(prg)$, $s' = s'_2[con(x_1, ..., x_k) / y_1]$. This is because these are the only cases in which a rule with left-hand side copattern $q$ of this form is present in Rules($\langle prg \rangle$), as can be seen directly in the definition of $split$.

It is to be shown that there exists $\mathcal{D}_{\textrm{PM}, 2}$ such that:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}, 2}$}
\UnaryInfC{$s =^? q_2 \searrow \sigma_2$}
\end{prooftree}

Remember that $s'_2[\sigma_2] = t$ has to hold.

We know there exists a derivation $\mathcal{D}_{\textrm{PM}}$ for $s =^? q \searrow \sigma$.

By inversion (Lemma 1) we have the following form for $\mathcal{D}_{\textrm{PM}}$:\\

{\setlength{\parindent}{-\leftmargin}
\AxiomC{$t^1_1 =^? x_1 \searrow t^1_1 / x_1$}
\AxiomC{...}
\AxiomC{$t^1_k =^? x_k \searrow t^1_k / x_k$}
\TrinaryInfC{$con(t^1_1, ..., t^1_k) =^? con(x_1, ..., x_k) \searrow t^1_1 / x_1, ..., t^1_k / x_k$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2 ..., t_n) =^? q \searrow t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$}
\DisplayProof
}

With that, $\sigma = t^1_1 / x_1, ..., t^1_k / x_k, t_2 / y_2, ..., t_n / y_n$ and we also know the form of $s$: $s = fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n)$. Now, set $\mathcal{D}_{\textrm{PM}, 2}$ as follows:

\begin{prooftree}
\AxiomC{$con(t^1_1, ..., t^1_k) =^? y_1 \searrow con(t^1_1, ..., t^1_k) / y_1$}
\AxiomC{$t_2 =^? y_2 \searrow t_2 / y_2$}
\AxiomC{...}
\AxiomC{$t_n =^? y_n \searrow t_n / y_n$}
\QuaternaryInfC{$fun(con(t^1_1, ..., t^1_k), t_2, ..., t_n) =^? q_2 \searrow \sigma_2$}
\end{prooftree}

In the derivation above, $\sigma_2 = con(t_1^1 ..., t_k^1) / y_1,  t_2 / y_2, ...,  t_n / y_n$ and thus:

$t = s'[\sigma] = s'_2[con(x_1, ..., x_k) / y_1][\sigma] = s'_2[con(t^1_1, ..., t^1_k) / y_1, t_2 / y_2, ..., t_n / y_n] = s'_2[\sigma_2]$

There is no conflict between the substitutions for, e.g., $x_1$ and $y_2$, since all variables that are substituted are distinct, as can be seen in the definition of $split$.

\end{itemize}

This concludes the proof for the ``Subst" case.

\item \textbf{``Constructor" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$\langle t_j \rangle \longrightarrow_{\langle prg \rangle} \langle t'_j \rangle$}
\UnaryInfC{$con(t_1, ..., \langle t_j \rangle, ..., t_n) \longrightarrow con(t_1, ..., \langle t'_j \rangle, ..., t_n)$}
\end{prooftree}

with $\langle s \rangle = s = con(t_1, ..., t_j, ..., t_n), \langle t \rangle = t = con(t_1, ..., t'_j, ..., t_n)$ and $\langle t_j \rangle = t_j, \langle t'_j \rangle = t'_j$.

It will be shown; there exists a derivation $\mathcal{D}_2$ for $s \longrightarrow_{prg} t$.

From the induction hypothesis it follows that, since there is a derivation $\mathcal{D'}$ (see above), there exists a derivation $\mathcal{D'}_2$ for $t_j \longrightarrow_{prg} t'_j $.

Thus we can define $\mathcal{D}_2$ as follows:

\begin{prooftree}
\AxiomC{$\mathcal{D'}_2$}
\UnaryInfC{$t_j \longrightarrow_{prg} t'_j$}
\UnaryInfC{$con(t_1, ..., t_j, ..., t_n) \longrightarrow_{prg} con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

\item \textbf{``Function" case}:

Completely analogous to ``Constructor" case, substitute $fun$ for $con$.

\item \textbf{``Destructor arguments" case}:

Analogous to ``Constructor" case, with the arguments (to the right) of the destructor as the $t_j$.

\item \textbf{``Destructor applied expression" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$t_0 \longrightarrow_{\langle prg \rangle} t_0'$}
\UnaryInfC{$t_0.des(t_1, ..., t_n) \longrightarrow_{\langle prg \rangle} t'_0.des(t_1, ..., t_n)$}
\end{prooftree}

Proceed with $t_0$ and $t'_0$ as in the ``Constructor" case with $t_j$ and $t'_j$.

\end{enumerate}

\end{proof}

\subsection{Eliminate multiple destructors}

For step $elim\_multi\_des$.

\begin{proof}[Proof of (1)] By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation doesn't change input terms, thus $\langle s \rangle = s$, $\langle t \rangle = t$.

It will be shown: there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\langle `` q = s' " \rangle^{extract\_outer\_des}$. Using Lemma 2 for $e = extract\_outer\_des$, this gives us the desired $s \longrightarrow_{\langle prg \rangle}^* t$, since $elim\_multi\_des = extract\_helpers(extract\_outer\_des)$.

By the condition of the ``Subst" case, we have a one-step reduction sequence from $s$ to $t$ with respect to $`` q = s' "$. Therefore, and since the addition of rules preserves the existence of a reduction sequence (TODO: prove lemma for this), the existence of the reduction sequence follows from the following statement for arbitrary copatterns $q$, terms $s'$, closed terms $s,t$, and helpers sets $H$, which will be proved by induction on the structure of $q$:

If there exists a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also exists such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_outer\_des}$.

Proof by induction:

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

$\langle `` q = s' ", H \rangle^{extract\_outer\_des} = \big\langle `` q = s' ", H \big\rangle$

Thus the resulting equations are the same as the original equations, for which we already know that the desired reduction sequence exists.

\item \underline{Case 2}: $q = q'.des(p_1, ..., p_k)$, $q'$ is hole pattern:

The argument is identical to that in Case 1.

\item \underline{Case 3}: $q = q'.des(p_1, ..., p_k)$, $q'$ is destructor pattern:

$\langle `` q = s' ", H \rangle^{extract\_outer\_des} = \langle \langle `` q = s' ", H \rangle^{extract\_des} \rangle^{extract\_outer\_des}$

By Lemma 3, since there is a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q = s' ", H \big\rangle$, there also is such a reduction sequence with respect to the equations within $\langle `` q = s' ", H \rangle^{extract\_des}$. 

From the definition of $extract\_des$ we have that:

$\langle `` q = s' ", H \rangle^{extract\_des} = \langle `` q'.des(p_1, ..., p_k) = s' ", H \rangle^{extract\_des} = \big\langle `` q' = t_h ", H' \big\rangle$ for some term $t_h$ and some helpers set $H'$. 

We thus have a reduction sequence from $s$ to $t$ with respect to the equations within $\big\langle `` q' = t_h ", H' \big\rangle$. By the induction hypothesis, applied to $q'$, we have the reduction sequence with respect to $\langle `` q' = t_h ", H' \rangle^{extract\_outer\_des}$, which is the desired sequence.

\end{itemize}

This concludes the proof for the ``Subst" case.

\item \textbf{``Constructor" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$t_j \longrightarrow t'_j$}
\UnaryInfC{$con(t_1, ..., t_j, ..., t_n) \longrightarrow con(t_1, ..., t'_j, ..., t_n)$}
\end{prooftree}

with $s = con(t_1, ..., t_j, ..., t_n), t = con(t_1, ..., t'_j, ..., t_n)$.

It will be shown; there exists a reduction sequence with derivations $\mathcal{D}_1, ..., \mathcal{D}_n$ so that $\langle s \rangle \longrightarrow^*_{\langle prg \rangle} \langle t \rangle$ (again, $\langle s \rangle = s, \langle t \rangle = t$).

From the induction hypothesis it follows that, since there is a derivation $\mathcal{D'}$ (see above), there exists a reduction sequence

$t^0_j \longrightarrow_{\langle prg \rangle} t^1_j, t^1_j \longrightarrow_{\langle prg \rangle} t^2_j,  ..., t^{n-1}_j \longrightarrow_{\langle prg \rangle} t^n_j$

with derivations $\mathcal{D'}_1, ..., \mathcal{D'}_n$, where $t^0_j = \langle t_j \rangle = t_j$, $t^n_j = \langle t'_j \rangle = t'_j$.

Thus we can define the $\mathcal{D}_i$ for $i = 1,...,n$ as follows:

\begin{prooftree}
\AxiomC{$\mathcal{D'}_i$}
\UnaryInfC{$t^{i-1}_j \longrightarrow_{\langle prg \rangle} t^i_j$}
\UnaryInfC{$con(t_1, ..., t^{i-1}_j, ..., t_n) \longrightarrow_{\langle prg \rangle} con(t_1, ..., t^i_j, ..., t_n)$}
\end{prooftree}

\item \textbf{``Function" case}:

Completely analogous to ``Constructor" case, substitute $fun$ for $con$.

\item \textbf{``Destructor arguments" case}:

Analogous to ``Constructor" case, with the arguments (to the right) of the destructor as the $t_j$.

\item \textbf{``Destructor applied expression" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D'}$}
\UnaryInfC{$t_0 \longrightarrow t_0'$}
\UnaryInfC{$t_0.des(t_1, ..., t_n) \longrightarrow t'_0.des(t_1, ..., t_n)$}
\end{prooftree}

Proceed with $t_0$ and $t'_0$ as in the ``Constructor" case with $t_j$ and $t'_j$.

\end{enumerate}

\end{proof}

\end{document}
