\chapter{Introduction and preliminaries}

In this work, we develop automatic program transformations for a specific language with copattern matching, called \textit{Uroboro}. One major goal is to support automatic de- and refunctionalization for all of Uroboro. Uses for these kinds of transformations have been presented by Reynolds and Danvy, among others. Uroboro is interesting for the purpose of automatizing such transformations, because, as Rendel et al. have shown, copatterns and refunctionalization are related. We have developed and/or adapted the necessary transformation steps for de- and refunctionalization. For some of the steps, we have identified a generalization; we call such transformations \textit{extractions}. We intend the transformations of this work to be a foundation for an entire toolbox of automatic transformations for Uroboro.

In this introduction, we first give an informal overview of de- and refunctionalization (\autoref{sec:dr}). Next, we briefly describe copatterns (\autoref{sec:cp}). We then outline how Uroboro relates these two concepts and why we consider this language interesting (\autoref{sec:uro}). Finally, we sum up the contents of this thesis (\autoref{sec:soc}).

\section{De- and refunctionalization}
\label{sec:dr}

\subsection{Defunctionalization}
\label{ssec:defunc}

\textit{Defunctionalization} is a technique to transform higher-order programs into semantically equivalent first-order programs. It was first described by Reynolds, who uses it as one of several tools to compile interpreters. We illustrate defunctionalization with the following example program, presented in a Haskell-like pseudocode.

\begin{lstlisting}

filterNats :: ((Nat -> Bool), [Nat]) -> [Nat]
filterNats (f, x:xs)
  | f x = x:(filterNats (f, xs))
  | otherwise = filterNats (f, xs)
filterNats (_, []) = []

even :: Nat -> Bool
even Zero = True
even Succ(n) = not (even n)

main :: [Nat]
main = filterNats (even, [1, 2, 3, 4, 5])

\end{lstlisting}

This program is higher-order because the first argument of \texttt{filterNats} has a function type (\texttt{Nat -> Bool}). Defunctionalization does the following:
\begin{enumerate}
\item  A data type \texttt{NatBoolFun} for this function type is introduced, with a constructor \texttt{Even} for \texttt{even}.
\item A function \texttt{apply :: (NatBoolFun, Nat) -> Bool} is introduced, which has an equation for every equation in \texttt{even}. The left-hand side \texttt{even $p$}, where $p$ is some pattern, of an equation of \texttt{even} is replaced by \texttt{apply (Even, $p$)}, and the respective right-hand sides are identical (preliminarily).
\item Each call to \texttt{even} is replaced by the corresponding call to \texttt{apply}, and each occurence of \texttt{even} in an argument position is replaced by \texttt{Even}.
\item The function definition for \texttt{even} is removed.
\end{enumerate}
The result is presented below.

\begin{lstlisting}

data NatBoolFun = Even

apply :: (NatBoolFun, Nat) -> Bool
apply (Even, Zero) = True
apply (Even, Succ(n)) = not (apply (Even, n))

filterNats :: (NatBoolFun, [Nat]) -> [Nat]
filterNats (f, x:xs)
  | f x = x:(filterNats (f, xs))
  | otherwise = filterNats (f, xs)
filterNats (_, []) = []

main :: [Nat]
main = filterNats (Even, [1, 2, 3, 4, 5])

\end{lstlisting}

This transformation is easily automatized. In general, the procedure described above is applied to all occurences of function types in the program.

\subsection{Refunctionalization}

\textit{Refunctionalization} is the left inverse of defunctionalization, first described by Danvy. Its goal is to undo defunctionalization. When one knows where to find the function that serves the role of \texttt{apply} in the example above, this is easily done by just reverting the steps described above. However, in general there can be multiple functions which have the correct form for this, and could all possibly be \texttt{apply} functions. In its originally described form, refunctionalization therefore only works on programs which are the result of the defunctionalization of some other program.

However, it would be desirable to have a transformation that transforms \textit{all} first-order programs into semantically equivalent higher-order programs, like defunctionalization does it the other way around. This is where another concept comes into play: copatterns and codata.

\section{Copatterns}
\label{sec:cp}

\textit{Copatterns} are the dual to patterns, in the following sense. Where patterns allow one to distinguish between different inputs to a function, with copatterns one can observe the output. The need to observe output arises naturally when describing infinite structures. Copatterns are thus connected to \textit{codata}. Where data type definitions are used for finite structures like natural numbers, codata type definitions are used for infinite structures like streams. Consider the following example program:

\begin{lstlisting}

codata Stream = {head :: Nat, tail :: Stream}

repeat :: Nat -> Stream
head (repeat n) = n
tail (repeat n) = repeat n

\end{lstlisting}

The codata type definition for \texttt{Stream} gives the ways, called \textit{destructors}, in which a stream can be observed, or \textit{destructed}. One is fetching its head, which is a natural number, the other is fetching the tail, which again is a stream. The function \texttt{repeat} describes a stream that always returns the same number when fetching its head. For this, the left-hand sides of the definition for \texttt{repeat} use copatterns; one applies the destructor \texttt{head}, the other the destructor \texttt{tail}.

\section{Uroboro}
\label{sec:uro}

Uroboro is a functional programming language. Instead of first-class functions, Uroboro has its generalization, codata types, and copattern matching. We first show how two fragments of Uroboro relate codata and copatterns with refunctionalization (\autoref{ssec:urocdf}). Then we motivate why Uroboro is interesting -- in general, and in particular for our purpose of automatic program transformations.

\subsection{The (Co)Data Fragments}
\label{ssec:urocdf}

How do copatterns and codata relate to refunctionalization? Rendel et al. show how a program in a certain first-order language -- which they call the Data Fragment -- can be automatically transformed to a language -- which they call the Codata Fragment -- with copattern matching, and vice versa. The authors intend these two languages to be fragments of Uroboro. The key idea of Rendel et al. is that codata can be regarded as a generalization of first-class functions. This solves the problem of the multiple apply functions described above. Consider the following example program in the Data Fragment.

\begin{lstlisting}

data Nat where
  Zero(): Nat
  Succ(Nat): Nat

function add(Nat, Nat): Nat where
  add(Zero(), n) = n
  add(Succ(m), n) = Succ(add(m, n))

function multiply(Nat, Nat): Nat where
  multiply(Zero(), n) = Zero()
  multiply(Succ(m), n) = add(multiply(m, n), n)

\end{lstlisting}

Here, both \texttt{add} and \texttt{multiply} could possibly play the role of apply functions. The refunctionalization of Rendel et al. does the following:
\begin{enumerate}
\item The data type definition \texttt{Nat} is replaced by a codata type definition which has a destructor for each function whose first argument has type \texttt{Nat}.
\item For each constructor of \texttt{Nat}, a function definition is added, the equations of which correspond to the equations of all function definitions (here, both \texttt{add} and \texttt{multiply}) where the first argument of the left-hand side pattern is this constructor. Instead of a pattern with a constructor, the left-hand sides of these are now copatterns with the corresponding destructor. The right-hand sides are likewise transformed.
\end{enumerate}
The result of refunctionalization is shown below.

\begin{lstlisting}

codata Nat where
  Nat.add(Nat): Nat
  Nat.multiply(Nat): Nat

function Zero(): Nat where
  Zero().add(n) = n
  Succ(m).add(n) = Succ(m).add(n)

function Succ(Nat): Nat where
  Zero().multiply(n) = Zero()
  Succ(m).multiply(n) = m.multiply(n).add(n)

\end{lstlisting}
The Codata Fragment's syntax for destructors, \texttt{fun(s).des} is taken from Abel et al. and is syntactical sugar for the form \texttt{des(fun(s))} used above.

Rendel et al.s refunctionalization for the Data Fragment finds its reverse in their defunctionalization for the Codata Fragment. As an example, consider the result of refunctionalization of the example program above. Defunctionalizing this program leads back to the original program. Rendel et al. show that, when one views programs as two-dimensional matrices, defunctionalizing the Codata Fragment and refunctionalizing the Data Fragment can be regarded as one and the same function, namely matrix transposition.

\subsection{The full Uroboro}
\label{ssec:urofull}

Rendel et al. intend the Data Fragment and the Codata Fragment to be fragments of a common language, called Uroboro. In the following chapter, we formally define this language in full for the first time. Here, we motivate why we think Uroboro is interesting in general and for our purpose, automatic program transformations.

\subsubsection{Automatic transformations}

In our opinion, Uroboro is well suited for automatic program transformations which are related to the conversion between first-order and higher-order programs. There are two major reasons for this:
\begin{itemize}
\item Uroboro isn't ``truly'' higher-order, i.e., it has no first-class functions. Especially, this means that typing is easier, since there are no recursively built-up function types. Further, the number of arguments on left-hand sides of equations is fixed, i.e., there can be no ``underapplication''.

\item Uroboro is symmetric in the sense that it has both data type definitions and its dual codata type definition, along with patterns and its dual copatterns. This is interesting for automatic transformations, since, as described in \autoref{ssec:urocdf}, the Data Fragment and the Codata Fragment of Uroboro are connected by refunctionalization and defunctionalization.
\end{itemize}
We aren't aware of any existing languages which have both of these properties.

\subsubsection{As a possible replacement of higher-order languages}

As stated before, codata generalizes first-class functions. For this reason, Uroboro doesn't lose expressiveness when compared to languages with first-class functions but without parametric polymorphism. Thus, in our opinion, Uroboro, or rather a future version of it that includes parametric polymorphism, has the potential to replace certain higher-order languages. We give more details on this in \autoref{sec:reluro}.

\section{Summary of content}
\label{sec:soc}

In this section, we sum up the remaining contents of this work.

In the second chapter, we define the language Uroboro. We give its syntax \autoref{sec:urosyn}, static semantics \autoref{sec:urostatsem}, and finally its dynamic semantics in a small-step operational way \autoref{sec:urosos}. We also show how the reduction relation of the full Uroboro extends that of the Data and Codata Fragment.

In the third chapter, we introduce the notion of \textit{extractions}. Extractions are basic automatic program transformations that decrease the syntactic complexity of the program while preserving its reduction semantics in some way. Syntactic complexity is decreased in the left-hand sides of some of the program's equations, such that the new lhs is the result of what we call a extraction projection applied to the old lhs. An extraction projection is a function which is the inverse of either a substitution or its dual, a co-substitution. The reduction semantics are preserved in a weak bisimulation; this is achieved by introducing an auxiliary function. The precise definition of extractions is given in \autoref{sec:extrdef}. The proof of bisimulation follows in \autoref{sec:extrbis}. Under which circumstances an important property, the absence of overlaps, holds in programs that are the result of extraction, is stated and proven in \autoref{sec:extrovl}. Example extractions are given in \autoref{sec:extrex}.

In the fourth chapter, we give an automatic defunctionalization and refunctionalization for the full Uroboro. Both are made up of two phases. First, the program needs to be simplified. We describe this process, called unnesting, in \autoref{sec:unn}. After this, core defunctionalization and core refunctionalization follow, described in \autoref{sec:coredr}.

The fifth chapter considers related and future work.

The sixth and final chapter concludes.
