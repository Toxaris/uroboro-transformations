\chapter{Extraction transformations}

Most of the steps that comprise the transformations of the following chapters are \textit{extractions}. Roughly speaking, this means that they decrease, in some way, the syntactic complexity of the program, while preserving its semantics to some degree.

As an example, consider the extraction of a destructor out of the following program fragment:
\begin{lstlisting}
fun().des().des() = t
\end{lstlisting}

\begin{lstlisting}
fun().des() = aux()
aux().des() = t
\end{lstlisting}
The resulting program fragment doesn't contain any copatterns with two destructors, unlike the original, thus the transformation has decreased the syntactic complexity in this way. The transformation preserves the semantics because, roughly, in the transformed program there is a way to go from the original equation's lhs to its rhs: $\mathtt{fun().des().des()} \longrightarrow \mathtt{aux().des()} \longrightarrow \mathtt{t}$.

\section{Extractions}
\label{sec:extrdef}

Extractions are induced by a function $\pi$ that specifies how to decrease the syntactic complexity. Before defining extractions a way is described to uniformly express extractions ``from the outside in'', such as the destructor extraction exemplified above.

Changing the ``outer'' form of the copattern, i.e., removing or adding destructors, is dual to changing its ``inner'' form, i.e., replacing patterns with other patterns. For the purpose of defining extractions of the latter type, substitutions will be used. For the purpose of defining extractions of the former, the notion of \textit{co-substitution} is introduced.

\begin{definition}[Co-substitution]
A function $\sigma$ from copatterns to copatterns is called a \textit{co-substitution}, if, for every copattern $q$, it is defined as follows:
\[
\sigma(q) = q.\overline{des(\overline{p})},
\]
for some $\overline{des(\overline{p})}$ possibly depending on the $q$.
\end{definition}

Finally, extraction functions can be defined. More precisely, it is defined what it means to be an extraction projection, and for such an extraction projection $\pi$, a $\pi$-extraction targeting a copattern $q$.

\begin{definition}[Extraction projection]
A function $\pi$ from copatterns to copatterns is called an extraction projection if for every copattern $q$ there exists a (co-)substitution $\sigma^q_\pi$ such that $\sigma^q_\pi(\langle q \rangle^\pi) = q$.
\end{definition}

\begin{definition}[$\pi$-lens]
The $\pi$-lens, for an extraction projection $\pi$, is the lens defined as follows:
\[
\mathtt{get} = \pi
\]
\[
\mathtt{putback}(q^a, q^c) = \sigma^{q^c}_\pi(q^a),
\]
where the $\sigma^{q^c}_\pi$ is the (co)-substitution for $q^c$ and $\pi$ as given in the definition of the extraction projection.
\end{definition}

\begin{definition}[$\pi$-extraction target]
A $\pi$-extraction target $T$ is a set of equations such that $\pi(q) = \pi(q')$ for any two lhss $q, q'$ of equations in $T$.
\end{definition}

\begin{definition}[$\pi$-extraction targeting $T$]
A $\pi$-extraction targeting an extraction target $T$ is a triple consisting of
\begin{itemize}
\item an equation $\epsilon$ with lhs $q_\epsilon = \mathtt{get}(q)$ and rhs $t_\epsilon = \langle q_\epsilon \rangle^{aux}$, for some lhs $q$ of an equation in $T$,
\item a function $\zeta: T \to \mathbf{Eqn}, \zeta_r = ``\mathtt{putback}(t_\epsilon, q_r) = t_r  "$, and
\item a signature $sig$ for the range of $\zeta$
\end{itemize}

Here, the pair of \texttt{get} and \texttt{putback} is the $\pi$-lens. $\langle \cdot \rangle^{aux}$ is the call to the auxiliary function that corresponds to the given copattern, defined as follows for copatterns $q$:
\[
\langle q \rangle^{aux} = aux(\langle q \rangle^{vars}),
\]
where $aux$ is a fresh function name\footnote{In practice this means that is in undeclared in the program that is transformed by the extraction lifted to programs (see next section).} and $\langle q \rangle^{vars}$ denotes the list of all variables of $q$ in the order that they appear in in $q$.
\end{definition}

\subsection{Applying extractions to programs}

An extraction function was defined as a triple. As it will be used to transform programs into programs, however, it is necessary to define how it should be applied to programs. The definition of the apply function is straightforward; all it does is replace each targeted lhs in the program with $\epsilon$, leaving all other lhss unchanged, and collecting the $\zeta_r$ for each targeted equation $r$ in an auxiliary function definition.

Let $e = (\epsilon, \zeta, sig)$ be an extraction targeting $T$, with
\[
def_T = `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns "
\]
the function definition that contains the lhss of $T$.

\begin{alignat*}{4}
\langle prg \rangle^{apply(e)} & = &&\{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ r ~ | ~ r \in eqns, r \not\in T \} \cup \{ \epsilon \}, \\
& && && \textrm{\textbf{function }} sig \textrm{\textbf{ where }} \{ \zeta_r ~ | ~ r \in T \} \} \\
& \cup && \{ def \in prg ~ | ~ def \neq def_T \} \span\span\span\span
\end{alignat*}

\section{Bisimulation}
\label{sec:extrbis}

Every $\pi$-extraction function targeting a $q$ preserves the semantics of programs in a kind of weak bisimulation. There are two equivalent characterizations of this bisimulation. One is given and proved in the first subsection, the other follows in the second subsection and is shown to be equivalent to the first.

Before that, a function $\langle \cdot \rangle^{aux^{-1}}$ from terms to terms needs to be defined that serves as the opposite of $\langle \cdot \rangle^{aux}$. It is defined as replacing calls to the auxiliary function as generated by $\langle \cdot \rangle^{aux}$ with the original copatterns with their variables instantiated accordingly. This corresponds to what Setzer et al. call a \textit{back-interpretation} in the framework of their paper ``Unnesting of copatterns''; this term will be used here as well when referring to $\langle \cdot \rangle^{aux^{-1}}$.

\subsection{Using a modified value judgement}

For the definition of this weak bisimulation, a modification, using the back-interpretation, of the value judgement needs to be defined. For any term $t$ with names declared in $\langle prg \rangle$, let
\[
\langle prg \rangle \vdash'_v t :\iff prg \vdash_v \langle t \rangle^{aux^{-1}}.
\]

From this it immediately follows that $\mathcal{E}$ is an evaluation context with respect to this modified value judgement for $\langle prg \rangle$ if and only if $\langle \mathcal{E} \rangle^{aux^{-1}}$ is an evaluation context with respect to the original value judgement for $prg$. It also means that, for a term $t$ with all names declared in $\langle prg \rangle$, the immediate subterms of $t$ are values with this judgement for $\langle prg \rangle$ if and only if the immediate subterms of $\langle t \rangle^{aux^{-1}}$ are values with the original judgement for $prg$.

Write $\longrightarrow'$ for the reduction relation $\longrightarrow$ with its value judgement modified in this way. The weak bisimulation is defined as follows, for every $s,t$ with all of their names declared in $prg$:
\begin{equation}
s \longrightarrow_{prg}^* t \iff s {\longrightarrow'}_{\langle prg \rangle}^* t
\end{equation}
This statement is now proved using Theorem 4 of ``Unnesting of copatterns'' (Setzer et al.).

\begin{proposition}
\label{prop:bisim1}
The weak bisimulation statement (2.1) holds for any transformation defined as $liftp(e)$ for some $\pi$-extraction targeting a $q$.

\begin{proof}
By Theorem 4 of ``Unnesting of copatterns'' (Setzer et al.), it suffices to show the statements (SN1) and (SN2), defined there along with the theorem. For this, set $\textrm{Int} = \langle \cdot \rangle^{aux^{-1}}$. Note that this unconversion is compatible with evaluation contexts, i.e.,
\[
\langle \mathcal{E}[s'] \rangle^{aux^{-1}} = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle s' \rangle^{aux^{-1}}],
\]
because $\langle \cdot \rangle^{aux}$ converts to function calls, not destructor calls.
Further, set $m$ as the number of calls to the function targeted in the transformation, i.e., that of $q_\epsilon$.

(SN1): We know that $s = \mathcal{E}[s'] = \mathcal{E}[q_r[\sigma]] \longrightarrow_{prg} \mathcal{E}[t_r[\sigma]] = t$, for some evaluation context $\mathcal{E}$ of $prg$ and some equation $r$ of $prg$.
\[
s = \mathcal{E}[s'] = \mathcal{E}[\sigma^{q_r}_\pi(q_\epsilon)[\sigma]]
\]
\[
\longrightarrow'_{\langle prg \rangle} \mathcal{E}[\sigma^{q_r}_\pi(t_\epsilon)[\sigma]] = \mathcal{E}[q_{\zeta_r}[\sigma]]
\]
\[
\longrightarrow'_{\langle prg \rangle} \mathcal{E}[t_{\zeta_r}[\sigma]] = \mathcal{E}[t_r[\sigma]] = t
\]

(SN2): Three cases will be distinguished: The reduction in $\langle prg \rangle$ can use either an equation taken over unchanged from $prg$ (1.), it can use a $\zeta_r$ (2.), or it can use $\epsilon$. Each case makes use of an evaluation context $\mathcal{E}$ of the reduction relation for $\langle prg \rangle$.
\begin{enumerate}
\item We know $s = \mathcal{E}[s'] = \mathcal{E}[q_r[\sigma]] \longrightarrow'_{\langle prg \rangle} \mathcal{E}[t_r[\sigma]] = t$. The desired reduction sequence can be given as follows:
\[
\langle \mathcal{E}[s'] \rangle^{aux^{-1}} = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle s' \rangle^{aux^{-1}}] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle q_r \rangle^{aux^{-1}}[\langle \sigma \rangle^{aux^{-1}}]]
\]
\[
 \longrightarrow_{prg} \langle \mathcal{E} \rangle^{aux^{-1}}[t_r[\langle t_r \rangle^{aux^{-1}}]] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle t_r \rangle^{aux^{-1}}[\langle \sigma \rangle^{aux^{-1}}]] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle t_r[\sigma] \rangle^{aux^{-1}}]
\]
\[
= \langle \mathcal{E}[t_r[\sigma]] \rangle^{aux^{-1}} = \langle t \rangle^{aux^{-1}}.
\]

\item We know $s = \mathcal{E}[s'] = \mathcal{E}[q_{\zeta_r}[\sigma]] \longrightarrow'_{\langle prg \rangle} \mathcal{E}[t_{\zeta_r}[\sigma]] = t$. The desired reduction sequence can be given as follows:
\[
\langle \mathcal{E}[s'] \rangle^{aux^{-1}} = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle s' \rangle^{aux^{-1}}] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle q_{\zeta_r} \rangle^{aux^{-1}}[\langle \sigma \rangle^{aux^{-1}}]] = \langle \mathcal{E} \rangle^{aux^{-1}}[q_r[\langle \sigma \rangle^{aux^{-1}}]]
\]
\[
\longrightarrow_{prg} \langle \mathcal{E} \rangle^{aux^{-1}}[t_r[\langle t_r \rangle^{aux^{-1}}]] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle t_r \rangle^{aux^{-1}}[\langle \sigma \rangle^{aux^{-1}}]] = \langle \mathcal{E} \rangle^{aux^{-1}}[\langle t_r[\sigma] \rangle^{aux^{-1}}]
\]
\[
= \langle \mathcal{E}[t_r[\sigma]] \rangle^{aux^{-1}} = \langle t \rangle^{aux^{-1}}.
\]

\item We know $s = \mathcal{E}[s'] = \mathcal{E}[q_\epsilon[\sigma]] \longrightarrow'_{\langle prg \rangle} \mathcal{E}[t_\epsilon[\sigma]] = t$. In this case, instead of giving a reduction sequence, the other side of the disjunction will be shown to hold.

Because $\langle q_\epsilon \rangle^{aux^{-1}} = \langle t_\epsilon \rangle^{aux^{-1}}$, it is $\langle s \rangle^{aux^{-1}} = \langle t \rangle^{aux^{-1}}$.

And because $q_\epsilon$ is of the function that is targeted in the transformation, and $t_\epsilon$ isn't, it is $m(q_\epsilon) > m(t_\epsilon)$, and consequently $m(s) > m(t)$.
\end{enumerate}
\end{proof}
\end{proposition}

\subsection{Using the back-interpretation directly}

This characterization of the bisimulation, equivalent to the first, directly uses the back-interpretation. In short, extractions preserve semantic properties by introducing an equation which leads from a, syntactically, more complex to a less complex term, where both terms are meant to represent, semantically, the same ``object''. This ``sameness'' is expressed by one being the back-interpretation of the other.

The bisimulation is characterized as follows:
\[
s {\longrightarrow}_{prg}^* t \iff s \longrightarrow^*_{\langle prg \rangle} \widetilde{t}, \text{ with } \langle \widetilde{t} \rangle^{aux^{-1}} = t
\]
In order to prove it, it suffices to show that this characterization is equivalent to the first characterization:
\begin{equation}
s {\longrightarrow'}_{\langle prg \rangle}^* t \iff s \longrightarrow^*_{\langle prg \rangle} \widetilde{t},
\end{equation}
for every $s, t$ with names declared in $prg$.

First, we show that the $`` \Rightarrow "$ direction of (2.2), as expressed in the following lemma, holds. In the following, all reductions are meant with respect to program $\langle prg \rangle$.

\begin{lemma}[$`` \Rightarrow "$ direction of (2.2)]
\label{lem:prop2lr}
\[
s {\longrightarrow'}_{\langle prg \rangle}^* t \implies s \longrightarrow^*_{\langle prg \rangle} \widetilde{t}
\]
\end{lemma}

In order to prove this, we define a counterpart to the $\longrightarrow'$ reduction relation: Let
\[
\longrightarrow^{aux} = \{(a,b) : a \longrightarrow^{all} b \land \langle a \rangle^{aux^{-1}} = \langle b \rangle^{aux^{-1}}\},
\]
where $\longrightarrow^{all}$ is the reduction relation for $\langle prg \rangle$ whose underlying value set is the set of all terms, i.e., the reduction is allowed to choose any redex. Where $\longrightarrow'$ can ``sidestep'' reductions which don't change the back-interpretation of a term, $\longrightarrow^{aux}$ is purely ``interpretative'', that is, it only allows reductions to terms with equal back-interpretation. This is expressed formally in the following lemmas relating $\longrightarrow'$ and $\longrightarrow^{aux}$, one concerning their commutation, the other what we call their complementarity. The $`` \Rightarrow "$ direction of (2.2) follows from these, as shown below.

\begin{restatable}[Commuting-diamond property]{lemma}{cdpaux}
\label{lem:cdpaux}

For all terms $a,b,c$ it holds that:
\[
a {\longrightarrow'} b \land a \longrightarrow^{aux} c \implies \exists d . b {\longrightarrow^{aux}}^* d \land c {\longrightarrow'}^= d
\]

\end{restatable}
\begin{proof}
Left for the appendix.
\end{proof}

\begin{corollary}
\label{cor:cdpauxcor}

For all terms $a,b,c$ and $n \in \mathbb{N}$ it holds that:
\[
a {\longrightarrow'}^n b \land a {\longrightarrow^{aux}}^* c \implies \exists d . b {\longrightarrow^{aux}}^* d \land c {\longrightarrow'}^{\leq n} d
\]

\begin{proof}

By induction on $n$ and on the length of $a {\longrightarrow^{aux}}^* c$.

\end{proof}

\end{corollary}

\begin{restatable}[Complementarity]{lemma}{compl}
\label{lem:compl}

For all terms $a,b$ it holds that:

When $a \longrightarrow' b$ but $a \not\longrightarrow b$, then there is a $c$ with $a \longrightarrow c$ and $a \longrightarrow^{aux} c$.

\end{restatable}

\begin{proof}
Left for the appendix.
\end{proof}

\begin{proof}[Proof of \autoref{lem:cdpaux}]

By induction on the length $n$ of $s {\longrightarrow'}_{\langle prg \rangle}^* t$. For $n = 0$ it is $s = t$, thus simply choose $\widetilde{t} = t$. Now, consider the case that $n = n'+1$ for some $n' \geq 0$. We proceed by induction on the number $k$ of calls in $s$ to the function targeted in the transformation, i.e., that of $q_\epsilon$.

\begin{itemize}
\item $k = 0$. Consider the first step $s {\longrightarrow'}_{\langle prg \rangle} s_1$ of $s {\longrightarrow'}_{\langle prg \rangle}^* t$. Because there are no calls to the function of $q_\epsilon$ in $s$, for all subterms $s^0$ of $s$ it is $\vdash'_v s^0$ iff $\vdash_v s^0$. Consequently, the reduction step from $s$ to $s_1$ is also possible with reduction relation $\longrightarrow_{\langle prg \rangle}$, that is, $s \longrightarrow_{\langle prg \rangle} s_1$. By the outer induction hypothesis, we have the rest of the desired reduction sequence $s_1 \longrightarrow_{\langle prg \rangle} \widetilde{t}$.

\item $k = k' + 1$. Again, consider the first step $s {\longrightarrow'}_{\langle prg \rangle} s_1$ of the original sequence. We distinguish two cases.
\begin{enumerate}
\item $s \longrightarrow_{\langle prg \rangle} s_1$. With this, we have the first step of the desired reduction sequence. By the outer induction hypothesis, we have the rest of the desired reduction sequence $s_1 \longrightarrow_{\langle prg \rangle} \widetilde{t}$.

\item $s \not\longrightarrow_{\langle prg \rangle} s_1$. By \autoref{lem:compl}, we have an $s_{aux}$ with $s \longrightarrow^{aux} s_{aux}$ and $s \longrightarrow_{\langle prg \rangle} s_{aux}$. By \autoref{cor:cdpauxcor}, we have a $\widetilde{t}'$ with (a) $s_{aux} \longrightarrow^{\leq n} \widetilde{t}'$ and (b) $t {\longrightarrow^{aux}}^* \widetilde{t}'$ and thus $\langle \widetilde{t}' \rangle^{aux^{-1}} = t$. Apply the inner induction hypothesis to $s_{aux} \longrightarrow^{\leq n} \widetilde{t}'$ to obtain the desired sequence.
\end{enumerate}
\end{itemize}

\end{proof}

%%-- under construction
Now, we show the $`` \Leftarrow ''$ direction of (3.2).

\begin{lemma}[$`` \Leftarrow "$ direction of (3.2)]
\label{lem:prop2rl}
\[
s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \implies s {\longrightarrow'}_{\langle prg \rangle}^* t
\]
\end{lemma}

Again, we begin by showing a commutation lemma; but this time, we operate on the inverse relations of $\longrightarrow'$ and $\longrightarrow^{aux}$.

\begin{restatable}[Commutation (inverses)]{lemma}{comminv}
\label{lem:comminv}

For all terms $b,c,d$ it holds that:
\[
c {\longrightarrow'} d \land b \longrightarrow^{aux} d \implies \exists a . a {\longrightarrow^{aux}}^* c \land a {\longrightarrow'}^= b
\]

\end{restatable}
\begin{proof}
Left for the appendix.
\end{proof}

\begin{corollary}
\label{cor:comminvcor}

For all terms $b,c,d$ and $n \in \mathbb{N}$ it holds that:
\[
c \longrightarrow' d \land b {\longrightarrow^{aux}}^* d \implies \exists a . a {\longrightarrow^{aux}}^* c \land a {\longrightarrow'}^= b
\]

\begin{proof}

By induction on the length of $b {\longrightarrow^{aux}}^* d$.

\end{proof}
\end{corollary}

\begin{proof}[Proof of \autoref{lem:prop2rl}]

First, note that this direction is logically equivalent to the statement
\[
\forall s, t \in \textrm{Term}_{prg}, \widetilde{t} \in \textrm{Term}_{\langle prg \rangle}. (s \longrightarrow^* \widetilde{t} \land \langle \widetilde{t} \rangle^{aux^{-1}} = t) \implies s {\longrightarrow'}^* t.
\]
We prove this statement by induction on the length $n$ of $s \longrightarrow^* \widetilde{t}$. For $n = 0$ it is $s = \widetilde{t}$; since $s \in \textrm{Term}_{prg}$ it is $\langle s \rangle^{aux^{-1}} = s$ and it follows that $s = \langle \widetilde{t} \rangle^{aux^{-1}} = t$. 

Now, consider the case that $n = n'+1$ for some $n' \geq 0$. Since $\longrightarrow \subseteq \longrightarrow'$ it is $s_1 \longrightarrow' \widetilde{t}$; and since $t = \langle \widetilde{t} \rangle^{aux^{-1}}$ it is $t {\longrightarrow^{aux}}^* \widetilde{t}$. Thus, by \autoref{cor:comminvcor} we have a $t'$ with $t' {\longrightarrow'}^= t$ and $t' {\longrightarrow^{aux}}^* s_1$. By the induction hypothesis we have a reduction sequence $s {\longrightarrow'}^* \langle s_1 \rangle^{aux^{-1}}$. Since it is $t' {\longrightarrow'}^= t$, and $t$ contains no calls to $aux$, neither does $t'$. Thus, from $t' {\longrightarrow^{aux}}^* s_1$ it follows that $\langle s_1 \rangle^{aux^{-1}} = t'$. By combining the thus known sequences and equalities, we get the desired sequence $s {\longrightarrow'}^* \langle s_1 \rangle^{aux^{-1}} = t' {\longrightarrow'}^= t$.

\end{proof}

%%--

\begin{lemma}[lem:hh2prop2rl]

\end{lemma}

\begin{lemma}
\label{lem:hprop2rl}
When $s \longrightarrow' t$ and $s \not\longrightarrow^{aux} t$, then $\langle s \rangle^{aux^{-1}} {\longrightarrow'}^* \langle t \rangle^{aux^{-1}}$.
\begin{proof}
From the derivation of $s \longrightarrow' t$, we know that $s = \mathcal{E}'[s_0], t = \mathcal{E}'[t_0], s_0 \mapsto' t_0$ for terms $s_0, t_0$ and an evaluation context $\mathcal{E}' \in \mathbf{EC}[\vdash'_v]$. Because, by definition, it is $\vdash'_v v$ iff $\vdash'_v \langle v \rangle^{aux^{-1}}$ for all terms $v$, using the definition of evaluation contexts it easily follows that $\langle \mathcal{E}' \rangle^{aux^{-1}} \in \mathbf{EC}[\vdash'_v]$. Since $s_0 \mapsto' t_0$, by \autoref{lem:hh2prop2rl} we have $\langle s_0 \rangle^{aux^{-1}} {\mapsto'}^* \langle t_0 \rangle^{aux^{-1}}$. Consequently, since evaluation contexts are compatible with $\langle \cdot \rangle^{aux^{-1}}$ we have $\langle s \rangle^{aux{-1}} = \langle \mathcal{E}' \rangle^{aux^{-1}}[\langle s_0 \rangle^{aux^{-1}}] {\longrightarrow'}^* \langle \mathcal{E}' \rangle^{aux^{-1}}[\langle t_0 \rangle^{aux^{-1}}] = \langle t \rangle^{aux^{-1}}$.
\end{proof}
\end{lemma}

\begin{lemma}[Right-to-left direction of (3.2)]
\label{lem:prop2rl}
\[
 s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \implies s {\longrightarrow'}_{\langle prg \rangle}^* t
\]

\begin{proof}
First, note that this direction is logically equivalent to the statement
\[
\forall s, t \in \textrm{Term}_{prg}, \widetilde{t} \in \textrm{Term}_{\langle prg \rangle}. (s \longrightarrow^* \widetilde{t} \land \langle \widetilde{t} \rangle^{aux^{-1}} = t) \implies s {\longrightarrow'}^* t.
\]
We prove this statement by induction on the length $n$ of $s \longrightarrow^* \widetilde{t}$.

If $n = 0$, it is $s = \widetilde{t} \in \textrm{Term}_{prg}$, therefore it must be $\widetilde{t} = t$, and thus it is $s = t$.

Otherwise, consider the final step of the sequence, $s' \longrightarrow \widetilde{t}$. By the induction hypothesis, we have a sequence $s {\longrightarrow'}^* \langle s' \rangle^{aux^{-1}}$. We distinguish two cases for the final step of the original sequence. 
\begin{itemize}
\item $s' \not\longrightarrow^{aux} \widetilde{t}$. Because $\longrightarrow \subseteq \longrightarrow'$, we know that $s' \longrightarrow' \widetilde{t}$. By \autoref{lem:hprop2rl} it follows that $\langle s' \rangle^{aux^{-1}} \longrightarrow' \langle \widetilde{t} \rangle^{aux^{-1}}$.

\item $s' \longrightarrow^{aux} \widetilde{t}$. Then it is $\langle s' \rangle^{aux^{-1}} = \langle \widetilde{t} \rangle^{aux^{-1}} = t$.
\end{itemize}
\end{proof}
\end{lemma}

Combining \autoref{lem:prop2lr} and \autoref{lem:prop2rl}, statement (2.2) obtains.
\begin{proposition}
\label{prop:bisim2}
Statement (2.2), that is
\[
s {\longrightarrow'}_{\langle prg \rangle}^* t \iff s \longrightarrow^*_{\langle prg \rangle} \widetilde{t},
\]
for every $s, t$ with names declared in $prg$, holds.
\end{proposition}

\section{Absence of overlaps}
\label{sec:extrovl}

Since, in the context of this work, it is always presupposed that a program to be transformed has no overlapping copatterns, a desirable property of the transformed program is that it doesn't have overlapping copatterns, as well. This is now shown to be the case whenever $q_\epsilon$ doesn't overlap with any lhs of an equation taken over unchanged from $prg$.

\begin{proposition}
For any well-behaved extraction function lifted to programs, $\langle \cdot \rangle$, it is the case that if $prg$ has no overlapping copatterns and $q_\epsilon$ doesn't overlap with any lhs of an equation taken over unchanged from $prg$, then $\langle prg \rangle$ has no overlapping copatterns, as well.

\begin{proof}
First, the equations of the transformed are classified. There are three kinds of them: Those taken over unchanged over from $prg$ (indicated as $r$ in the table below), those which are an $\epsilon$ in a transformation result ($\epsilon$), and those which are, also in such a transformation result, a $\zeta_r$ ($\zeta$). The table below shows all possible combinations; its fields are filled with the number of the proof that lhss of equations of the respective kinds don't overlap.

\begin{tabular}{ l | c | c | r }  & r & $\epsilon$ & $\zeta$ \\ \hline r & (1) &  &  \\ \hline $\epsilon$ & (2) & (3) &  \\ \hline $\zeta$ & (4) & (5) & (6) \\ \hline \end{tabular}

\textit{ad} (1): Both equations are present in $prg$, thus their lhss don't overlap.

\textit{ad} (2): By assumption.

\textit{ad} (3): By the definition of the $q$-extraction, there is only one $\epsilon$-equation in the transformed program.

\textit{ad} (4): The $\zeta$-equation has a function name not declared in $prg$, unlike the $r$-equation.

\textit{ad} (5): The $\zeta$-equation has a function name not declared in $prg$, unlike the $\epsilon$-equation.

\textit{ad} (6): The lhss of each of the $\zeta$-equations are equivalent to a lhs in $prg$, thus, if they overlapped, so would these lhss in $prg$, contrary to fact.
\end{proof}
\end{proposition}

\section{Example extractions}
\label{sec:extrex}

The two following extractions will be used in the next chapter.

\subsection{Destructor extraction}

The extraction $des\_extract(q)$ of a single destructor targeting some copattern $q$ can be defined as follows: It is the $\pi$-extraction (targeting some $T$) for the extraction projection $\pi$ defined below.

\[
\pi(`` fun(\overline{p}) ") = `` fun(\overline{p}) "
\]
\[
\pi(`` q.des(\overline{p}) ") = `` q "
\]

Since copatterns without destructors aren't affected, this extraction is only meant to be used for copatterns with at least one destructor. We now show that $\pi$ is an extraction projection, by giving a cosubstitution $\sigma^q_\pi$ for each $q$ such that $\sigma^q_\pi(\pi(q)) = q$: Set
\[
\sigma^q_\pi(q') = \begin{cases}
                              q'.des(\overline{p}) &,\text{ if } q = q''.des(\overline{p}) \\
                              q' &,\text{ otherwise}
                              \end{cases}
\]

\subsection{Constructor extraction}

We define a family $\textsf{ExtractCon}(p)$ of extractions of single constructors. The parameter $p$ stands for the position of the constructor call to be extracted in the targeted copatterns. For such a position $p$, $\textsf{ExtractCon}(p)$ is defined as the $\pi$-extraction (targeting some $T$) for the extraction projection $\pi$ defined below.

For a copattern $q$, let $x_q$ be a variable different from all in $q$.
\[
\pi(q) = \begin{cases}
             q[con(\overline{p}) \mapsto x_q]_p &\text{ if } q \text{ has a constructor call at position } p \\
             q &\text{ otherwise}
             \end{cases}
\]

We now show why $\pi$ is an extraction projection, that is, we give, for each $q$, a substitution $\sigma^q_\pi$ such that $\sigma^q_\pi(\pi(q)) = q$: Set $\sigma^q_\pi := \{x_q \mapsto \overline{p}\}$.

\subsection{Extracting all patterns out of a single-destructor copattern}

This extraction extracts all patterns, that is, all constructor calls, out of a copattern with only a single destructor. Define this extraction $extract\_patterns$ as the $\pi$-extraction targeting $q$ with the extraction projection $\pi$ defined below.

\[
\pi(`` fun(\overline{p}).des(\overline{p'}) ") = `` fun(\overline{x}, \overline{x'}) "
\]