\chapter{Automatic de- and refunctionalization}

\section{Common pretransformations}

...

\subsection{From order-dependent to order-independent}

...

\subsection{Aligning patterns}

This step is necessary for destructor extraction to work correctly.

The purpose of $align\_patterns$ is to bring the patterns inside the copatterns within one function definition to the same level of specification. Consider the following example:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(x).d2() = t_3

\end{lstlisting}

Here, the third equation's left-hand side has a catch-all pattern (variable) in its first destructor call $d1$. The first destructor in the first and second equations' left-hand sides is also $d1$, but the patterns there are the constructors $c1()$ and $c2()$, respectively; they have a higher level of specification than the catch-all pattern. For destructor extraction to work correctly, the catch-all pattern therefore must be split. Such splitting steps are what $align\_patterns$ is doing. The result of $align\_patterns$ applied to the above function definition is:

\begin{lstlisting}

fun().d1(c1()).d1() = t_1
fun().d1(c2()).d1() = t_2
fun().d1(c1()).d2() = t_3
fun().d1(c2()).d2() = t_3

\end{lstlisting}

For programs, $align\_patterns$ is defined as follows.
\begin{alignat*}{4}
\langle prg \rangle^{align\_patterns} & = &&\bigcup &&\{ ~&&\{ \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \\
& && && &&\quad \{ `` q' = t " ~ | ~ q' \in Q_q, `` q = t " \in eqns \} \} \\
& && && | && `` fun (\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \} \\
& \cup && \{ def ~ | ~ def \in prg, def \textrm{ is (co)data def. } \} \span\span\span\span
\end{alignat*}
with
\begin{equation*}
Q_{fun(p_1, ..., p_n)} = \{fun(p_1, ..., p_n)\}
\end{equation*}
and
\begin{equation*}
Q_{q^0.des(p_1, ..., p_k)} = \langle \underline{q^0} \rangle^{align_patterns}.des(p_1, ..., p_k)
\end{equation*}
with
\begin{equation*}
\underline{fun(p_1, ..., p_n)} = fun(\_, ..., \_)
\end{equation*}
and
\begin{equation*}
\underline{q^0.des(p_1, ..., p_k)} = \underline{q^0}.des(\_, ..., \_)
\end{equation*}
Here, the $\_$ represent holes which are used to describe generic forms of copatterns. For instance, one generic form of $fun(p_1, ..., p_n).des(p_1, ..., p_k)$ is $fun(\_, ..., \_).des(\_, ..., \_)$. The generic forms for a given copattern can be simply defined inductively, starting with setting $\_$ as being a generic form for any pattern.

For generic forms of copatterns, $align\_patterns$ is defined as follows. Let $q_\_ = fun(\_, ..., \_).des_1(\_, ..., \_)...des_k(\_, ..., \_)$, and $q^i_\_$ be the context that obtains by replacing the $i$-th hole in $q_\_$ with another kind of hole $[]$ used for plugging other contexts into it.
\begin{multline*}
\langle q_\_ \rangle^{align\_patterns} = \\
fun(\langle q^1_\_ \rangle^{a\_p}, ..., \langle q^{n_0}_\_ \rangle^{a\_p}).des_1(\langle q^{n_0 + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_1}_\_ \rangle^{a\_p})...des_k(\langle q^{n_{k-1} + 1}_\_ \rangle^{a\_p}, ..., \langle q^{n_k}_\_ \rangle^{a\_p})
\end{multline*}

Finally, $a\_p$ for such contexts is defined as follows.

\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \bigcup_{con} \{con(t_1, ..., t_n) ~ | ~ t_i \in \langle \mathcal{C}[con(\_, ..., \_, [], \_, ..., \_)] \rangle^{a\_p} \},
\end{equation*}
if $\exists$ lhs in $def$ with a prefix of the generic form $\mathcal{C}[con(\_, ..., \_)]$,
\begin{equation*}
\langle \mathcal{C} \rangle^{a\_p} = \{x\},
\end{equation*}
otherwise.

\section{Transformation steps}

Both de- and refunctionalization are made up of a couple of preprocessing steps, followed by the core de-/refunctionalization, which is essentially the two-way transformation from the paper of Rendel et al.

Automatic defunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors. ($elim\_multi\_des_d$)

\item Unmix function definitions. ($unmix$)

\item Eliminate constructors from destructor copatterns. ($elim\_cons\_from\_des$)

\item Core defunctionalization. ($d_{core}$)

\end{enumerate}

Automatic refunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors from copatterns containing constructors. ($elim\_multi\_des_r$)

\item Unmix function definitions. ($unmix$)

\item Eliminate constructors from destructor copatterns. ($elim\_cons\_from\_des$)

\item Eliminate multiple constructors. ($elim\_multi\_con$)

\item Core refunctionalization. ($r_{core}$)

\end{enumerate}

Each preprocessing steps can be defined as a recursive composition of one of the basic building blocks described in the next section. One such building block is an extraction function lifted to programs with $extract\_helpers$. The definitions for each step follow below; for them, the following conditional recursion combinator will be used:
\[
    condrec(f, cond) :=
\begin{cases}
    condrec(f, cond) \circ f,& \text{if $cond$ holds} \\
   id,& \text{otherwise}
\end{cases}
\]

\begin{framed}

\begin{alignat*}{1}
&elim\_multi\_des_i = condrec(extract\_helpers(extract\_des^{\geq 1}), cond_i), \textrm{ for } i \in \{d, r\}, \textrm{ with } \\
&\qquad cond_d = \textrm{``the program contains multiple destructors''} \\
&\qquad cond_r = \textrm{``the program contains a multiple destructor copattern with constructors''} \\
&unmix = condrec(extract\_helpers(extract\_des, funs), cond), \textrm{ with}\\
&\qquad cond = \textrm{``the program has mixed function def.s'' and} \\
&\qquad funs = \{ fun \in prg ~ | ~ \textrm{the def. of $fun$ is mixed} \} \\
&elim\_cons\_from\_des = condrec(extract\_helpers(extract\_patterns), cond), \textrm{ with}\\
&\qquad cond = \textrm{``the program has destructor copatterns with constructors''} \\
&elim\_multi\_con = condrec(extract\_helpers(extract\_con), cond), \textrm{ with}\\
&\qquad cond = \textrm{``the program has copatterns with multiple constructors''}
\end{alignat*}

\end{framed}

As stated above, $r_{core}$ and $d_{core}$ are essentially two ways of the transformation of Rendel et al. Their precise definitions are given in section 3.6.

\section{Building blocks}

Each of the extraction functions defined below are lifted to programs with $extract\_helpers$ and then recursively composed to build the preprocessing steps of de- and refunctionalization.

\subsection{Destructor extraction}

\begin{figure}
\vspace{2.4in}
\begin{alignat*}{3}
& \langle `` q = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` q' =  \langle q' \rangle^{\sim}_{prg} ", \big\langle \langle q' \rangle^{hsig}_{prg}, `` \langle q' \rangle^{\sim}_{prg}.des(\overline{p}) = t  " \big\rangle \big\rangle, \span\span \\
& \qquad \textrm{if $q = q'.des(\overline{p})$ and $q$ has the most destructors in its function definition} \span\span\span \\
& \langle `` q = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` q = t " \big\rangle, \span\span \\
& \qquad \textrm{otherwise} \span\span\span
\end{alignat*}
\caption{Extraction function $extract\_des$.}
\end{figure}

The destructor extraction function is called $extract\_des$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_des$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vars}),& \text{if $q.des(\overline{p})$ is a lhs in $prg$} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

For the transformation step that eliminate multiple destructors, described in section 3.3, a wrapper of $extract\_des$ is needed that stops at the last destructor.
\[
    \langle `` q = t " \rangle^{extract\_des^{\geq 1}}_{prg} =\\
\begin{cases}
    \big\langle `` q = t " \rangle^{extract\_des},& \text{if $q$ has more than one destructor} \\
   \big\langle `` q = t " \big\rangle,& \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

Destructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_des$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. From the definition of $extract\_helpers$ and $extract\_des$ we thus know that $q_r$ is a destructor copattern. By inversion, we know the form of $s$ is $s^0.des(\overline{t})$ The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s^0_{subv}.des(\overline{t}) = q_{\epsilon_r}[\sigma_\epsilon].des(\overline{t})\\
&\longrightarrow &t_{\epsilon_r}.des(\overline{t})\\
&\longrightarrow^*  &t_{\epsilon_r}.des(\overline{t_v}) = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r} =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s^0$ to equivalent values. We have such a sequence by the third extraction property, because $s^0$ matches $q_{\epsilon_r}$, by the definition of $\epsilon_r$ and because $s = s^0.des(\overline{t})$ and $s$ matches $q_r$.

Similarly, the second multi-step part is concerned with reducing the $\overline{t}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.
\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s^0_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s^0_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0_{subv}] \longrightarrow \mathcal{E}[t_{\epsilon_r}[\sigma_\epsilon]]$}
\end{prooftree}
with $\mathcal{E} = [].des(\overline{t})$. $s^0_{subv}$ matches $q_{\epsilon_r}$ because $s = s^0.des(\overline{t})$ and $q_r = q_{\epsilon_r}.des(\overline{p})$ and $s$ matches $q_r$. The two sides of $\epsilon_r$ are equivalent by definition, thus $s^0_{subv}$ and $t_{\epsilon_r}[\sigma_\epsilon]$ are, too.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
The relevant subterms of $s^0_{subv}$ were values, thus also the terms that $\sigma_\epsilon$ substituted with. And $t_{\epsilon_r}[\sigma_\epsilon]$ contains no reduction-relevant subterms, as well. $t_[\epsilon_r]$ matches $q_{\zeta_r}$ by the definition of $\epsilon_r$ and $\zeta_r$. Because $t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\zeta]$ is equivalent to $s = q_r[\sigma]$, $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta] \sim t_r[\sigma_\zeta]$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the second extraction function property.

\begin{proof}

By induction on the structure of $s$.

By the induction hypothesis, we have that for any immediate subterm $s^0$ of $s$ that, if $s^0$ reduces in $prg$, then also any $\widetilde{s^0} \sim s^0$ reduces in $\langle prg \rangle$.

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$.

Now, consider an $\widetilde{s} \sim s$ which has the same top-level structure as $s$.

%% under construction
This means that each immediate subterm $s^0$ of $s$ is equivalent to an immediate subterm of $\widetilde{s}$. If $s$ reduced by the ``Subst" rule for some equation, we know that $\widetilde{s}$ also matches that equation's lhs. It follows that it either reduces by that equation, or has a reducible subterm. If $s$ reduced by the ``Cong" rule for $s^0$ and some evaluation context, by the induction hypothesis, we know that $\widetilde{s^0}$ reduces, and we can either find some evaluation context such that $\widetilde{s}$ reduces by the ``Cong" rule, or there is a reducible subterm of $\widetilde{s}$ that prevents such a reduction. But then $\widetilde{s}$ would still be reducible in $\langle prg \rangle$.

Finally, consider an $\widetilde{s} \sim s$ with a top-level structure different from that of $s$. It suffices to show that a prefix of $\widetilde{s}$ matches a lhs of $\langle prg \rangle$, because if a reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst'' rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm. By the definition of the equivalence relation, $\widetilde{s}$ has the form
\begin{equation*}
\langle q \rangle^{\sim}_{prg}.\overline{des(\overline{p})}[\sigma],
\end{equation*}
for some $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that a prefix of $\widetilde{s}$, with its form as given above, matches it, if it has one ($des_1$) or more top-level destructor calls. If $\widetilde{s}$ had no top-level destructor calls, i.e., it is an application of the helper function, then there would exist equations in $prg$ which overlap. To see this, consider the form of $s \sim \widetilde{s}$: It matches a $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, as stated above. But then $q$ and $q.des_1(\overline{p})$ overlap, contrary to assumption.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, some equations in $\langle prg \rangle$ result from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By definition, the two sides of $\epsilon_r$ are equivalent, and $\zeta_r$ is equivalent to the equation $r$ of $prg$, i.e., $q_{\zeta_r} \sim q_r$ and $t_{\zeta_r} \sim t_r$.

Suppose the lemma holds for the reduction-relevant subterms of $s$ (the induction hypothesis). This lets us reduce these subterms of $s$ to equivalent values (in $\langle prg \rangle$) first (from left to right). Let $s_0$ be the result of these reductions; it is equivalent to s. The desired reduction sequence is
\begin{equation*}
s \longrightarrow^* s_0 (\longrightarrow s_v).
\end{equation*}
The initial part of the reduction is derived as described above. The final step is only necessary if $s_0$ can still reduce in $\langle prg \rangle$. This can only be the case if it matches $q_{\epsilon_r}$, because (a) it can't match $q_{\zeta_r}$ since its function name isn't declared in $prg$, and (b) if it matched an unchanged equation of $prg$, it wouldn't be a value in $prg$. Thus, if at all, $s_0$ reduces by the ``Subst" rule for $\epsilon_r$ to a $s_v$; the two sides of $\epsilon_r$ are equivalent and therefore $s_0 \sim s_v$. $s_v$ can't reduce any further, because it is an instance of $t_{\epsilon_r}$, which has no destructor, and has a function name not declared in $prg$, and these functions only have definitions with destructor copattern lhss. If it doesn't reduce, set $s_v := s_0$.

\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that destructor extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_des$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since it doesn't touch patterns.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_des)}$.

\begin{proof}

An equation of $\langle prg \rangle$ is either taken over unchanged from $prg$, or it is one of $\epsilon_r, \zeta_r$ for an $r$ of $prg$. This means that the $\epsilon$ equations have to be compared with other $\epsilon$ equations, $\zeta$ with other $\zeta$, $\epsilon$ with unchanged. $\zeta$ equations needn't be compared with $\epsilon$ or unchanged equations, since the latter two have lhss with function names declared in $prg$, while the function name of the lhs of the $\zeta$ equation is fresh in $prg$. Any two unchanged equations also needn't be compared, since we already know they don't overlap.

First, compare any two $\epsilon$ equations. Their immediate prefixes are lhss in $prg$, thus if the $\epsilon$ equations overlapped, so would two lhss in $prg$. But we know that they don't.

Second, compare any two $\zeta$ equations. By their definition, they can only overlap if the equations they are generated from overlap, which we know they don't.

Third, compare an $\epsilon$ equation with an unchanged equation. All equations $r$ which are transformed to a pair of equations $\epsilon_r, \zeta_r$ have the same number of destructors. Because of $align\_patterns$, their immediate prefixes also have the same level of pattern specification. Thus, if the $\epsilon$ equations overlap, their lhss are the same. By their definition, the right-hand sides are identical, as well, thus the two $\epsilon$ equations are one and the same.

\end{proof}

\end{lemma}

\subsection{Constructor extraction}

\begin{figure}
\vspace{2.4in}
\[
    \langle `` q = t " \rangle^{extract\_des}_{prg} =\\
\begin{cases}
    \big\langle `` q^{-con} =  \langle q \rangle^{\sim}_{prg} ", \big\langle \langle q \rangle^{hsig}_{prg}, `` \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^-}) = t  " \big\rangle \big\rangle,& \\
   \qquad \text{if $q$ contains a constructor other than a left outer-most} \\
   \big\langle `` q = t " \big\rangle,& \\
   \qquad \text{otherwise}
\end{cases}
\]
\caption{Extraction function $extract\_con$.}
\end{figure}

The constructor extraction function is called $extract\_con$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \langle q^{-con} \rangle^{name\_pattern}, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q^{-con}_{vars^+} \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_con$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^+}),& \text{if $q$ contains a constructor other than a left outer-most} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

Constructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_con$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by the third extraction function property.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}[\sigma_\epsilon]$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with one pattern replaced by a variable and put in front of the other patterns. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with the variable in front replaced by the respective pattern of $q_r$ (that, in $q_{\epsilon_r}$, was replaced by a variable and put in front). $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_con$ satisfies the second extraction function property.

\begin{proof}

By induction on the structure of $s$.

By the induction hypothesis, we have that for any immediate subterm $s^0$ of $s$ that, if $s^0$ reduces in $prg$, then also any $\widetilde{s^0} \sim s^0$ reduces in $\langle prg \rangle$.

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$.

Now, consider an $\widetilde{s} \sim s$ which has the same top-level structure as $s$. This means that if $s$ reduces in $prg$, so does $\widetilde{s}$ in $\langle prg \rangle$ unless a reducible subterm prevents it. But then it would still reduce in $\langle prg \rangle$.

Finally, consider an $\widetilde{s} \sim s$ with a top-level structure different from that of $s$. It suffices to show that a prefix of $\widetilde{s}$ matches a lhs of $\langle prg \rangle$, because if a reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst'' rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm. By the definition of the equivalence relation, $\widetilde{s}$ has the form
\begin{equation*}
\langle q_r \rangle^{\sim}_{prg}.\overline{des(\overline{p})}[\sigma]
\end{equation*}
for some $q_r$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in exactly such a way that $\langle q \rangle^{\sim}_{prg}[\sigma]$ matches it.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_con$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, some equations in $\langle prg \rangle$ result from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By definition, the lhs of $\epsilon_r$ appears in $prg$ with one variable replaced by a constructor, and the lhs of $\zeta_r$ has a function name undeclared in $prg$.

This means that a term $t$ with all of its names declared in $prg$ can't reduce by a $\zeta_r$ equation. It also can't reduce by an equation that is taken over unchanged from $prg$, because then it would also reduce in $prg$.

The only kind of equation that remains is an $\epsilon_r$. Suppose $t$ reduces by this equation; by definition, the result $\widetilde{t}$ is equivalent to $t$. It can't reduce further. To see this, first note that there is an equation $r$ such that $q_{\epsilon_r}$ is $q_r$ with one constructor replaced by a variable. We know $t$ doesn't reduce by $r$ in $prg$. By definition, there thus also cannot be a $\zeta_r$ by which $\widetilde{t}$ reduces. But all equations of kind $\epsilon$ of taken over unchanged from $prg$ have a function name declared in $prg$, unlike $\widetilde{t}$.

\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that constructor extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_con$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since patterns are either not touched or uniformly replaced by variables.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_des)}$.

\begin{proof}

An equation of $\langle prg \rangle$ is either taken over unchanged from $prg$, or it is one of $\epsilon_r, \zeta_r$ for an $r$ of $prg$. This means that the $\epsilon$ equations have to be compared with other $\epsilon$ equations, $\zeta$ with other $\zeta$, $\epsilon$ with unchanged. $\zeta$ equations needn't be compared with $\epsilon$ or unchanged equations, since the latter two have lhss with function names declared in $prg$, while the function name of the lhs of the $\zeta$ equation is fresh in $prg$. Any two unchanged equations also needn't be compared, since we already know they don't overlap.

First, compare any two $\epsilon$ equations. In $prg$, there are two lhss that are these equations' lhss with one variable replaced by a constructor pattern. Thus, if the $\epsilon$ equations overlapped, so would these two lhss in $prg$. But we know that they don't.

Second, compare any two $\zeta$ equations. By their definition, they can only overlap if the equations they are generated from overlap, which we know they don't.

Third, compare an $\epsilon$ equation with an unchanged equation. The only transformed equations have no destructors on their lhs. The domain of this transformation only has unmixed function definitions. It follows that, if $\epsilon$ overlapped with an unchanged equation, the latter has no destructors, too. Since the extracted constructor is further right than the right-most constructor in the unchanged equation, the unchanged equation and the equation that $\epsilon$ was extracted out of would overlap, which we know they don't.

\end{proof}

\end{lemma}

\subsection{Extraction of all constructors from a single-destructor copattern}

\begin{figure}
\vspace{2.4in}
\[
    \langle `` fun(\overline{p}).des(\overline{p'}) = t " \rangle^{extract\_des}_{prg} =
\begin{cases}
    \big\langle `` fun(\overline{x}).des(\overline{x'}) =  \langle fun(\overline{x}).des(\overline{x'}) \rangle^{\sim}_{prg} ", \\
    \quad \big\langle \langle fun, des \rangle^{hsig}_{prg}, `` \langle fun, des \rangle^{hname}_{prg}(\overline{p}, \overline{p'}) = t  " \big\rangle \big\rangle,& \\
    \qquad \text{if one of the $\overline{p}$ or $\overline{p'}$ is a constructor pattern} \\
   \big\langle `` fun(\overline{p}).des(\overline{p'}) = t " \big\rangle,& \\
    \qquad \text{otherwise}
\end{cases}
\]
\caption{Extraction function $extract\_patterns$.}
\end{figure}

The extraction function that extracts all constructors from a single-destructor copattern is called $extract\_patterns$ and defined in Figure 3-3. The definition uses functions defined in the next paragraph.

For each function $fun$, destructor $des$, and program $prg$, define the helper function name
\begin{equation*}
\langle fun, des \rangle^{hname}_{prg} := \langle fun, des, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle fun, des \rangle^{hsig}_{prg} := \langle fun, des \rangle^{hname}_{prg}(\langle fun \rangle^{argtypes}_{prg}, \langle des \rangle^{argtypes}_{prg}): \langle des \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_patterns$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle fun, des \rangle^{hname}_{prg}(\overline{x}, \overline{x'}),& \text{if } q = fun(\overline{x}).des(\overline{x'}) \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

This extraction function satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_patterns$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by the third extraction function property.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with all patterns replaced by variables. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with all variables replaced by the patterns of $q_r$. $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_patterns$ satisfies the second extraction function property.

\begin{proof} The argument here is identical to that for $extract\_con$.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_patterns$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, some equations in $\langle prg \rangle$ result from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By definition, the lhs of $\epsilon_r$ appears in $prg$ with one variable replaced by a constructor, and the lhs of $\zeta_r$ has a function name undeclared in $prg$.

This means that a term $t$ with all of its names declared in $prg$ can't reduce by a $\zeta_r$ equation. It also can't reduce by an equation that is taken over unchanged from $prg$, because then it would also reduce in $prg$.

The only kind of equation that remains is an $\epsilon_r$. Suppose $t$ reduces by this equation; by definition, the result $\widetilde{t}$ is equivalent to $t$. It can't reduce further. To see this, first note that there is an equation $r$ such that $q_{\epsilon_r}$ is $q_r$ with all patterns replaced by variables. We know $t$ doesn't reduce by $r$ in $prg$. By definition, there thus also cannot be a $\zeta_r$ by which $\widetilde{t}$ reduces. But all equations of kind $\epsilon$ of taken over unchanged from $prg$ have a function name declared in $prg$, unlike $\widetilde{t}$.

\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that this extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_patterns$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since patterns are either not touched or uniformly replaced by variables.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_patterns)}$.

\begin{proof}

An equation of $\langle prg \rangle$ is either taken over unchanged from $prg$, or it is one of $\epsilon_r, \zeta_r$ for an $r$ of $prg$. This means that the $\epsilon$ equations have to be compared with other $\epsilon$ equations, $\zeta$ with other $\zeta$, $\epsilon$ with unchanged. $\zeta$ equations needn't be compared with $\epsilon$ or unchanged equations, since the latter two have lhss with function names declared in $prg$, while the function name of the lhs of the $\zeta$ equation is fresh in $prg$. Any two unchanged equations also needn't be compared, since we already know they don't overlap.

First, compare any two $\epsilon$ equations. In $prg$, there are two lhss that are these equations' lhss with one variable replaced by a constructor pattern. Thus, if the $\epsilon$ equations overlapped, so would these two lhss in $prg$. But we know that they don't.

Second, compare any two $\zeta$ equations. By their definition, they can only overlap if the equations they are generated from overlap, which we know they don't.

Third, compare an $\epsilon$ equation with an unchanged equation. The only transformed equations have exactly one destructor on their lhs. The domain of this transformation only has unmixed function definitions. It follows that, if $\epsilon$ overlapped with an unchanged equation, the latter has one or more destructors. Since $\epsilon$ has only variables as patterns, the unchanged equation and the equation that $\epsilon$ was extracted out of would overlap, which we know they don't.

\end{proof}

\end{lemma}

\section{Core de- and refunctionalization}

\subsection{Core defunctionalization}

After the preprocessing steps, the only thing that remains is to apply the defunctionalization for the Codata Fragment of Uroboro, as developed by Rendel et al., to the not yet defunctionalized parts of the program. It can be applied to these parts because the preprocessing steps guarantee that they are in the Codata Fragment. Call the defunctionalization for the Data Fragment of Uroboro $d^{codata}$; the core defunctionalization for programs is defined as follows below.

\begin{alignat*}{3}
\langle prg \rangle^{d_{core}} & = ~&& \langle && \{ def \in prg ~ | ~ def \textrm{ is codata def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has destr. pattern } \} \rangle^{d^{codata}} \\
& \cup && \{ && \textrm{\textbf{data }} ... ~ | ~ `` \textrm{\textbf{data }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} \{ p = \langle t \rangle^d ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\sigma, \tau_1, ..., \tau_k): \tau \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has hole pattern}\} 
\end{alignat*}

Technical note on constructor subsumption:

The input of $d^{codata}$ in the definition above is actually not in its domain. This is because it can contain constructor calls. The following technical trick allows to transform such inputs as well: For the sake of $d^{codata}$, subsume constructor names under function names (as if they were from the same syntactic domain). After the transformation, since names aren't changed (or when name changes are desired, the original name can still be retrieved), the subsumed constructor names (or their equivalents after a name change) are once again considered constructor names (from the original syntactic domain).

Defunctionalizing terms: \\
$\langle x \rangle^d = x$ \\
$\langle s.des(t_1, ..., t_n) \rangle^d = \langle des \rangle^d (\langle s \rangle^d, \langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle fun(t_1, ..., t_n) \rangle^d = \langle fun \rangle^d (\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\
$\langle con(t_1, ..., t_n) \rangle^d = con(\langle t_1 \rangle^d, ..., \langle t_n \rangle^d)$ \\

\subsubsection{Proof of strong bisimulation}

For $d_{core}$, strong bisimulation holds. The proof relies on properties of $d^{codata}$. As stated in section 2.3.1, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $d^{codata}$, the Codata Fragment.

In section 3, Rendel et al. prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, the refunctionalization $r^{data}$ and the defunctionalization $d^{codata}$. Statement (*) means that strong bisimulation holds for $d^{codata}$.

Using (*), it will now be shown that strong bisimulation holds for $d_{core}$.

\begin{proof}[Proof of strong bisimulation for $d_{core}$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms as defined above. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d_{core}$). Such equations (and indeed the function definitions) are left unchanged by $d_{core}$ except for defunctionalizing the right-hand term, as can be seen directly in the definition of $d_{core}$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

By inversion, we have from $s =^? q \searrow \sigma$ that $s$ has the form $fun(v_1, ..., v_n)$ for some values $v_1, ..., v_n$, thus $\langle s \rangle = fun(\langle v_1 \rangle, ..., \langle v_n \rangle)$. By inversion for values, we have that each $v_i$ is either a constructor application or a value of codata type. If it is a value of codata type, by inversion on pattern matching, the relevant subpattern of $q$ can only be a variable, thus it is also matched by $\langle v_i \rangle$. If it is a constructor application, the relevant subpattern of $q$ is either a variable, and the same holds, or it is a constructor pattern, and by recursively descending into its subpatterns we still get that $\langle v_i \rangle = con(\langle v^1_i \rangle, ..., \langle v^m_n \rangle)$ matches against the subpattern of $q$.

By carrying the substitutions returned from the matchings along in the above recursive argument, we get a substitution $\sigma'$ such that $\langle s \rangle =^? q \searrow \sigma'$ and, by distributing over $\langle s' \rangle$, $\langle s' \rangle [\sigma'] = \langle s'[\sigma] \rangle = \langle t \rangle$. It follows that $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $d_{core}$). Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $d^{codata}$, as specified in the definition of $d_{core}$. Let this part, amended by the ``constructor subsumption" noted for the definition of $d_{core}$, be $prg'$; it is: $s \longrightarrow_{prg'} t$

By (*) we would have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{codata}}} \langle t \rangle,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. 

For the coverage, bear in mind that the equation $`` q = s' "$ enabling the reduction of $s$ by the ``Subst" rule is part of $prg'$ by the precondition of Case 2. As $s$ matches against $q$, copattern coverage for $s$ is trivially fulfilled in $prg'$. The immediate subterms of $s$ are values with respect to $prg$ and, by inversion, their immediate subterms and so forth, which especially means that there is no rule in $prg$ against which they match. But $prg$ has copattern coverage for such a subterm (TODO: make this a general precondition) and there is already no rule for it in $prg$. It follows that $prg'$ still has copattern coverage for the subterm even though there is no rule for it in $prg'$. This is because, either (1) the subterm is a destructor call, then it can only be covered by destructor copatterns (as it matches against a destructor copattern) and those only occur within $prg'$, or (2) it is a constructor call, which doesn't need to be matched for coverage. It can't be a function call, since these can only be covered by directly matching the call, which isn't the case even in $prg$, for which coverage is assumed. Thus coverage holds for $prg'$.

For well-typedness, simply treat the missing types temporarily, that is, for the sake of (*), as codata types. This is no problem for the restriction to the domain of $d^{codata}$, since such types could be introduced inside the Codata Fragment with codata definitions. To be more precise, empty function definitions can be added for missing ones and empty codata definitions for missing types, and removed again after using (*), without adding or removing possible reductions, respectively. All in all, we have by (*):
\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{codata}}} \langle t \rangle
\end{equation*}

But this program $\langle prg' \rangle^{d^{codata}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $d_{core}$. This implies the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

Other cases are excluded by the relevant input fragment.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $\langle s' \rangle \longrightarrow_{\langle prg \rangle} \langle t' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$, defined analogously to the transformation of terms by transforming the terms in $\mathcal{E}$ and by setting $\langle [] \rangle = []$. By applying the congruence rule we get $\langle \mathcal{E} \rangle[\langle s' \rangle] \longrightarrow_{\langle prg \rangle} \langle \mathcal{E} \rangle[\langle t' \rangle]$. It is clear that $\langle \mathcal{E} \rangle[\langle s' \rangle] = \langle \mathcal{E}[s'] \rangle = \langle s \rangle$ and $\langle \mathcal{E} \rangle[\langle t' \rangle] = \langle \mathcal{E}[t'] \rangle = \langle t \rangle$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms as defined above. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $d^{codata}$ to the relevant part of $prg$, as specified in the definition of $d''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $d''$, this other part is taken over unchanged from $prg$ except for defunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $d^{codata}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{codata}}} \langle t \rangle$.

By (*) we would have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{codata}}} \langle t \rangle \iff s \longrightarrow_{prg'} t,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. Both of those properties can be shown or simulated similarly to the way they are in the $`` \Rightarrow "$ part.

But it is $prg' \subseteq prg$, as can be seen in the definition of $d''$. This implies the desired $s \longrightarrow_{prg} t$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = \langle s \rangle$ and $\mathcal{E}[t'] = \langle t \rangle$.

By the induction hypothesis we have $s'' \longrightarrow_{prg} t''$ with $s' = \langle s'' \rangle$, $t' = \langle t'' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$ (defined as in the $`` \Rightarrow "$ part). Apply the congruence rule to get $\mathcal{E}'[s''] \longrightarrow_{prg} \mathcal{E}'[t'']$ with $\mathcal{E} = \langle \mathcal{E}' \rangle$. That is, $\mathcal{E}'$ is the result of applying the inverse of $\langle \cdot \rangle$ to $\mathcal{E}$, which is possible, since, for instance, $\mathcal{E}[s'] = \langle s \rangle$. It is $\langle \mathcal{E}'[s''] \rangle = \langle \mathcal{E}' \rangle[\langle s'' \rangle] = \mathcal{E}[s'] = \langle s \rangle$ and $\langle \mathcal{E}'[t''] \rangle = \langle \mathcal{E}' \rangle[\langle t'' \rangle] = \mathcal{E}[t'] = \langle t \rangle$ and thus we have the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\end{proof}

\subsection{Core refunctionalization}

This is defined analogously to core defunctionalization, by applying the refunctionalization for the Data Fragment of Uroboro to the not yet refunctionalized parts of the program. It can be applied to these parts because the preprocessing steps guarantee that they are in the Data Fragment. Call the refunctionalization for the Data Fragment of Uroboro $r^{data}$; the core refunctionalization for programs is defined as follows below.

First, a technical note: As $r_{core}$ doesn't allow destructor terms in its inputs, they have to be converted beforehand. This conversion is the same as that of $r$ for terms below, restricted to destructor terms. Call this conversion lifted to programs (in the way that all destructor terms on right-hand sides or as subterms of them are converted) $des\_conv$.

\begin{alignat*}{3}
\langle prg \rangle^{r_{core}} & = ~&& \langle \langle && \{ def \in prg ~ | ~ def \textrm{ is data def. or} \\ & && &&\quad \textrm{ function def. with equations } eqns \neq \emptyset: \forall e \in eqns: e \textrm{ has no destr. pattern}, \\
& && &&\qquad \textrm{the first argument of the lhs isn't a variable } \} \rangle^{des\_conv} \rangle^{r_{core}} \\
& \cup && \{ && \textrm{\textbf{codata }} ... ~ | ~ `` \textrm{\textbf{codata }} ... " \in prg \} \\
& \cup && \{ && \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} \{ p = \langle t, prg \rangle^r ~ | ~ "p = t" \in eqns \} \\
& && | && `` \textrm{\textbf{function }} fun(\tau_1, ..., \tau_n): \sigma \textrm{\textbf{ where }} eqns " \in prg \textrm{ with } \forall e \in eqns: e \textrm{ has destr. pattern} \\
& && &&\quad \textrm{or where } n = 0 \textrm{ or where the first argument of the lhs is a variable} \} 
\end{alignat*}

Along with the transformation for programs, a transformation of terms is necessary, which is a conservative extension of $r^{data}$ for programs. For this, write $r$ short for $r_{core}$ \\
$\langle x, prg \rangle^r = x$ \\
$\langle s.des(t_1, ..., t_n), prg \rangle^r = \langle s, prg \rangle^r .des(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = fun(\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
if ``\textbf{function} $fun(\tau_n, ..., \tau_n): \sigma$ \textbf{where} $eqns$" $\in prg$  with $\forall e \in eqns: e$ has destructor pattern or where $n = 0$ or where the first argument of the lhs is a variable \\
$\langle fun(t_1, ..., t_n), prg \rangle^r = \langle t_1, prg \rangle^r .\langle fun, prg \rangle^r (\langle t_2, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$, \\
otherwise \\
$\langle con(t_1, ..., t_n), prg \rangle^r = \langle con, prg \rangle^r (\langle t_1, prg \rangle^r, ..., \langle t_n, prg \rangle^r)$ \\

Note that the case distinction above is only necessary because of the special syntax for destructors ($q(...).des(...)$ instead of $des(..., ...)$).

\subsubsection{Proof of strong bisimulation}

For $r_{core}$, strong bisimulation holds. The proof relies on properties of $r^{data}$. As stated in section 2.3.1, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $r^{data}$, the Data Fragment.

In section 3, Rendel et al. prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, the refunctionalization $r^{data}$ and the defunctionalization $d^{codata}$. Statement (*) means that strong bisimulation holds for $r^{data}$.

Using (*), it will now be shown that strong bisimulation holds for $r_{core}$.

\begin{proof}[Proof of strong bisimulation for $r_{core}$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms as defined above (it is omitted that $prg$ is passed to $r$ as well). This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is destructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $r_{core}$). Such equations (and indeed the function definitions) are left unchanged by $r_{core}$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r_{core}$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

From here, the argument proceeds analogously to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d_{core}$.

\item \underline{Case 2}: $q$ is hole pattern without arguments or where the first argument is a variable:

Then the equation is left unchanged by $r_{core}$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r_{core}$ (last set in the highest-level union). Proceed as in Case 1.

\item \underline{Case 3}: $q$ is hole pattern and has a first argument which is a constructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $r_{core}$), and it has a first argument with data type. Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $des\_conv$, and then the result of this to $r^{data}$, as specified in the definition of $r_{core}$. Let the part passed to $des\_conv$ be $prg'$; it is: $s \longrightarrow_{prg'} t$.

By (*) we have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{r^{data}}} \langle t \rangle,
\end{equation*}

But this program $\langle prg' \rangle^{r^{data}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $r_{core}$. Thus we have the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d_{core}$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined above. This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{data}$ to the relevant part of $prg$, as specified in the definition of $r_{core}$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $r_{core}$, this other part is taken over unchanged from $prg$ except for refunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d_{core}$.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{data}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{data}}} \langle t \rangle$.

By (*) we have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{data}}} \langle t \rangle \iff s \longrightarrow_{\langle prg' \rangle^{des\_conv}} t.
\end{equation*}

In the result of $des\_conv$, no new matching left-hand sides are added. That is, $prg'$ contains at least all the matching left-hand sides that $\langle prg' \rangle^{des\_conv}$ has. Thus any reduction that is possible with respect to $\langle prg' \rangle^{des\_conv}$ is already possible with respect to $prg'$.

But it is $prg' \subseteq prg$, as can be seen in the definition of $r_{core}$. This implies the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d_{core}$.

\end{proof}

\section{Simplifying copatterns (Alternative approach to de- and refunc.}

Both de- and refunctionalization are made up of two major parts:
\begin{enumerate}
\item First, destructor and constructor extractions alternate to transform the program into a form which can be used by the second part.

\item This second part is the core de-/refunctionalization, which is essentially the two-way transformation from the paper of Rendel et al.
\end{enumerate}

The \textit{simplifying} part of the defunctionalization transformation is made up of destructor and constructor extraction steps and stops when the program is in the input fragment of core defunctionalization, described below. The simplifying part of the refunctionalization transformation is defined like that, with the only difference being that it stops when the program is in the input fragment of core refunctionalization, also described below.

This simplification is done individually for each function definition, the order in which the function definitions are transformed is unimportant. For one function definition $def$, the algorithm is defined below.

\[
  \langle prg \rangle^{simplify(def)}=\begin{cases}
               prg, &\text{ if $def$ is in the desired fragment}\\
               \langle prg \rangle^{simplify\_step(def)} \rangle^{simplify(def)}, &\text{ otherwise}
            \end{cases}
\]

\[
  \langle prg \rangle^{simplify\_step(def)}=\begin{cases}
               \langle prg \rangle^{liftp(des\_extract(q^{max}_{def}))}, \\
               \qquad\text{ if } \langle prg \rangle^{liftp(con_{n_{def}}\_extract(q^{max}_{def}))} \text{ has overlaps}\\
               \langle prg \rangle^{liftp(con_{n_{def}}\_extract(q^{max}_{def}))},\\
               \qquad\text{ otherwise}
            \end{cases}
\]

with

\[
q^{max}_{def} = \textrm{max}_{\# con.} \textrm{max}_{\# des.} \{q ~ | ~ q \text{ is lhs in $def$ } \}
\]

and $n_{def}$ the number of the inner-most constructor in $q^{max}_{def}$ which has a variable ``in its place'' in another lhs of $def$. For a pattern $p$ of a copattern $q$ to be ``in the place'' of another pattern $p'$ in another copattern $q'$ means:
\begin{itemize}
\item When $p$ is a subterm of the $n$-th pattern immediately under $q$, then $p'$ is a subterm of the $n$-th pattern immediately under $q$,

\item the same for the $m$-th pattern immediately under the $n$-th patterns if $p$ and/or $p'$ aren't the $n$-th patterns themselves,

\item and so on recursively.
\end{itemize}

As can be seen in the definition of $simplify\_step$, the algorithm switches from destructor to constructor extraction whenever constructor extraction would produce overlapping lhss. This actually prevents overlaps, because, whenever constructor extraction would produce overlaps, destructor extraction doesn't, as will be shown below.

Clearly, this also means that the algorithm eventually arrives at a function definition without any destructors and without any constructors, unless it stops before that, thus ensuring that the desired fragment will be reached in any case.

\subsection{Bisimulation}

Two properties are desired for this algorithm: some kind of bisimulation, and that no overlapping lhss are generated. Since the algorithm is made up only of $des\_extract$ and $con\_extract$ steps, these properties follow from their respective properties.

When overlapping lhss are absent in the transformed program, we have the kind of weak bisimulation as established by Proposition 2.3.1 for both $des\_extract$ and $con\_extract$, irrespective of which lhs is targeted. That overlaps aren't generated by one such step will be shown in the following subsection.

\subsection{Absence of overlaps}

By Proposition 2.4.1, for both $des\_extract$ and $con\_extract$, it suffices to show that $q_\epsilon$ doesn't overlap with unchanged lhss. This doesn't hold for arbitrary targeted lhss; in order to avoid generating overlaps, $simplify\_step$ was defined as above. It is now shown that this definition really prevents overlaps in the resulting program of one such step. As pointed out above, because of the definition of $simplify\_step$, it suffices to show that destructor extraction doesn't produce overlaps whenever constructor extraction does.

When constructor extraction leads to overlaps, ...
