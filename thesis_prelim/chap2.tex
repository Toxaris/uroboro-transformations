\chapter{The language Uroboro}

In this chapter we formally define the language Uroboro. It is a more or less straightforward generalization of Rendel et al.s Data and Codata Fragments; we therefore orient ourselves on their presentation. We will also sometimes orient ourselves on Abel et al., which also define a language with copatterns, albeit including first-class functions unlike Uroboro. We first define the syntax of Uroboro (\autoref{sec:urosyn}), then its typing (\autoref{sec:urostatsem}), and finally its dynamic semantics (\autoref{sec:urosos}), which we present as small-step operational semantics.

In the introduction, we have already shown example programs from the Data and Codata Fragments. Before we start with the definitions, we give an example Uroboro program that is neither in the Data nor in the Codata Fragments, i.e., it contains both data and codata types.

\begin{lstlisting}



\end{lstlisting}

\section{Syntax}
\label{sec:urosyn}

We assume the following domains of symbols.

\begin{align*}
&\sigma, \tau = &\textrm{type names}\\
&con = &\textrm{constructor names}\\
&des = &\textrm{destructor names}\\
&fun = &\textrm{function names}\\
&x, y = &\textrm{variable names}\\
\end{align*}

The \textit{terms} of Uroboro are variables, and constructor calls, destructor calls, and function calls to lists of terms.

\[
s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)
\]

The destructor call syntax is syntactical sugar for $des(s, t^*)$, meant to easier distinguish between the destructed (or observed) term and the other arguments of the destructor. A subset of terms is the set of copatterns, which we denote $\mathbf{Cop}$; a copattern is either a function call applied to patterns, or a destructor destructing another copattern and otherwise applied to patterns.

\begin{align*}
&q ::= fun(p^*) ~ | ~ q.des(p^*) \\
&p ::= x ~ | ~ con(p^*)
\end{align*}

\textit{Programs} are defined to be sets of \textit{definitions}. A definition can either be a data type definition, a codata type definition, or a function definition.

\[
prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*
\]

\textit{Data (type) definitions} consist of the name of the data type together with a set of constructor signatures.

\begin{align*}
&ddef &::= \textbf{data } \sigma \textbf{ where } csig^* &\\
&csig &::= con(\tau^*): \tau &\\
\end{align*}

\textit{Codata (type) definitions} consist of the name of the codata type together with a set of destructor signatures.

\begin{align*}
&coddef &::= \textbf{codata } \sigma \textbf{ where } dsig^*\\
&dsig &::= \sigma.des(\tau^*): \tau\\
\end{align*}

\textit{Function definitions} consist of the signature of the function together with a set of \textit{equations}. Equations have a left-hand side, which is a copattern, and a right-hand side, which is some term.

\begin{align*}
&fdef &::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*\\
&eqn &::= q = t
\end{align*}

\section{Static semantics}
\label{sec:urostatsem}

As is the case with the copattern language of Abel et al., there are two kinds of types in Uroboro. \textit{Positive types}, which are those defined by data type definitions, and \textit{negative types}, which are those defined by codata type definitions. Like Rendel et al. do for their fragments, we give a type judgement for terms, and one to judge whether equations are well-typed.  Like them, we let $\Sigma$ be the signatures of a program, that is, its function signatures, codata signatures, and data signatures, as defined above, and we let $\Gamma$ be a typing context, i.e., a set of type assignments to variables, and write
\begin{itemize}
\item $\Gamma \vdash_{\Sigma} t : \tau$ to mean that term $t$ is well-typed with type $\tau$ under typing context $\Gamma$ and signature $\Sigma$, and

\item $\Sigma \vdash eqn \textrm{ ok}$ to mean that equation $eqn$ is well-typed under signature $\Sigma$.
\end{itemize}
We give the following rules for the type judgement for terms, which extend those of the Data and Codata Fragments. In fact, we simply combine the rules of the Data and Codata Fragments.

\begin{prooftree}
\AxiomC{$``x : \tau" \in \Gamma$}
\RightLabel{Var}
\UnaryInfC{$\Gamma \vdash_{\Sigma} x : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Fun}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} fun(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Con}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} con(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} s : \sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Des}
\QuinaryInfC{$\Gamma \vdash_{\Sigma} s.des(t_1, ..., t_n): \tau$}
\end{prooftree}

We give the following rules for the well-typedness judgement for equations, which generalize the rules for the Data and Codata Fragment. We write $V(q)$ to denote the variables occuring in $q$.

\begin{prooftree}
\AxiomC{$q = q'.des(p_1, ..., p_n)$}
\noLine
\UnaryInfC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$(q \vdash_{\Sigma} x : \sigma_x)_{x \in V(q)}$}
\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q) \} \vdash_{\Sigma} t : \tau$}
\RightLabel{Des}
\TrinaryInfC{$\Sigma \vdash q = t \textrm{ ok}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q = fun(p_1, ..., p_n)$}
\noLine
\UnaryInfC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$(q \vdash_{\Sigma} x : \sigma_x)_{x \in V(q)}$}
\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q) \} \vdash_{\Sigma} t : \tau$}
\RightLabel{Fun}
\TrinaryInfC{$\Sigma \vdash q = t \textrm{ ok}$}
\end{prooftree}

Here, $q \vdash_{\Sigma} x : \sigma$, for $x \in V(q)$, is an auxiliary judgement which means that, within copattern $q$, the variable has type $\sigma$ under signature $\Sigma$. To put it another way, it is a type inference for variables. This judgement, in turn, uses an analogous judgement for patterns. The rules for both judgements are given below.

\begin{center}
\AxiomC{$x = p_i$}
\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\RightLabel{Con\textsubscript{Var}}
\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \tau_i$}
\DisplayProof
\AxiomC{$x \in V(p_i), x \neq p_i$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Con\textsubscript{Con}}
\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\end{center}

\begin{prooftree}
\AxiomC{$x \in V(p_i)$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Fun}
\BinaryInfC{$fun(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\end{prooftree}

\begin{center}
\AxiomC{$x \in V(p_i)$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Des\textsubscript{P}}
\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\AxiomC{$x \in V(q)$}
\AxiomC{$q \vdash_{\Sigma} x : \sigma$}
\RightLabel{Des\textsubscript{Q}}
\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\end{center}





We say that a program with signatures $\Sigma$ is well-typed when it is $\Sigma \vdash eqn \textrm{ ok}$ for all equations $eqn$ of the program.

\section{Dynamic semantics}
\label{sec:urosos}

\subsection{Copattern matching}

orients itself on and borrows notations from paper ``Copatterns" (Abel et al.), section 4

$t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

$t =^? q \searrow \sigma$ means that term $t$ matches copattern $q$ returning substitution $\sigma$.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\subsection{Values}

This section formalizes the notion of value for Uroboro. As is the case with the language of Abel et al., whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from `Copatterns" (Abel et al.), section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

%%-- under construction

The value judgement makes use of a ``no-match" judgement. This judgement is complementary to the pattern matching judgement of the previous section.

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Con/Card}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Card}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \neq m$}
\RightLabel{NPM\textsubscript{Des/Card}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}

%%--

\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\subsection{Copattern coverage}

\begin{prooftree}
\AxiomC{}
\RightLabel{C\textsubscript{Head}}
\UnaryInfC{$fun \lhd | (fun(\overline{x}))$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q^\tau)$}
\RightLabel{C\textsubscript{Des}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q.des(\overline{x^{des}}))_{des \in Dess_\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q(x^\tau))$}
\RightLabel{C\textsubscript{Con}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q[x := con(\overline{y^{con}})])_{con \in Cons_\tau}$}
\end{prooftree}

\subsection{The reduction relation}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction depends upon a set of terms $\textrm{Val}$ which are considered to be values. Standardly, $\textrm{Val}$ is assumed to be the set of terms which are judged to be values by $\vdash_v t$. Sometimes, an alternative reduction judgement will be used, which will only differ in the underlying value set $\textrm{Val}$. This alternative reduction will then be defined by giving the alternative $\textrm{Val}$.

We define evaluation contexts for left-to-right, call-by-value evaluation.
\begin{alignat*}{2}
& v  \in &&\textrm{Val} \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}
We let $\mathbf{EC}$ denote the set of evaluation contexts for the standard value judgement $\vdash'_v$, and we let $\mathbf{EC}[V]$ denote the set of evaluation contexts for other value sets (or their respective judgements).

Contraction $\mapsto$ of terms using equations is defined as follows.

if the immediate subterms of $t$ are values:
\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \mapsto t'[\sigma]$}
\end{prooftree}

Finally, we define the actual reduction relation by a congruence rule.
\begin{prooftree}
\AxiomC{$t \mapsto t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

Write $\longrightarrow^=$ for the reflexive closure, $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^=_{prg}$, $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

The well-known notions of \textit{context} and \textit{multi-hole context} are related to that of evaluation context. We will use them in some of the proofs of this work, and therefore give an Uroboro-specific definition for each of them here.

\begin{definition}[Context]
Contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun(t^*, \mathcal{E}, t^*) ~ | ~ con(t^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des(t^*, \mathcal{E}, t^*)
\]
\end{definition}

\begin{definition}[Multi-hole context]
Multi-hole contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun((\mathcal{E} ~ | ~ t)^*) ~ | ~ con((\mathcal{E} ~ | ~ t)^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des((\mathcal{E} ~ | ~ t)^*)
\]
\end{definition}

Concerning evaluation contexts and contexts, the following holds, which will be used in the proof of \autoref{lem:cdpaux}.

\begin{fact}
\label{fac:chp21}
For any two contexts $\mathcal{C}, \mathcal{C}_0$ and any evaluation context $\mathcal{E} \in \mathbf{EC}[V]$ for some set of values $V$:
\[
\mathcal{E} = \mathcal{C}[\mathcal{C}_0] \implies \mathcal{C} \in \mathbf{EC}[V].
\]
\end{fact}

\subsection{As an extension of (Co)Data Fragment semantics}

The properties of the reductions and the de- and refunctionalization transformations of the paper of Rendel, Trieflinger, and Ostermann are used for the proofs of the next section. The domain of their defunctionalization is what they call the Codata Fragment, and that of refunctionalization the Data Fragment. Their semantic properties can be used in the proofs because, for well-typed programs and limited to terms which have copattern coverage for all of their subterms in the program (TODO: define this more precisely), this work's reducibility notion is a conservative extension of either the Data Fragment's notion or the Codata Fragment's notion. When the well-typedness and coverage conditions are dropped, the reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsubsection{Data Fragment}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment (Figure 6b), as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that it is not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from last section.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b)
\begin{equation*}
u, v ::= con(v^*),
\end{equation*}
while the V\textsubscript{CodTFun} can never be applied. This is because a function in the Data Fragment can only have data type unless it doesn't have a type defined in the program at all, as types can only be added by data definitions.

\subsubsection{Codata Fragment}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. It will be demonstrated why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if" direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. That the second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if" direction. By the rules of the judgement, a value can also be a destructor application if it has codata type and doesn't match any rule of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage for all subterms of the input term, since those are the only ones that can be relevant for the value judgement in the one-step reduction.
