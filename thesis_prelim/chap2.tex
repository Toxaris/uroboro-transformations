\chapter{The language Uroboro}

In this chapter we formally define the language Uroboro. It is a more or less straightforward generalization of the Data and Codata Fragments of Rendel et al.\cite{rendel15automatic}; we therefore orient ourselves on their presentation. We will also sometimes orient ourselves on Abel et al.\cite{abel13copatterns}, which also define a language with copatterns, albeit including first-class functions unlike Uroboro. We first define the syntax of Uroboro (\autoref{sec:urosyn}), then its typing (\autoref{sec:urostatsem}), and finally its dynamic semantics (\autoref{sec:urosos}), which we present as small-step operational semantics. Afterwards, we define copattern coverage for Uroboro (\autoref{sec:cc}), which is analogous to coverage in functional programming languages with pattern matching. Then we show type soundness for Uroboro (\autoref{sec:urots}). We conclude the chapter by showing how the reduction semantics of Uroboro extends those of either the Data or Codata Fragment (\autoref{codfragext}).

In the introduction, we have already shown example programs from the Data and Codata Fragments. Before we start with the definitions, we give an example Uroboro program that is neither in the Data nor in the Codata Fragments, i.e., it contains both data and codata types.

\begin{lstlisting}



\end{lstlisting}

\section{Syntax}
\label{sec:urosyn}

We assume the following domains of symbols.

\begin{align*}
&\sigma, \tau = &\textrm{type names}\\
&con = &\textrm{constructor names}\\
&des = &\textrm{destructor names}\\
&fun = &\textrm{function names}\\
&x, y = &\textrm{variable names}\\
\end{align*}

The \textit{terms} of Uroboro are variables, and constructor calls, destructor calls, and function calls to lists of terms.

\[
s, t ::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*)
\]

The destructor call syntax is syntactical sugar for $des(s, t^*)$, meant to easier distinguish between the destructed (or observed) term and the other arguments of the destructor. A subset of terms is the set of copatterns, which we denote $\mathbf{Cop}$; a copattern is either a function call applied to patterns, or a destructor destructing another copattern and otherwise applied to patterns.

\begin{align*}
&q ::= fun(p^*) ~ | ~ q.des(p^*) \\
&p ::= x ~ | ~ con(p^*)
\end{align*}

\textit{Programs} are defined to be sets of \textit{definitions}. A definition can either be a data type definition, a codata type definition, or a function definition.

\[
prg ::= (ddef ~ | ~ coddef ~ | ~  fdef)^*
\]

\textit{Data (type) definitions} consist of the name of the data type together with a set of constructor signatures.

\begin{align*}
&ddef &::= \textbf{data } \sigma \textbf{ where } csig^* &\\
&csig &::= con(\tau^*): \tau &\\
\end{align*}

\textit{Codata (type) definitions} consist of the name of the codata type together with a set of destructor signatures.

\begin{align*}
&coddef &::= \textbf{codata } \sigma \textbf{ where } dsig^*\\
&dsig &::= \sigma.des(\tau^*): \tau\\
\end{align*}

\textit{Function definitions} consist of the signature of the function together with a set of \textit{equations}. Equations have a left-hand side, which is a copattern, and a right-hand side, which is some term.

\begin{align*}
&fdef &::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^*\\
&eqn &::= q = t
\end{align*}

Note that we consider the collection of equations in a function definition to be a \textit{set}. This means that we establish no order on the equations. We don't consider order-dependent programs in this work; suffice it to say that a variant of Uroboro augmented with order would require a change to the semantics. In general, this is a problem not yet considered for languages with copattern matching; for instance, the language of Abel et al.\cite{abel13copatterns} also doesn't have an order on equations.

\section{Static semantics}
\label{sec:urostatsem}

As is the case with the copattern language of Abel et al.\cite{abel13copatterns}, there are two kinds of types in Uroboro. \textit{Positive types}, which are those defined by data type definitions, and \textit{negative types}, which are those defined by codata type definitions. Like Rendel et al. do for their fragments, we give a type judgement for terms, and one to judge whether equations are well-typed.  Like them, we let $\Sigma$ be the signatures of a program, that is, its function signatures, codata signatures, and data signatures, as defined above, and we let $\Gamma$ be a typing context, i.e., a set of type assignments to variables, and write
\begin{itemize}
\item $\Gamma \vdash_{\Sigma} t : \tau$ to mean that term $t$ is well-typed with type $\tau$ under typing context $\Gamma$ and signature $\Sigma$, and

\item $\Sigma \vdash eqn \textrm{ ok}$ to mean that equation $eqn$ is well-typed under signature $\Sigma$.
\end{itemize}
We give the following rules for the type judgement for terms, which extend those of the Data and Codata Fragments. In fact, we simply combine the rules of the Data and Codata Fragments.

\begin{prooftree}
\AxiomC{$``x : \tau" \in \Gamma$}
\RightLabel{Var}
\UnaryInfC{$\Gamma \vdash_{\Sigma} x : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Fun}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} fun(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Con}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} con(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} s : \sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Des}
\QuinaryInfC{$\Gamma \vdash_{\Sigma} s.des(t_1, ..., t_n): \tau$}
\end{prooftree}

We give the following rules for the well-typedness judgement for equations, which generalize the rules for the Data and Codata Fragment. We write $V(q)$ to denote the variables occuring in $q$.

\begin{prooftree}
\AxiomC{$q = q'.des(p_1, ..., p_n)$}
\noLine
\UnaryInfC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$(q \vdash_{\Sigma} x : \sigma_x)_{x \in V(q)}$}
\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q) \} \vdash_{\Sigma} t : \tau$}
\RightLabel{Des}
\TrinaryInfC{$\Sigma \vdash q = t \textrm{ ok}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q = fun(p_1, ..., p_n)$}
\noLine
\UnaryInfC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$(q \vdash_{\Sigma} x : \sigma_x)_{x \in V(q)}$}
\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q) \} \vdash_{\Sigma} t : \tau$}
\RightLabel{Fun}
\TrinaryInfC{$\Sigma \vdash q = t \textrm{ ok}$}
\end{prooftree}

Here, $q \vdash_{\Sigma} x : \sigma$, for $x \in V(q)$, is an auxiliary judgement which means that, within copattern $q$, the variable has type $\sigma$ under signature $\Sigma$. To put it another way, it is a type inference for variables. This judgement, in turn, uses an analogous judgement for patterns. The rules for both judgements are given below.

\begin{center}
\AxiomC{$x = p_i$}
\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\RightLabel{Con\textsubscript{Var}}
\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \tau_i$}
\DisplayProof
\AxiomC{$x \in V(p_i), x \neq p_i$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Con\textsubscript{Con}}
\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\end{center}

\begin{prooftree}
\AxiomC{$x \in V(p_i)$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Fun}
\BinaryInfC{$fun(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\end{prooftree}

\begin{center}
\AxiomC{$x \in V(p_i)$}
\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
\RightLabel{Des\textsubscript{P}}
\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\AxiomC{$x \in V(q)$}
\AxiomC{$q \vdash_{\Sigma} x : \sigma$}
\RightLabel{Des\textsubscript{Q}}
\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
\DisplayProof
\end{center}

We say that a program with signatures $\Sigma$ is well-typed when it is $\Sigma \vdash eqn \textrm{ ok}$ for all equations $eqn$ of the program.

\section{Dynamic semantics}
\label{sec:urosos}

In this section, we formally define the semantics of Uroboro. We present them as small-step operational semantics. Before defining the reduction relation, a few other definitions are in order. In Uroboro, a reduction is a term rewriting that uses one of the equations of the program. Therefore, we need to define what it means for a term to match an lhs, that is, a copattern; we do so in \autoref{ssec:copm}. For languages with codata, there is a special notion of value; we define what values are in Uroboro in \autoref{ssec:val}. Then we define the reduction relation (\autoref{ssec:red}).

\subsection{Copattern matching}
\label{ssec:copm}

Here, we define what it means for a term to match a copattern. In short, a term $t$ matches a copattern $q$ when there is a substitution $\sigma$ such that $t = q[\sigma]$. We give a judgement for this, which orients itself on and borrows notations from Abel et al.\cite{abel13copatterns}, section 4. In order to do so, we also give an analogous judgement for patterns. In terms of the judgement for patterns, $t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$ (i.e. it is equivalent to $t = p[\sigma]$). The meaning of $t =^? q \searrow \sigma$, for copatterns $q$, is defined analogously. The rules for the pattern matching judgement are as follows.

\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

Using this judgement for patterns, we define the rules for the copattern matching judgement.

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}

\subsection{Values}
\label{ssec:val}

This section formalizes the notion of value for Uroboro. As is the case with the language of Abel et al.\cite{abel13copatterns}, whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$\vdash_v t$ means that the closed term $t$ is a value. This notation is borrowed from Abel et al.\cite{abel13copatterns}, section 5. Note that only closed terms are considered because only those are relevant for the semantics preservation.

The value judgement makes use of a ``no-match'' judgement. We write $t \neq^? q$ to mean that $t$ doesn't match $q$, i.e., it is $t \neq q[\sigma]$ for all substitutions $\sigma$. This judgement is complementary to the copattern matching judgement of the previous section. In order to define the rules of the ``no-match'' judgement for copatterns, as with the matching judgement, we give the rules of an analogous ``no-match'' judgement for patterns.

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$con \neq con'$}
\RightLabel{NPM\textsubscript{Con/Diff}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con'(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \neq fun'$}
\RightLabel{NPM\textsubscript{App/Diff}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun'(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$des \neq des'$}
\RightLabel{NPM\textsubscript{Des/Diff}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des'(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}

Finally, using this ``no-match'' judgement, we define the rules of the value judgement. As said above, this judgement also depends upon the type of the term. In short, a term is a value whenever it is a either (a) constructor applied to values, or (b) a function or destructor applied to values such that the return type of the function or destructor is a negative type, i.e., a type defined by a codata type definition.

\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}

\subsection{The reduction relation}
\label{ssec:red}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction depends upon a set of terms $\textrm{Val}$ which are considered to be values. Standardly, $\textrm{Val}$ is assumed to be the set of terms which are judged to be values by $\vdash_v t$. Sometimes, an alternative reduction judgement will be used, which will only differ in the underlying value set $\textrm{Val}$. This alternative reduction will then be defined by giving the alternative $\textrm{Val}$.

We define evaluation contexts for left-to-right, call-by-value evaluation.
\begin{alignat*}{2}
& v  \in &&\textrm{Val} \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}
We let $\mathbf{EC}$ denote the set of evaluation contexts for the standard value judgement $\vdash'_v$, and we let $\mathbf{EC}[V]$ denote the set of evaluation contexts for other value sets (or their respective judgements).

Contraction $\mapsto$ of terms using equations is defined as follows.

\begin{center}
if the immediate subterms of $t$ are values:
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \mapsto t'[\sigma]$}
\DisplayProof
\end{center}

Finally, we define the actual reduction relation by a congruence rule.
\begin{prooftree}
\AxiomC{$t \mapsto t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

Write $\longrightarrow^=$ for the reflexive closure, $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^=_{prg}$, $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

The well-known notions of \textit{context} and \textit{multi-hole context} are related to that of evaluation context. We will use them in some of the proofs of this work, and therefore give an Uroboro-specific definition for each of them here.

\begin{definition}[Context]
Contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun(t^*, \mathcal{E}, t^*) ~ | ~ con(t^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des(t^*, \mathcal{E}, t^*)
\]
\end{definition}

\begin{definition}[Multi-hole context]
Multi-hole contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun((\mathcal{E} ~ | ~ t)^*) ~ | ~ con((\mathcal{E} ~ | ~ t)^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des((\mathcal{E} ~ | ~ t)^*)
\]
\end{definition}

Concerning evaluation contexts and contexts, the following holds, which will be used in the proof of \autoref{lem:cdpaux}.

\begin{fact}
\label{fac:chp21}
For any two contexts $\mathcal{C}, \mathcal{C}_0$ and any evaluation context $\mathcal{E} \in \mathbf{EC}[V]$ for some set of values $V$:
\[
\mathcal{E} = \mathcal{C}[\mathcal{C}_0] \implies \mathcal{C} \in \mathbf{EC}[V].
\]
\end{fact}

\section{Copattern coverage}
\label{sec:cc}

In general, when a language enjoys type soundness, for programs with \textit{coverage} it is guaranteed that no term is stuck. We adapt the judgement for \textit{copattern coverage} from Abel et al.\cite{abel13copatterns} for Uroboro. $fun \lhd | ~ Q$ means that the set of copatterns $Q$ \textit{covers} the function $fun$. Intuitively, when this set $Q$ is the set of left-hand sides of the function definition for $fun$, this function is fully specified. One can regard the consecutive application of the rules of the coverage judgement as a way of step-wise refining the specification of the function. The rule C\textsubscript{Head} stands for the start point, where the only left-hand side of the function neither has destructor nor constructor calls. The other two rules refine the specification of $fun$ by variable splitting (C\textsubscript{Con}), that is, refining based upon the input, or by result splitting (C\textsubscript{Des}), that is, refining based upon the output (or result). The terminology ``variable splitting'' and ``result splitting'' is also borrowed from Abel et al. and will become relevant in chapter 4.

These rules for the judgement are defined below. We assume a program and write $Dess_\tau$ for the set of destructors for codata type $\tau$, and $Cons_\tau$ for the set of constructors for data type $\tau$. We also write $q^\tau$ and $x^\tau$ to indicate that the type of the copattern $q$ or the variable $x$, respectively, has been inferred to be $\tau$. \autoref{sec:urostatsem} provides a way to infer types for variables, the type of a copattern is found out by looking it up in the respective function or destructor signature.

\begin{prooftree}
\AxiomC{}
\RightLabel{C\textsubscript{Head}}
\UnaryInfC{$fun \lhd | (fun(\overline{x}))$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q^\tau)$}
\RightLabel{C\textsubscript{Des}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q.des(\overline{x^{des}}))_{des \in Dess_\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q(x^\tau))$}
\RightLabel{C\textsubscript{Con}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q[x := con(\overline{y^{con}})])_{con \in Cons_\tau}$}
\end{prooftree}

A program has copattern coverage whenever all of its function definitions have coverage, that is, it is $fun \lhd | ~ Q$ for each function $fun$ and its set of left-hand sides $Q$.

In chapter 4, we will rely not only upon copattern coverage, but also on knowing how the coverage was derived by consecutive result and variable splitting. In other words, we need an algorithm for the judgement. Abel et al.\cite{abel13copatterns} hint, for their judgement, at a possible way to adapt other coverage algorithms for copatterns; to our knowledge, there currently is no such algorithm for copattern coverage checking, either by Abel et al. or others. For the time being, an exponential-time algorithm that goes through all derivation trees of a maximum depth will have to suffice. The maximum depth is the maximal number of constructors and destructors, added together, of all lhss of the function definition.

\section{Type soundness}
\label{sec:urots}

We show that Uroboro enjoys type-soundness. As usual, we do so by showing preservation and progress for the reduction relation $\longrightarrow$. The notion of completeness used in the progress lemma is the copattern coverage defined in the previous section; the value notion is that of the judgement $\vdash_v$ defined in \autoref{ssec:val}.

\begin{lemma}[Type preservation]
If a program $prg$ with signatures $\Sigma$ is well-typed, the following holds for any two terms $s, t$: When $\Gamma \vdash_{\Sigma} s : \tau$ and $s \longrightarrow_{prg} t$, then $\Gamma \vdash_{\Sigma} t : \tau$.
\begin{proof}
TODO
\end{proof}
\end{lemma}

\begin{lemma}[Progress]
If a program $prg$ with signatures $\Sigma$ is well-typed and has copattern coverage, any term with $\vdash_{\Sigma} t : \tau$ (especially: $t$ is closed) is either reducible, i.e., their exists a term $t'$ with $t \longrightarrow_{prg} t'$, or it is $\vdash_v t$.
\begin{proof}
Suppose that $t$ doesn't reduce, i.e., there is no term $t'$ with $t \longrightarrow_{prg} t'$. By induction on the structure of $t$ we show that in this case it is $\vdash_v t$.

Assume that for all subterms $t_0$ of $t$ it is $\vdash_v t_0$ (the induction hypothesis). If $t$ matched an lhs of $prg$, it would thus reduce (contract) using this equation, contrary to assumption. If the type $\tau$ of $t$ is a negative (codata) type, we have $\vdash_v t$ by either the rule V\textsubscript{CodTFun} or the rule V\textsubscript{CodTDes} of the value judgement, depending on whether $t$ is a function call or a destructor call. If $\tau$ is a positive (data) type, we distinguish two cases.
\begin{enumerate}
\item $t$ is a constructor call. Then we have $\vdash_v t$ by the V\textsubscript{Con} rule of the value judgement.

\item $t$ is a function or destructor call. Since $t$ doesn't match any lhs of $prg$, this contradicts the fact that $prg$ has copattern coverage. This is because coverage for the function definition of the function of $t$ can only be established when there is an lhs that $t$ itself matches, since (a) coverage cannot be established by result splitting, as $\tau$ is a positive type, and (b) all subterms of $t$ are values and thus don't match any lhs.
\end{enumerate}
\end{proof}
\end{lemma}

\section{As an extension of (Co)Data Fragment semantics}
\label{sec:codfragext}

To conclude this chapter, we show how Uroboro's semantics relate to those of either the Data Fragment or of the Codata Fragment. Assuming well-typedness and copattern coverage, Uroboro's notion of reducibility is a conservative extension of either the Data Fragment's notion (\autoref{ssec:df}) or the Codata Fragment's notion (\autoref{ssec:codf}). Note that, when the well-typedness and coverage conditions are dropped, Uroboro's reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsection{Data Fragment}
\label{ssec:df}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment, as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that values are not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from \autoref{ssec:val}.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b of Rendel et al.\cite{rendel15})
\[
u, v ::= con(v^*),
\]
while the V\textsubscript{CodTFun} can never be applied. This is because a function in the Data Fragment can only have data type unless it doesn't have a type defined in the program at all, as types can only be added by data definitions.

\subsection{Codata Fragment}
\label{ssec:codf}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. It will be demonstrated why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if" direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. That the second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if" direction. By the rules of the judgement, a value can also be a destructor application if it has codata type and doesn't match any rule of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage.
