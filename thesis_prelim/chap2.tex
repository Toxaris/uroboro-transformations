% !TEX root = main.tex
\chapter{The language Uroboro}

\begin{figure}
\begin{lstlisting}

data Nat where
  Zero(): Nat
  Succ(Nat): Nat

function add(Nat, Nat): Nat where
  add(Zero(), n) = n
  add(Succ(m), n) = Succ(add(m, n))

function multiply(Nat, Nat): Nat where
  multiply(Zero(), n) = Zero()
  multiply(Succ(m), n) = add(multiply(m, n), n)

codata Array where
  Array.get(Nat): Nat

function oneElemArray(Nat): Array where
  oneElemArray(n).get(Zero()) = n
  oneElemArray(n).get(Succ(m)) = Zero()

function isOne(Nat): Nat where
  isOne(Zero()) = Zero()
  isOne(Succ(Zero())) = Succ(Zero())
  isOne(Succ(Succ(n))) = Zero()

\end{lstlisting}
\caption{Uroboro sample outside (Co)Data Fragments}
\label{fig:ch2uroex}
\end{figure}

In this chapter we formally define the language Uroboro. It is a more or less straightforward generalization of the Data and Codata Fragments of Rendel et al.\cite{rendel15automatic}; we therefore orient ourselves on their presentation. We will also sometimes orient ourselves on Abel et al.\cite{abel13copatterns}, which also define a language with copatterns, albeit including first-class functions unlike Uroboro.

In this chapter, we start with some notational preliminaries (\autoref{sec:uronotp}). Then we define the syntax of Uroboro (\autoref{sec:urosyn}), then its typing (\autoref{sec:urostatsem}), and finally its dynamic semantics (\autoref{sec:urosos}), which we present as small-step operational semantics. Afterwards, we define copattern coverage for Uroboro (\autoref{sec:cc}), which is analogous to coverage in functional programming languages with pattern matching. Then we show type soundness for Uroboro (\autoref{sec:urots}). We conclude the chapter by showing how the reduction semantics of Uroboro extends those of either the Data or Codata Fragment (\autoref{sec:codfragext}).

In the introduction, we have already shown example programs from the Data and Codata Fragments. Before we start with the definitions, we give an example Uroboro program, shown in \autoref{fig:ch2uroex}, that is neither in the Data nor in the Codata Fragments, i.e., it contains both data and codata types. We start with the example program for the Data Fragment of the introduction, which consisted of a data type for natural numbers and function definitions for addition and multiplication, and add (a) a codata type for infinite arrays, (b) a function that, given a natural number $n$, returns such an array with $n$ as its first element and all other elements $0$, and (c) a predicate that determines whether the input is $1$ (we use \texttt{Succ(Zero())} and \texttt{Zero()} and in the place of true and false, respectively). We will carry this example along in this chapter, and at the end we will have both de- and refunctionalized it to a semantically equivalent program.

\section{Notational preliminaries}
\label{sec:uronotp}

There is one notation that we will presuppose throughout the rest of this work: the Featherweight Java\cite{igarashi01featherweight} ``overbar'' syntax. It is a shorthand for lists of terms of parametrized length, otherwise usually denoted with ellipses. Consider the following example.
\[
fun(t_1, ..., t_n)
\]
Instead of this, we will sometimes write $fun(\overline{t})$. This ``overbar'' is to be understood as a shorthand for a list of some fixed but unknown length, say $n$, of instances of the expression under the bar. Precisely, for the positions $i$ where the instance actually appears in such a list (usually $i \in \{1, n\}$), the instance is defined as the entire expression indexed by $i$, i.e., this means that all variables in the expression, be they terms, names, or length parameters itself, are given an index $i$. This is always assumed to happen in such a way that all previously existing indices (including those produced by another ``overbar'') are preserved. We illustrate this with a slightly more complicated example.
\[
fun(\overline{con(\overline{t})})
\]
The ``overbars'' can be expanded step-by-step. First take the inner bar, over $t$, and expand it to a list of fixed but unknown length $n$ of indexed $t$s.
\[
fun(\overline{con(t_1, ..., t_n)})
\]
Next, take the remaining outer bar, and expand it to a list of fixed but unknown length $m$ of the entirely indexed expression under the bar; especially, $n$ is now also indexed as $n_1$ and $n_m$. Since there are now two different indices for the arguments of the $con_i$s, one is written as a superscript and the other as a subscript.
\[
fun(con_1(t^1_1, ..., t^1_{n_1}), ..., con_m(t^m_1, ..., t^m_{n_m}))
\]
We think that this notation is especially useful for such cases where length parameters themselves are indexed, like in the example above. In our opinion, as soon as one knows the meaning of the notation, an expression like $fun(\overline{con(\overline{t})})$ is not only shorter than its expanded form, but also easier to grasp. This is because we think that, unlike its expanded form, its meaning isn't obscured by a potentially confusing number of indices, where furthermore some depend on others.

\section{Syntax}
\label{sec:urosyn}

\begin{figure}
\begin{subfigure}{0.5\textwidth}
\begin{align*}
\sigma, \tau ~&= \textrm{type names}&\\
con ~&= \textrm{constructor names}&\\
des ~&= \textrm{destructor names}&\\
fun ~&= \textrm{function names}&\\
x, y ~&= \textrm{variable names}&\\
\end{align*}
\caption{Syntactic domains}
\label{fig:syndomain}
\end{subfigure}
~
\begin{subfigure}{0.5\textwidth}
\begin{align*}
s, t ~&::= x ~ | ~ fun(t^*) ~ | ~ con(t^*) ~ | ~ s.des(t^*) &\\
q ~&::= fun(p^*) ~ | ~ q.des(p^*) &\\
p ~&::= x ~ | ~ con(p^*) &
\end{align*}
\caption{Terms}
\label{fig:uroterms}
\end{subfigure}
\caption{Uroboro syntactic domains and terms}
\end{figure}

\begin{figure}
\begin{align*}
prg ~&::= (ddef ~ | ~ coddef ~ | ~  fdef)^* &\\
~\\
ddef ~&::= \textbf{data } \sigma \textbf{ where } csig^* &\\
csig ~&::= con(\tau^*): \tau &\\
~\\
coddef ~&::= \textbf{codata } \sigma \textbf{ where } dsig^* &\\
dsig ~&::= \sigma.des(\tau^*): \tau &\\
~\\
fdef ~&::= \textbf{function } fun(\tau^*): \tau \textbf{ where } eqn^* &\\
eqn ~&::= q = t &
\end{align*}
\caption{Uroboro programs and definitions}
\label{fig:uroprogdefs}
\end{figure}

We assume the domains of symbols presented in \autoref{fig:syndomain}. The \textit{terms} of Uroboro, as presented in \autoref{fig:uroterms}, are variables, and constructor calls, destructor calls, and function calls to lists of terms. The destructor call syntax is syntactical sugar for $des(s, t^*)$, meant to easier distinguish between the destructed (or observed) term and the other arguments of the destructor.\footnote{We will also combine this syntactical sugar with the overbar shorthand: $fun(...).\overline{des(...)}$ stands for the stacked destructor calls $fun(...).des_1(...).des_2(...)...des_n(...)$. In this case, the list separator for the list denoted by the overbar is the dot, instead of the comma.} A subset of terms is the set of copatterns, which we denote $\mathbf{Cop}$; a copattern is either a function call applied to patterns, or a destructor destructing another copattern and otherwise applied to patterns.

\textit{Programs} are defined to be sets of \textit{definitions}, the syntax rules for all of these are given in \autoref{fig:uroprogdefs}. A definition can either be a data type definition, a codata type definition, or a function definition. \textit{Data (type) definitions} consist of the name of the data type together with a set of constructor signatures. \textit{Codata (type) definitions} consist of the name of the codata type together with a set of destructor signatures. We assume all data and codata type definitions to be non-empty, i.e., they have at least one constructor or destructor signature, respectively. \textit{Function definitions} consist of the signature of the function together with a set of \textit{equations}. Equations have a left-hand side, which is a copattern, and a right-hand side, which is some term.

Note that we consider the collection of equations in a function definition to be a \textit{set}. This means that we establish no order on the equations. We don't consider order-dependent programs in this work; suffice it to say that a variant of Uroboro augmented with order would require a change to the semantics. In general, this is a problem not yet considered for languages with copattern matching; for instance, the language of Abel et al.\cite{abel13copatterns} also doesn't have an order on equations.

\section{Typing}
\label{sec:urostatsem}

\begin{figure}
\begin{prooftree}
\AxiomC{$``x : \tau" \in \Gamma$}
\RightLabel{Var}
\UnaryInfC{$\Gamma \vdash_{\Sigma} x : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Fun}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} fun(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Con}
\QuaternaryInfC{$\Gamma \vdash_{\Sigma} con(t_1, ..., t_n): \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} s : \sigma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t_1 : \tau_1$}
\AxiomC{...}
\AxiomC{$\Gamma \vdash_{\Sigma} t_n : \tau_n$}
\RightLabel{Des}
\QuinaryInfC{$\Gamma \vdash_{\Sigma} s.des(t_1, ..., t_n): \tau$}
\end{prooftree}
\caption{Type judgement for terms}
\label{fig:typjterm}
\end{figure}

%

\begin{figure}
\begin{prooftree}
\AxiomC{$\Sigma \vdash q : \tau; \Gamma$}
\AxiomC{$\Gamma \vdash_{\Sigma} t : \tau$}
\BinaryInfC{$\Sigma \vdash q = t \textrm{ ok}$}
\end{prooftree}
\caption{Well-typedness judgement for equations}
\label{fig:wtjteq}
\end{figure}

%

%\begin{figure}
%\begin{prooftree}
%\AxiomC{$``\sigma.des(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
%\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q), ~ q \vdash_{\Sigma} x : \sigma_x \} \vdash_{\Sigma} t : \tau$}
%\RightLabel{Des}
%\BinaryInfC{$\Sigma \vdash q'.des(p_1, ..., p_n) = t \textrm{ ok}$}
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$``fun(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
%\AxiomC{$\{ x : \sigma_x ~ | ~ x \in V(q), ~ q \vdash_{\Sigma} x : \sigma_x \} \vdash_{\Sigma} t : \tau$}
%\RightLabel{Fun}
%\BinaryInfC{$\Sigma \vdash fun(p_1, ..., p_n) = t \textrm{ ok}$}
%\end{prooftree}
%\caption{Well-typedness judgement for equations}
%\label{fig:wtjteq}
%\end{figure}

%

\begin{figure}
\begin{subfigure}{\textwidth}
\begin{prooftree}
\AxiomC{$`` fun(\tau_1, ..., \tau_n): \tau " \in \Sigma$}
\AxiomC{$\tau_1 \vdash_{\Sigma} p_1 : \Gamma_1$}
\AxiomC{...}
\AxiomC{$\tau_1 \vdash_{\Sigma} p_1 : \Gamma_1$}
\RightLabel{Fun}
\QuaternaryInfC{$\Sigma \vdash fun(p_1, ..., p_n) : \tau; \Gamma_1, ..., \Gamma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash q : \sigma; \Gamma$}
\AxiomC{$`` \sigma.des(\tau_1, ..., \tau_n): \tau " \in \Sigma$}
\AxiomC{$\tau_1 \vdash_{\Sigma} p_1 : \Gamma_1$}
\AxiomC{...}
\AxiomC{$\tau_1 \vdash_{\Sigma} p_1 : \Gamma_1$}
\RightLabel{Des}
\QuinaryInfC{$\Sigma \vdash q.des(p_1, ..., p_n) : \tau; \Gamma, \Gamma_1, ..., \Gamma_n$}
\end{prooftree}
\caption{Type inference in patterns}
\label{fig:typeinfjp}
\end{subfigure}
~\\
\begin{subfigure}{\textwidth}
\begin{prooftree}
\AxiomC{}
\RightLabel{Var}
\UnaryInfC{$\tau \vdash_{\Sigma} x : x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$`` con(\tau_1, ..., \tau_n): \tau " \in \Sigma$}
\AxiomC{$\tau_1 \vdash_{\Sigma} p_1 : \Gamma_1$}
\AxiomC{...}
\AxiomC{$\tau_n \vdash_{\Sigma} p_n : \Gamma_n$}
\RightLabel{Con}
\QuaternaryInfC{$\tau \vdash_{\Sigma} con(p_1, ..., p_n) : \Gamma_1, ..., \Gamma_n$}
\end{prooftree}
\caption{Type inference in copatterns}
\label{fig:typeinfjq}
\end{subfigure}

\caption{Type inference judgements}
\end{figure}

%

%\begin{figure}
%\begin{subfigure}{\textwidth}
%\begin{center}
%\AxiomC{$x = p_i$}
%\AxiomC{$``con(\tau_1, ..., \tau_n): \tau" \in \Sigma$}
%\RightLabel{Con\textsubscript{Var}}
%\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \tau_i$}
%\DisplayProof
%\AxiomC{$x \in V(p_i), x \neq p_i$}
%\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
%\RightLabel{Con\textsubscript{Con}}
%\BinaryInfC{$con(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
%\DisplayProof
%\end{center}
%\caption{Type inference in patterns}
%\label{fig:typeinfjp}
%\end{subfigure}
%~\\
%~\\
%\begin{subfigure}{\textwidth}
%\begin{prooftree}
%\AxiomC{$x \in V(p_i)$}
%\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
%\RightLabel{Fun}
%\BinaryInfC{$fun(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
%\end{prooftree}
%
%\begin{center}
%\AxiomC{$x \in V(p_i)$}
%\AxiomC{$p_i \vdash_{\Sigma} x : \sigma$}
%\RightLabel{Des\textsubscript{P}}
%\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
%\DisplayProof
%\AxiomC{$x \in V(q)$}
%\AxiomC{$q \vdash_{\Sigma} x : \sigma$}
%\RightLabel{Des\textsubscript{Q}}
%\BinaryInfC{$q.des(p_1, ..., p_n) \vdash_{\Sigma} x : \sigma$}
%\DisplayProof
%\end{center}
%\caption{Type inference in copatterns}
%\label{fig:typeinfjq}
%\end{subfigure}

%\caption{Type inference judgements}
%\end{figure}

As is the case with the copattern language of Abel et al.\cite{abel13copatterns}, there are two kinds of types in Uroboro. \textit{Positive types}, which are those defined by data type definitions, and \textit{negative types}, which are those defined by codata type definitions. Like Rendel et al. do for their fragments, we give a type judgement for terms, and one to judge whether equations are well-typed.  Like them, we let $\Sigma$ be the signatures of a program, that is, its function signatures, codata signatures, and data signatures, as defined above, and we let $\Gamma$ be a typing context, i.e., a set of type assignments to variables, and write
\begin{itemize}
\item $\Gamma \vdash_{\Sigma} t : \tau$ to mean that term $t$ is well-typed with type $\tau$ under typing context $\Gamma$ and signature $\Sigma$, and

\item $\Sigma \vdash eqn \textrm{ ok}$ to mean that equation $eqn$ is well-typed under signature $\Sigma$.
\end{itemize}
We give the rules for the type judgement for terms in \autoref{fig:typjterm}, which extend those of the Data and Codata Fragments. In fact, we simply combine the rules of the Data and Codata Fragments.

%In \autoref{fig:wtjteq}, we give the rules for the well-typedness judgement for equations, which generalize the rules for the Data and Codata Fragment. We write $V(q)$ to denote the variables occuring in $q$, and we use an auxiliary judgement, presented in \autoref{fig:typeinfjq}: $q \vdash_{\Sigma} x : \sigma$, for $x \in V(q)$,  means that, within copattern $q$, the variable has type $\sigma$ under signature $\Sigma$. To put it another way, this judgement is a type inference for variables. This judgement, in turn, uses an analogous judgement for patterns, presented in \autoref{fig:typeinfjp}.

In \autoref{fig:wtjteq}, we give the rules for the well-typedness judgement for equations, which generalize the rules for the Data and Codata Fragment. We use an auxiliary judgement, presented in \autoref{fig:typeinfjq}: $\Sigma \vdash q : \tau; \Gamma$ means that, under signature $\Sigma$, the variables within copattern $q$ have the types assigned to them in $\Gamma$. To put it another way, this judgement is a type inference for variables. This judgement, in turn, uses a type inference judgement for patterns, presented in \autoref{fig:typeinfjp}: $\tau \vdash_{\Sigma} p : \Gamma$ means that, under signature $\Sigma$, when $p$ is assumed to have type $\tau$, the variables within $p$ have the types assigned to them in $\Gamma$.

We say that a program with signatures $\Sigma$ is well-typed when it is $\Sigma \vdash eqn \textrm{ ok}$ for all equations $eqn$ of the program.

\section{Semantics}
\label{sec:urosos}

In this section, we formally define the semantics of Uroboro. We present them as small-step operational semantics. Before defining the reduction relation, a few other definitions are in order. In Uroboro, a reduction is a term rewriting that uses one of the equations of the program. Therefore, we need to define what it means for a term to match an lhs, that is, a copattern; we do so in \autoref{ssec:copm}. For languages with codata, there is a special notion of value; we define what values are in Uroboro in \autoref{ssec:val}. Then we define the reduction relation (\autoref{ssec:red}).

\subsection{Copattern matching}
\label{ssec:copm}

\begin{figure}
\begin{prooftree}
\AxiomC{}
\RightLabel{PM\textsubscript{Var}}
\UnaryInfC{$t =^? x \searrow t/x$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{PM\textsubscript{Con}}
\UnaryInfC{$con(t_1, ..., t_n) =^? con(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}
\caption{Pattern matching}
\label{fig:pm}
\end{figure}

\begin{figure}
\begin{prooftree}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{QM\textsubscript{App}}
\UnaryInfC{$fun(t_1, ..., t_n) =^? fun(p_1, ..., p_n) \searrow \sigma_1, ..., \sigma_n$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t =^? q \searrow \sigma$}
\AxiomC{$t_i =^? p_i \searrow \sigma_i ~ \forall i \in \{1, ..., n\}$}
\RightLabel{QM\textsubscript{Des}}
\BinaryInfC{$t.des(t_1, ...t_n) =^? q.des(p_1, ..., p_n) \searrow \sigma, \sigma_1, ..., \sigma_n$}
\end{prooftree}
\caption{Copattern matching}
\label{fig:copm}
\end{figure}

Here, we define what it means for a term to match a copattern. In short, a term $t$ matches a copattern $q$ when there is a substitution $\sigma$ such that $t = q[\sigma]$. We give a judgement for this, which orients itself on and borrows notations from Abel et al.\cite{abel13copatterns}, section 4. In order to do so, we also give an analogous judgement for patterns in \autoref{fig:pm}. In terms of the judgement for patterns, $t =^? p \searrow \sigma$ means that term t matches with pattern $p$ under substitution $\sigma$ (i.e. it is equivalent to $t = p[\sigma]$). The meaning of $t =^? q \searrow \sigma$, for copatterns $q$, is defined analogously in \autoref{fig:copm}.

\subsection{Values}
\label{ssec:val}

\begin{figure}
\begin{subfigure}{\textwidth}
\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Con/Mism}}
\UnaryInfC{$con(t_1, , ..., t_i, ..., t_n) \neq^? con(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$con \neq con'$}
\RightLabel{NPM\textsubscript{Con/Diff}}
\UnaryInfC{$con(t_1, , ..., t_n) \neq^? con'(p_1, ..., p_m)$}
\end{prooftree}
\caption{For patterns}
\label{fig:nmp}
\end{subfigure}
~\\
~\\
\begin{subfigure}{\textwidth}
\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{App/Mism}}
\UnaryInfC{$fun(t_1, ..., t_i, ..., t_n) \neq^? fun(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \neq fun'$}
\RightLabel{NPM\textsubscript{App/Diff}}
\UnaryInfC{$fun(t_1, ..., t_n) \neq^? fun'(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \neq^? q$}
\RightLabel{NPM\textsubscript{Des/Mism}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des(p_1, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_i \neq^? p_i$}
\RightLabel{NPM\textsubscript{Des/MismArgs}}
\UnaryInfC{$t.des(t_1, ..., t_i, ..., t_n) \neq^? q.des(p_1, ..., p_i, ..., p_n)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$des \neq des'$}
\RightLabel{NPM\textsubscript{Des/Diff}}
\UnaryInfC{$t.des(t_1, ..., t_n) \neq^? q.des'(p_1, ..., p_m)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff1}}
\UnaryInfC{$fun(...) \neq^? q.des(...)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{NPM\textsubscript{Diff2}}
\UnaryInfC{$t.des(...) \neq^? fun(...)$}
\end{prooftree}
\caption{For copatterns}
\label{fig:nmq}
\end{subfigure}

\caption{``No-match'' judgement}
\end{figure}

\begin{figure}
\begin{prooftree}
\AxiomC{$fun(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTFun}}
\QuaternaryInfC{$\vdash_v fun(t_1, ..., t_n)$, if $fun(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_0.des(t_1, ..., t_n) \neq^? q ~ \forall (q, t) \in \textrm{Rules}(prg)$}
\AxiomC{$\vdash_v t_0$}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{CodTDes}}
\QuinaryInfC{$\vdash_v t_0.des(t_1, ..., t_n)$, , if $t_0.des(t_1, ..., t_n)$ has codata type}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\vdash_v t_1$}
\AxiomC{...}
\AxiomC{$\vdash_v t_n$}
\RightLabel{V\textsubscript{Con}}
\TrinaryInfC{$\vdash_v con(t_1, ..., t_n)$}
\end{prooftree}
\caption{Value judgement}
\label{fig:valj}
\end{figure}

This section formalizes the notion of value for Uroboro. As is the case with the language of Abel et al.\cite{abel13copatterns}, whether a term is a value depends upon its type. Thus for the following judgement rules a type for every term will be presupposed.

$prg \vdash_v t$ means that the closed term $t$ is a value with respect to program $prg$. This notation is partially borrowed from Abel et al.\cite{abel13copatterns}, section 5. We omit the program whenever it is clear from the context or unimportant. Note that only closed terms are considered because only those are relevant for the semantics preservation.

The value judgement makes use of a ``no-match'' judgement, presented in \autoref{fig:nmq}. We write $t \neq^? q$ to mean that $t$ doesn't match $q$, i.e., it is $t \neq q[\sigma]$ for all substitutions $\sigma$. This judgement is complementary to the copattern matching judgement of the previous section. In order to define the rules of the ``no-match'' judgement for copatterns, as with the matching judgement, we give the rules of an analogous ``no-match'' judgement for patterns, presented in \autoref{fig:nmp}.

Finally, using this ``no-match'' judgement, we define the rules of the value judgement in figure \autoref{fig:valj} (always meant with respect to a program $prg$). As said above, this judgement also depends upon the type of the term. In short, a term is a value whenever it is a either (a) constructor applied to values, or (b) a function or destructor applied to values such that the return type of the function or destructor is a negative type, i.e., a type defined by a codata type definition.

\subsection{The reduction relation}
\label{ssec:red}

\begin{figure}
\begin{alignat*}{2}
& v  \in &&\textrm{Val} \\
& \mathcal{E} ::= ~&& [] ~ | ~ fun(v^*, \mathcal{E}, t^*) ~ | ~ con(v^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ v.des(v^*, \mathcal{E}, t^*)
\end{alignat*}
\caption{Uroboro evaluation contexts}
\label{fig:uroevalc}
\end{figure}

$\longrightarrow$ is the one-step reduction relation for closed terms, which is assumed to be used with respect to the rules $\textrm{Rules}(prg)$ of a program $prg$, where a rule $(q, t)$ consists of a copattern $q$ (left-hand side of the rule) and a term $t$ (right-hand side of the rule). The reduction depends upon a set of terms $\textrm{Val}$ which are considered to be values. Standardly, $\textrm{Val}$ is assumed to be the set of terms which are judged to be values by $\vdash_v t$. Sometimes, an alternative reduction judgement will be used, which will only differ in the underlying value set $\textrm{Val}$. This alternative reduction will then be defined by giving the alternative $\textrm{Val}$.

In figure \autoref{fig:uroevalc}, we define evaluation contexts for left-to-right, call-by-value evaluation. We let $\mathbf{EC}$ denote the set of evaluation contexts for the standard value judgement $\vdash'_v$, and we let $\mathbf{EC}[V]$ denote the set of evaluation contexts for other value sets (or their respective judgements).

Contraction $\mapsto$ of terms using equations is defined as follows.

\begin{center}
if the immediate subterms of $t$ are values:
\AxiomC{$t =^? q \searrow \sigma$ with $(q, t') \in \textrm{Rules}(prg)$}
\RightLabel{Subst}
\UnaryInfC{$t \mapsto t'[\sigma]$}
\DisplayProof
\end{center}

Finally, we define the actual reduction relation by a congruence rule.
\begin{prooftree}
\AxiomC{$t \mapsto t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[t] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

Write $\longrightarrow^=$ for the reflexive closure, $\longrightarrow^*$ for the reflexive and transitive closure of $\longrightarrow$. To make it clear that the reduction relation is meant with respect to a certain program $prg$, write $\longrightarrow^=_{prg}$, $\longrightarrow^*_{prg}$ and $\longrightarrow_{prg}$. When clear from the context or unimportant for the statement to make, this subscript will be omitted.

The well-known notions of \textit{context} and \textit{multi-hole context} are related to that of evaluation context. We will use them in some of the proofs of this work, and therefore give an Uroboro-specific definition for each of them here.

\begin{definition}[Context]
Contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun(t^*, \mathcal{E}, t^*) ~ | ~ con(t^*, \mathcal{E}, t^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des(t^*, \mathcal{E}, t^*)
\]
\end{definition}

\begin{definition}[Multi-hole context]
Multi-hole contexts are defined by the following EBNF rule.
\[
\mathcal{E} ::= [] ~ | ~ fun((\mathcal{E} ~ | ~ t)^*) ~ | ~ con((\mathcal{E} ~ | ~ t)^*) ~ | ~ \mathcal{E}.des(t^*) ~ | ~ t.des((\mathcal{E} ~ | ~ t)^*)
\]
\end{definition}

Concerning evaluation contexts and contexts, the following holds, which will be used in the proof of \autoref{lem:cdpaux}.

\begin{fact}
\label{fac:chp21}
For any two contexts $\mathcal{C}, \mathcal{C}_0$ and any evaluation context $\mathcal{E} \in \mathbf{EC}[V]$ for some set of values $V$:
\[
\mathcal{E} = \mathcal{C}[\mathcal{C}_0] \implies \mathcal{C} \in \mathbf{EC}[V].
\]
\end{fact}

\section{Copattern coverage}
\label{sec:cc}

\begin{figure}
\begin{prooftree}
\AxiomC{}
\RightLabel{C\textsubscript{Head}}
\UnaryInfC{$fun \lhd | (fun(\overline{x}))$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q^\tau)$}
\RightLabel{C\textsubscript{Des}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q.des(\overline{x^{des}}))_{des \in Dess_\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$fun \lhd | ~ Q ~ (q(x^\tau))$}
\RightLabel{C\textsubscript{Con}}
\UnaryInfC{$fun \lhd | ~ Q ~ (q[x \mapsto con(\overline{y^{con}})])_{con \in Cons_\tau}$}
\end{prooftree}
\caption{Copattern coverage}
\label{fig:cc}
\end{figure}

In general, when a language enjoys type soundness, for programs with \textit{coverage} it is guaranteed that no term is stuck. We adapt the judgement for \textit{copattern coverage} from Abel et al.\cite{abel13copatterns} for Uroboro. $fun \lhd | ~ Q$ means that the set of copatterns $Q$ \textit{covers} the function $fun$. Intuitively, when this set $Q$ is the set of left-hand sides of the function definition for $fun$, this function is fully specified. One can regard the consecutive application of the rules of the coverage judgement as a way of step-wise refining the specification of the function. The rule C\textsubscript{Head} stands for the start point, where the only left-hand side of the function neither has destructor nor constructor calls. The other two rules refine the specification of $fun$ by variable splitting (C\textsubscript{Con}), that is, refining based upon the input, or by result splitting (C\textsubscript{Des}), that is, refining based upon the output (or result). The terminology ``variable splitting'' and ``result splitting'' is also borrowed from Abel et al. and will become relevant in chapter 4.

These rules for the judgement are defined in \autoref{fig:cc}. We assume a program and write $Dess_\tau$ for the set of destructors for codata type $\tau$, and $Cons_\tau$ for the set of constructors for data type $\tau$. We also write $q^\tau$ and $x^\tau$ to indicate that the type of the copattern $q$ or the variable $x$, respectively, has been inferred to be $\tau$. \autoref{sec:urostatsem} provides a way to infer types for variables, the type of a copattern is found out by looking it up in the respective function or destructor signature.

A program has copattern coverage whenever all of its function definitions have coverage, that is, it is $fun \lhd | ~ Q$ for each function $fun$ and its set of left-hand sides $Q$.

In chapter 4, we will rely not only upon copattern coverage, but also on knowing how the coverage was derived by consecutive result and variable splitting. In other words, we need an algorithm for the judgement. Abel et al.\cite{abel13copatterns} hint, for their judgement, at a possible way to adapt other coverage algorithms for copatterns; to our knowledge, there currently is no such algorithm for copattern coverage checking, either by Abel et al. or others. For the time being, an exponential-time algorithm that goes through all derivation trees of a maximum depth will have to suffice. The maximum depth is the maximal number of constructors and destructors, added together, of all lhss of the function definition.

\section{Type soundness}
\label{sec:urots}

We show that Uroboro enjoys type-soundness. As usual, we do so by showing preservation and progress for the reduction relation $\longrightarrow$.\footnote{This approach was formulated by Wright and Felleisen\cite{wright94syntactic}; the terminology ``preservation'' and ``progress'' is due to Harper.} The notion of completeness used in the progress lemma is the copattern coverage defined in the previous section; the value notion is that of the judgement $\vdash_v$ defined in \autoref{ssec:val}.

\begin{lemma}[Type preservation]
If a program $prg$ with signatures $\Sigma$ is well-typed, the following holds for any two terms $s, t$: When $\vdash_{\Sigma} s : \tau$ and $s \longrightarrow_{prg} t$, then $\vdash_{\Sigma} t : \tau$.
\begin{proof}
From the derivation of $s \longrightarrow_{prg} t$ we know that there is an evaluation context $\mathcal{E}$ and terms $s_0, t_0$ such that $s = \mathcal{E}[s_0], t = \mathcal{E}[t_0]$ and $s_0 \mapsto t_0$. From the derivation of the contraction, we know that $s_0 = q_r[\sigma], t_0 = t_r[\sigma]$ for some equation $r$ of $prg$ and some $\sigma$.  By its derivation, we know that from $\vdash_{\Sigma} s : \tau$ it follows that $\vdash_{\Sigma} s_0 : \tau_0$ for some type $\tau_0$.

%Since $r$ is well-typed, it is $\Sigma \vdash q_r = t_r \textrm{ ok}$. From the derivation of the well-typedness of $r$ we know (a) that for each variable $x$ of $q_r$ there exists a $\tau_x$ such that $q_r \vdash_{\Sigma} x : \tau_x$ (type inference in $q_r$) and (b) that $\{ x : \tau_x ~ | ~ x \in V(q_r) \} \vdash_{\Sigma} t_r : \tau'$, with $\tau'$ being the return type of the function or destructor that $q_r$ is a call to. Since $s_0 = q_r[\sigma]$, by the derivation of $\vdash_{\Sigma} s_0 : \tau_0$ we know that $\tau' = \tau_0$. By induction on the derivation of $q_r \vdash_{\Sigma} x : \tau_x$ (the type inference for $x$ in $q_r$), using the fact that $\vdash_{\Sigma} q_r[\sigma]: \tau_0$, we can see that, for all variables $x$ of $q_r$, it is $\vdash_{\Sigma} \sigma(x) : \tau_x$. We combine this with $\{ x : \tau_x ~ | ~ x \in V(q_r) \} \vdash_{\Sigma} t_r : \tau_0$ to derive $\vdash_{\Sigma} t_r[\sigma] : \tau_0$. Using this, we derive $\vdash_{\Sigma} \mathcal{E}[t_r[\sigma]] : \tau$, which is the desired typing judgement.

Since $r$ is well-typed, it is $\Sigma \vdash q_r = t_r \textrm{ ok}$. From the derivation of the well-typedness of $r$ we know that $\Sigma \vdash q_r : \tau', \Gamma$ and $\Gamma \vdash_{\Sigma} t_r : \tau'$ for some typing context $\Gamma$, where $\tau'$ is the return type of the function or destructor that $q_r$ is a call to. Since $s_0 = q_r[\sigma]$, by the derivation of $\vdash_{\Sigma} s_0 : \tau_0$ we know that $\tau' = \tau_0$. By induction on the derivation of $\Sigma \vdash q_r : \tau_0, \Gamma$, using the fact that $\vdash_{\Sigma} q_r[\sigma] : \tau_0$, we can see that, for all variables $x$ of $q_r$, it is $\vdash_{\Sigma} \sigma(x) : \Gamma(x)$. Using this fact, by induction on the derivation of $\Gamma \vdash_{\Sigma} t_r : \tau_0$ we can derive $\vdash_{\Sigma} t_r[\sigma] : \tau_0$. Using this, we derive $\vdash_{\Sigma} \mathcal{E}[t_r[\sigma]] : \tau$, which is the desired typing judgement.
\end{proof}
\end{lemma}

\begin{lemma}[Progress]
If a program $prg$ with signatures $\Sigma$ is well-typed and has copattern coverage, any term with $\vdash_{\Sigma} t : \tau$ (especially: $t$ is closed) is either reducible, i.e., their exists a term $t'$ with $t \longrightarrow_{prg} t'$, or it is $\vdash_v t$.
\begin{proof}
Suppose that $t$ doesn't reduce, i.e., there is no term $t'$ with $t \longrightarrow_{prg} t'$. By induction on the structure of $t$ we show that in this case it is $\vdash_v t$.

Assume that for all subterms $t_0$ of $t$ it is $\vdash_v t_0$ (the induction hypothesis). If $t$ matched an lhs of $prg$, it would thus reduce (contract) using this equation, contrary to assumption. If the type $\tau$ of $t$ is a negative (codata) type, we have $\vdash_v t$ by either the rule V\textsubscript{CodTFun} or the rule V\textsubscript{CodTDes} of the value judgement, depending on whether $t$ is a function call or a destructor call. If $\tau$ is a positive (data) type, we distinguish two cases.
\begin{enumerate}
\item $t$ is a constructor call. Then we have $\vdash_v t$ by the V\textsubscript{Con} rule of the value judgement.

\item $t$ is a function or destructor call. Since $t$ doesn't match any lhs of $prg$, this contradicts the fact that $prg$ has copattern coverage. This is because coverage for the function definition of the function of $t$ can only be established when there is an lhs that $t$ itself matches, since (a) coverage cannot be established by result splitting, as $\tau$ is a positive type, and (b) all subterms of $t$ are values and thus don't match any lhs.
\end{enumerate}
\end{proof}
\end{lemma}

\section{As an extension of (Co)Data Fragment semantics}
\label{sec:codfragext}

To conclude this chapter, we show how Uroboro's semantics relate to those of either the Data Fragment or of the Codata Fragment. Assuming well-typedness and copattern coverage, Uroboro's notion of reducibility is a conservative extension of either the Data Fragment's notion (\autoref{ssec:df}) or the Codata Fragment's notion (\autoref{ssec:codf}). Note that, when the well-typedness and coverage conditions are dropped, Uroboro's reducibility notion is still a conservative extension of the Data Fragment's notion.

\subsection{Data Fragment}
\label{ssec:df}

The evaluation context $\mathcal{E}$ conservatively extends the context for the Data Fragment, as explained below. The common congruence rule for both of this and their Codata Fragment is used here, as well. As a result of this and of the pattern matching rules given above, the notion of reduction for Uroboro of this work is a conservative extension of their Data Fragment reduction.

$\mathcal{E}$ uses a different notion of evaluation context than the usual, in that values are not syntactic. Determining whether something is an evaluation context is nonetheless unproblematic, as one can simply use the value judgement from \autoref{ssec:val}.

This work's evaluation context conservatively extends that for the Data Fragment, since the value judgement conservatively extends the syntactic notion of value for the Data Fragment: For this fragment, the Con rule is identical to the syntax rule (Figure 6b of Rendel et al.\cite{rendel15automatic})
\[
u, v ::= con(v^*),
\]
while the V\textsubscript{CodTFun} can never be applied. This is because, in the Data Fragment, there are no codata type definitions.

\subsection{Codata Fragment}
\label{ssec:codf}

The Codata Fragment's evaluation context notion is conservatively extended by this work's, as well. And here again, this is why the notion of reduction for all of Uroboro conservatively extends that for the Codata Fragment.

As with the Data Fragment, this conservation for evaluation context notions follows from that of the value notions. In their value rule for the Codata Fragment, a term is a value if and only if it is a function application with argument values. We now show why the two directions of the equivalence hold for this work's value judgement, restricted to terms in the Codata Fragment, as well.

Consider first the ``if'' direction. By the rules of the judgement, a function application with argument values is only a value if it has codata type and doesn't match any rule of the program. Assuming well-typedness, the first constraint is always fulfilled in the Codata Fragment, since there, a type can only be added by a codata definition. The second constraint is always fulfilled because, in the Codata Fragment, there are no left-hand sides of rules which are hole patterns.

Second, consider the ``only if'' direction. By the rules of the judgement, a value $v$ can also be a destructor application if it has codata type and no subterm of it matches any lhs of the program. But this case can be excluded in the Codata Fragment for programs with copattern coverage, as follows. Since only lhss of the form $fun(\overline{x}).des(\overline{y})$ are allowed in this fragment, coverage for a function can only be established by an application of the C\textsubscript{Head} rule followed by one application of C\textsubscript{Des}. It follows that, for each function $fun$ defined the program, the function definition consists of lhss $fun(\overline{x}).des(\overline{y})$ for each destructor of the return type of $fun$. Thus, when $v$ is a destructor application, it must match an lhs of the respective function definition.
