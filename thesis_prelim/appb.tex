\chapter{Establishing order-independence}

Here, we consider the problem of making Uroboro programs independent of the order of their equations, as this order-independence is presupposed in our work. We don't actually solve this problem here, but we point to the problematic cases and give an idea how to possibly circumvent them. Basically, when equations do have an order, the contraction judgement needs to be changed such that only the first matched lhs can be used to contract the start term. We illustrate this with some examples; for all of these, we assume the following data and codata type definitions.

\begin{lstlisting}

data P where
  c1(): P
  c2(): P

codata N  where
  N.des1(): P
  N.des2(): P

\end{lstlisting}

The collection of equations in the function definition shown below is already order-independent, and nothing needs to be done for them.

\begin{lstlisting}

function fun(P): N where
  fun(c1()).des1() = c1()
  fun(c1()).des2() = c2()
  fun(c2()) = fun(c2())

\end{lstlisting}

An example for a collection of equations for \texttt{fun} that is not order-independent is the following.

\begin{lstlisting}

fun(x) = fun(c2())
fun(c1()).des1() = c1()
fun(c1()).des2() = c2()

\end{lstlisting}

A program that contains these equations depends upon an order given for them; without any order, the first and third, as well as the second and third, equations overlap. Under the order given here (from top to bottom), this program fragment is semantically equivalent to the order-independent program given below.

\begin{lstlisting}

fun(x) = fun(c2())

\end{lstlisting}

Why is this single equation equivalent to the three given above? Because the other two equations are unreachable. For instance, the term \texttt{fun(c1()).des1()} can contract using \texttt{fun(c1()).des1()}, but also using \texttt{fun(x)}, and this is placed before \texttt{fun(c1()).des1()}. In general, any term which could contract using one of \texttt{fun(c1()).des1() = c1()}  and \texttt{fun(c1()).des2() = c2()} already contracts using \texttt{fun(x)}. Thus, under this order, the lower two equations can simply be removed.

Now for a more problematic example. 

\begin{lstlisting}

fun(c1()).des1() = c1()
fun(c1()).des2() = c2()
fun(x) = fun(c2())

\end{lstlisting}

This collection of equations, ordered as given, has no direct order-independent equivalent. This is because, for instance, the term \texttt{fun(c1())} contracts using the third equation, while the term \texttt{fun(c1()).des1()} contracts using the first equation. That is, how the term contracts depends upon whether the destructor is present or not. The only way, that we know of, to transform this program into an order-independent equivalent, is to split the function definition into two and to also transform the terms. The resulting function definitions look as follows.

\begin{lstlisting}

function fun_1(P): N where
  fun_1(c1()).des1() = c1()
  fun_1(c1()).des2() = c2()
  fun_1(c2()) = fun_1(c2())

function fun_2(P): N where
  fun_2(x) = fun_2(c2())

\end{lstlisting}

Consider the terms for which their contraction depends upon the presence of destructors. The first function definition is responsible for such terms with destructors, the second function definition is responsible for those without destructor. Thus, along with the transformation for programs, terms are transformed, in two directions, according to the following relation.

\begin{align*}
& fun(t).des1() &\leftrightharpoons &fun\_1(t).des1() &\\
& fun(t).des2() &\leftrightharpoons &fun\_1(t).des2() &\\
& fun(t) &\leftrightharpoons &fun\_2(t) &
\end{align*}