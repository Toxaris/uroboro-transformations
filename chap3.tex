\chapter{Automatic de- and refunctionalization}

...

\section{Preliminaries}

\subsection{Notations used}

...

\subsection{Helper extraction}

...

\section{Common pretransformations}

...

\subsection{From order-dependent to order-independent}

...

\subsection{Aligning patterns}

...

\section{Overview of transformation steps}

Both de- and refunctionalization are made up of a couple of preprocessing steps, followed by the core de-/refunctionalization, which is essentially the transformation from the paper of Rendel et al.

Automatic defunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors.

\item Unmix function definitions.

\item Eliminate constructors from destructor copatterns.

\item Core defunctionalization.

\end{enumerate}

Automatic refunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors from copatterns containing constructors.

\item Unmix function definitions.

\item Eliminate constructors from destructor copatterns.

\item Eliminate multiple constructors.

\item Core refunctionalization.

\end{enumerate}

\section{Bisimulation}

For the core de- and refunctionalization, strong bisimulation holds, which will be proven in the respective section.

Each preprocessing step is defined as a recursive composition of one of the basic building blocks described in the next section. One such building block is an extraction function lifted to programs with $extract\_helpers$. For the lifted extraction function, a weak kind of bisimulation holds. Let angular brackets denote this transformation, and let $prg$ be the program to be transformed. When $prg$ has no overlapping lhss, it holds that:

\begin{itemize}
\item $s \longrightarrow_{prg} t \implies s  \longrightarrow^*_{\langle prg \rangle} \tilde{t}$ for a $\tilde{t} \sim t$ (1a)

\item for all terms $s'$ in the sequence of (1a), with the exception of the last ($t'$), it is $s \sim s'$ (1b)

\item if $s \not\sim t$: $s \longrightarrow_{\langle prg \rangle} t \implies \tilde{s} \longrightarrow_{prg} \tilde{t}$ for $\tilde{s} \sim s, \tilde{t} \sim t$ (2)

\end{itemize}

Here, $\sim$ is an equivalence relation; $s \sim t$ reads as: ``$s$ and $t$ represent the same `state' ''. The equivalence relation is specific to the respective extraction function: Given a function $\langle \cdot \rangle^{\sim}_{prg}$ returning an equivalent for copatterns, the equivalence relation is defined as the smallest congruence relation, with respect to the syntactic structure,\footnote{I.e., it is
\begin{itemize}

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $con(t_1, ..., t_n) \sim con(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $fun(t_1, ..., t_n) \sim fun(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{0, ..., n\}$: $t_0.des(t_1, ..., t_n) \sim \widetilde{t_0}.des(\widetilde{t_1}, ..., \widetilde{t_n})$ 

\end{itemize}} for which $q[\sigma] \sim \langle q \rangle^{\sim}_{prg}[\sigma]$ holds.

As proven in the propositions that follow, these weak bisimulation statements hold for all extraction functions that satisfy a number of properties defined below, simply called the \textit{extraction function properties}. Therefore, in its respective section, the bisimulation will be shown for an extraction function by showing that it satisfies these properties. For the bisimulation to hold at each step, it must also be the case that the step preserves the property that the program has no overlapping lhss. This will also be shown in the respective section of each building block.

\begin{definition}[Extraction function properties]
An extraction function $e$ is said to satisfy the extraction function properties iff:

\begin{enumerate}
\item $\forall r \not\in Rules(\langle prg \rangle): s \longrightarrow^{\textrm{Subst}_r}_{prg} t \implies s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \sim t$.

\item If $s$ reduces in $prg$, so does every $\widetilde{s} \sim s$ in $\langle prg \rangle$.

\item If $s$ is irreducible in $prg$, then there is a reduction sequence $s \longrightarrow^*_{\langle prg \rangle} s_v$, where $s \sim s_v$ is irreducible in $prg$.

\end{enumerate}

\end{definition}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties, and let $trans = extract\_helpers(e)$.

If the program $prg$ has no overlapping lhss, statements (1a) and (1b) hold for $trans$.

\begin{proof}

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$s =^? q_r \searrow \sigma$}
\RightLabel{\scriptsize Subst with $r \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow t_r[\sigma]$}
\end{prooftree}

with $t_r[\sigma] = t$; the reduction-relevant subterms of $s$ are values.

When $r$ is also an equation of $\langle prg \rangle$, it suffices to (a) by the third extraction function property, reduce the reduction-relevant subterms of $s$ to equivalent values, and then (b) apply the ``Subst" rule for $r$ to get a reduction to a term equivalent to $t$.

When, otherwise, $r$ is not an equation of $\langle prg \rangle$, we have the desired sequence by the first extraction function property.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s^0 \longrightarrow t^0$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0] \longrightarrow \mathcal{E}[t^0]$}
\end{prooftree}

with $\mathcal{E}[s^0] = s$ and $\mathcal{E}[t^0] = t$. By the induction hypothesis, we have a reduction sequence $s^0 \longrightarrow_{\langle prg \rangle} \widetilde{t^0} \sim t^0$.

It suffices to (a) by the third extraction function property, reduce the reduction-relevant subterms of $\mathcal{E}[s^0]$ left of $s^0$ to equivalent values, and then (b) use the ``Cong" rule, with the new context $\widetilde{\mathcal{E}}$ (around $s^0$) yielded by this, on the reduction sequence obtained from the induction hypothesis.

\end{enumerate}

\end{proof}

\end{proposition}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties, and let $trans = extract\_helpers(e)$.

If the program $prg$ has no overlapping lhss, statement (2) holds for $trans$.

\begin{proof} By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the reduction-relevant subterms of $s$ are values.

By the extraction function properties, since $s \not\sim t$, it can only be the case that $`` q = s' " = \zeta$ for the $\zeta$ in $\langle r \rangle^e$. Choose $\widetilde{s} := q_r[\sigma]$ and $\widetilde{t} := t_r[\sigma]$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$. Because $\mathcal{E}[s'] \not\sim \mathcal{E}[t']$, it follows that $s' \not\sim t'$.

By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. Apply the congruence rule to get the desired
\begin{equation*}
s = \mathcal{E}[s'] \sim \widetilde{\mathcal{E}}[\widetilde{s'}] \longrightarrow_{prg} \widetilde{\mathcal{E}}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
\end{equation*}
for an $\widetilde{\mathcal{E}} \sim \mathcal{E}$, that contains only names declared in $prg$ and which will now be constructed from $\mathcal{E}$ inductively.

\begin{itemize}

\item $\mathcal{E} = []$:

Define $\widetilde{\mathcal{E}} = \mathcal{E}$.

\item $\mathcal{E} = [].\overline{des(\overline{t})}$:

Define $\widetilde{\mathcal{E}} = [].\overline{des(\overline{\widetilde{t}})}$.

\item $\mathcal{E} = fun(\overline{v}, \mathcal{E}', \overline{t}).\overline{des(\overline{t'})}$, with $fun$ declared in $prg$:

We have $\widetilde{\mathcal{E}'}$ inductively, and can define: $\widetilde{\mathcal{E}} = fun(\overline{\widetilde{v}}, \mathcal{E}', \overline{\widetilde{t}}).\overline{des(\overline{\widetilde{t'}})}$.

\item $\mathcal{E} = fun(\overline{v}).\overline{des(\overline{v'})}.des'(\overline{v''}, \mathcal{E}', \overline{t}).\overline{des''(\overline{t'})}$, with $fun$ declared in $prg$:

Analogously to the previous case.

\item $\mathcal{E} = fun(\overline{v}, \mathcal{E}', \overline{t}).\overline{des(\overline{t'})}$, with $fun$ not declared in $prg$:

We have $\widetilde{\mathcal{E}'}$ inductively. Further, we know
\begin{equation*}
fun(\overline{v}, \mathcal{E}', \overline{t}) = fun(\overline{p}, \mathcal{E}', \overline{p'})[\sigma] = \langle q_{\mathcal{E}'} \rangle^{\sim}_{prg}[\sigma] \sim q_{\mathcal{E}'}[\widetilde{\sigma}]
\end{equation*}
for a $q$ with all names declared in $prg$, where $q_{\mathcal{E}'}$ stands for $q$ with the relevant pattern replaced by the context $\mathcal{E}'$. Thus we can define: $\widetilde{\mathcal{E}} = q[\widetilde{\sigma}].\overline{des(\overline{\widetilde{t'}})}$.

\item $\mathcal{E} = fun(\overline{v}).\overline{des(\overline{v'})}.des'(\overline{v''}, \mathcal{E}', \overline{t}).\overline{des''(\overline{t'})}$, with $fun$ not declared in $prg$:

Analogously to the previous case.

\end{itemize}

Here $\widetilde{t}$ for a term $t$ stands for a term that is equivalent in $t$ but has all of its names declared in $prg$. Such a term can be construed from $t$ analogously to how the evaluation context was constructed. When a term $v$ is a value in $\langle prg \rangle$, so is $\widetilde{v}$ by the second extraction function property. To see this, suppose $\widetilde{v} \sim v$ reduced in $prg$, then, by the property, so would $v$ in $\langle prg \rangle$, contrary to fact.

\end{enumerate}

\end{proof}

\end{proposition}

\section{Building blocks}

Each of the extraction functions defined below are lifted to programs with $extract\_helpers$ and then recursively composed to build the preprocessing steps of de- and refunctionalization.

\subsection{Destructor extraction}

\begin{figure}
\vspace{2.4in}
\begin{alignat*}{3}
& \langle `` q.des(\overline{p}) = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` q =  \langle q \rangle^{\sim}_{prg} ", \big\langle \langle q \rangle^{hsig}_{prg}, `` \langle q \rangle^{\sim}_{prg}.des(\overline{p}) = t  " \big\rangle \big\rangle \span\span \\
& \langle `` fun(\overline{p}) = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` fun(\overline{p}) = t " \big\rangle \span\span
\end{alignat*}
\caption{Extraction function $extract\_des$.}
\end{figure}

The destructor extraction function is called $extract\_des$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_des$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vars}),& \text{if $q.des(\overline{p})$ is a lhs in $prg$} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

Destructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_des$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. From the definition of $extract\_helpers$ and $extract\_des$ we thus know that $q_r$ is a destructor copattern. By inversion, we know the form of $s$ is $s^0.des(\overline{t})$ The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s^0_{subv}.des(\overline{t}) = q_{\epsilon_r}[\sigma_\epsilon].des(\overline{t})\\
&\longrightarrow &t_{\epsilon_r}.des(\overline{t})\\
&\longrightarrow^*  &t_{\epsilon_r}.des(\overline{t_v}) = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r} =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s^0$ to equivalent values. We have such a sequence by the third extraction property, because $s^0$ matches $q_{\epsilon_r}$, by the definition of $\epsilon_r$ and because $s = s^0.des(\overline{t})$ and $s$ matches $q_r$.

Similarly, the second multi-step part is concerned with reducing the $\overline{t}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.
\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s^0_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s^0_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0_{subv}] \longrightarrow \mathcal{E}[t_{\epsilon_r}[\sigma_\epsilon]]$}
\end{prooftree}
with $\mathcal{E} = [].des(\overline{t})$. $s^0_{subv}$ matches $q_{\epsilon_r}$ because $s = s^0.des(\overline{t})$ and $q_r = q_{\epsilon_r}.des(\overline{p})$ and $s$ matches $q_r$. The two sides of $\epsilon_r$ are equivalent by definition, thus $s^0_{subv}$ and $t_{\epsilon_r}[\sigma_\epsilon]$ are, too.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
The relevant subterms of $s^0_{subv}$ were values, thus also the terms that $\sigma_\epsilon$ substituted with. And $t_{\epsilon_r}[\sigma_\epsilon]$ contains no reduction-relevant subterms, as well. $t_[\epsilon_r]$ matches $q_{\zeta_r}$ by the definition of $\epsilon_r$ and $\zeta_r$. Because $t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\zeta]$ is equivalent to $s = q_r[\sigma]$, $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta] \sim t_r[\sigma_\zeta]$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle q \rangle^{\sim}_{prg}.\overline{des(\overline{p})}[\sigma],
\end{equation*}
for some $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has exactly one top-level destructor call ($des_1$).

If it has more than one top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a  possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

Finally, if $\widetilde{s}$ had no top-level destructor calls, i.e., it is an application of the helper function, then there would exist equations in $prg$ which overlap. To see this, consider the form of $s \sim \widetilde{s}$: It matches a $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, as stated above. But then $q$ and $q.des_1(\overline{p})$ overlap, contrary to assumption.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, some equations in $\langle prg \rangle$ result from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By definition, the two sides of $\epsilon_r$ are equivalent, and $\zeta_r$ is equivalent to the equation $r$ of $prg$, i.e., $q_{\zeta_r} \sim q_r$ and $t_{\zeta_r} \sim t_r$.

Suppose the lemma holds for the reduction-relevant subterms of $s$ (the induction hypothesis). This lets us reduce these subterms of $s$ to equivalent values (in $\langle prg \rangle$) first (from left to right). Let $s_0$ be the result of these reductions; it is equivalent to s. The desired reduction sequence is
\begin{equation*}
s \longrightarrow^* s_0 (\longrightarrow s_v).
\end{equation*}
The initial part of the reduction is derived as described above. The final step is only necessary if $s_0$ can still reduce in $\langle prg \rangle$. This can only be the case if it matches $q_{\epsilon_r}$, because (a) it can't match $q_{\zeta_r}$ since its function name isn't declared in $prg$, and (b) if it matched an unchanged equation of $prg$, it wouldn't be a value in $prg$. Thus, if at all, $s_0$ reduces by the ``Subst" rule for $\epsilon_r$ to a $s_v$; the two sides of $\epsilon_r$ are equivalent and therefore $s_0 \sim s_v$. $s_v$ can't reduce any further, because it is an instance of $t_{\epsilon_r}$, which has no destructor, and has a function name not declared in $prg$, and these functions only have definitions with destructor copattern lhss. If it doesn't reduce, set $s_v := s_0$.

\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that destructor extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_des$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since it doesn't touch patterns.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_des)}$.

\begin{proof}

An equation of $\langle prg \rangle$ is either taken over unchanged from $prg$, or it is one of $\epsilon_r, \zeta_r$ for an $r$ of $prg$. This means that the $\epsilon$ equations have to be compared with other $\epsilon$ equations, $\zeta$ with other $\zeta$, $\epsilon$ with unchanged. $\zeta$ equations needn't be compared with $\epsilon$ or unchanged equations, since the latter two have lhss with function names declared in $prg$, while the function name of the lhs of the $\zeta$ equation is fresh in $prg$. Any two unchanged equations also needn't be compared, since we already know they don't overlap.

First, compare any two $\epsilon$ equations. Their immediate prefixes are lhss in $prg$, thus if the $\epsilon$ equations overlapped, so would two lhss in $prg$. But we know that they don't.

Second, compare any two $\zeta$ equations. By their definition, they can only overlap if the equations they are generated from overlap, which we know they don't.

Third, compare an $\epsilon$ equation with an unchanged equation. All equations $r$ which are transformed to a pair of equations $\epsilon_r, \zeta_r$ have the same number of destructors. Because of $align\_patterns$, their immediate prefixes also have the same level of pattern specification. Thus, if the $\epsilon$ equations overlap, their lhss are the same. By their definition, the right-hand sides are identical, as well, thus the two $\epsilon$ equations are one and the same.

\end{proof}

\end{lemma}

\subsection{Constructor extraction}

\begin{figure}
\vspace{2.4in}
\[
    \langle `` q = t " \rangle^{extract\_des}_{prg} =\\
\begin{cases}
    \big\langle `` q^{-con} =  \langle q \rangle^{\sim}_{prg} ", \big\langle \langle q \rangle^{hsig}_{prg}, `` \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^-}) = t  " \big\rangle \big\rangle,& \text{if $q$ contains a constructor other than a left outer-most} \\
   \big\langle `` fun(\overline{p}) = t " \big\rangle,& \text{otherwise}
\end{cases}
\]
\caption{Extraction function $extract\_con$.}
\end{figure}

The constructor extraction function is called $extract\_con$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \langle q^{-con} \rangle^{name\_pattern}, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q^{-con}_{vars^+} \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_con$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^+}),& \text{if $q$ contains a constructor other than a left outer-most} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

Constructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_con$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by the third extraction function property.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}[\sigma_\epsilon]$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with one pattern replaced by a variable and put in front of the other patterns. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with the variable in front replaced by the respective pattern of $q_r$ (that, in $q_{\epsilon_r}$, was replaced by a variable and put in front). $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_con$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle q \rangle^{\sim}_{prg}.\overline{des(\overline{p})}[\sigma],
\end{equation*}
for some $q_r$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_con$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, some equations in $\langle prg \rangle$ result from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By definition, the lhs of $\epsilon_r$ appears in $prg$ with one variable replaced by a constructor, and the lhs of $\zeta_r$ has a function name undeclared in $prg$.

This means that a term $t$ with all of its names declared in $prg$ can't reduce by a $\zeta_r$ equation. It also can't reduce by an equation that is taken over unchanged from $prg$, because then it would also reduce in $prg$.

The only kind of equation that remains is an $\epsilon_r$. Suppose $t$ reduces by this equation; by definition, the result $\widetilde{t}$ is equivalent to $t$. It can't reduce further. To see this, first note that there is an equation $r$ such that $q_{\epsilon_r}$ is $q_r$ with one constructor replaced by a variable. We know $t$ doesn't reduce by $r$ in $prg$. By definition, there thus also cannot be a $\zeta_r$ by which $\widetilde{t}$ reduces. But all equations of kind $\epsilon$ of taken over unchanged from $prg$ have a function name declared in $prg$, unlike $\widetilde{t}$.

\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that constructor extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_con$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since patterns are either not touched or uniformly replaced by variables.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_des)}$.

\begin{proof}

An equation of $\langle prg \rangle$ is either taken over unchanged from $prg$, or it is one of $\epsilon_r, \zeta_r$ for an $r$ of $prg$. This means that the $\epsilon$ equations have to be compared with other $\epsilon$ equations, $\zeta$ with other $\zeta$, $\epsilon$ with unchanged. $\zeta$ equations needn't be compared with $\epsilon$ or unchanged equations, since the latter two have lhss with function names declared in $prg$, while the function name of the lhs of the $\zeta$ equation is fresh in $prg$. Any two unchanged equations also needn't be compared, since we already know they don't overlap.

First, compare any two $\epsilon$ equations. In $prg$, there are two lhss that are these equations' lhss with one variable replaced by a constructor pattern. Thus, if the $\epsilon$ equations overlapped, so would these two lhss in $prg$. But we know that they don't.

Second, compare any two $\zeta$ equations. By their definition, they can only overlap if the equations they are generated from overlap, which we know they don't.

Third, compare an $\epsilon$ equation with an unchanged equation. The only transformed equations have no destructors on their lhs. The domain of this transformation only has unmixed function definitions. It follows that, if $\epsilon$ overlapped with an unchanged equation, the latter has no destructors, too. Since the extracted constructor is further right than the right-most constructor in the unchanged equation, the unchanged equation and the equation that $\epsilon$ was extracted out of would overlap, which we know they don't.

\end{proof}

\end{lemma}

\subsection{Extraction of all constructors from a single-destructor copattern}

\begin{figure}
\vspace{2.4in}
\[
    \langle `` fun(\overline{p}).des(\overline{p'}) = t " \rangle^{extract\_des}_{prg} =\\
\begin{cases}
    \big\langle `` fun(\overline{x}).des(\overline{x'}) =  \langle fun(\overline{x}).des(\overline{x'}) \rangle^{\sim}_{prg} ", \big\langle \langle fun, des \rangle^{hsig}_{prg}, `` \langle fun, des \rangle^{hname}_{prg}(\overline{p}, \overline{p'}) = t  " \big\rangle \big\rangle,& \text{if one of the $\overline{p}$ or $\overline{p'}$ is a constructor pattern} \\
   \big\langle `` fun(\overline{p}).des(\overline{p'}) = t " \big\rangle,& \text{otherwise}
\end{cases}
\]
\caption{Extraction function $extract\_patterns$.}
\end{figure}

The extraction function that extracts all constructors from a single-destructor copattern is called $extract\_patterns$ and defined in Figure 3-3. The definition uses functions defined in the next paragraph.

For each function $fun$, destructor $des$, and program $prg$, define the helper function name
\begin{equation*}
\langle fun, des \rangle^{hname}_{prg} := \langle fun, des, prg \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle fun, des \rangle^{hsig}_{prg} := \langle fun, des \rangle^{hname}_{prg}(\langle fun \rangle^{argtypes}_{prg}, \langle des \rangle^{argtypes}_{prg}): \langle des \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_patterns$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle fun, des \rangle^{hname}_{prg}(\overline{x}, \overline{x'}),& \text{if } q = fun(\overline{x}).des(\overline{x'}) \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

\subsubsection{Proofs of extraction function properties}

This extraction function satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_patterns$ satisfies the first extraction function property.

\begin{proof}

We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s_{subv} = q_{\epsilon_r}[\sigma_\epsilon]\\
&\longrightarrow &t_{\epsilon_r}\\
&\longrightarrow^*  &(t_{\epsilon_r}[\sigma_\epsilon])_{subv} = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r}[\sigma_\zeta] =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s$ to equivalent values. We have such a sequence by the third extraction function property.

Similarly, the second multi-step part is concerned with reducing the reduction-relevant subterms of $t_{\epsilon_r}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.

\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\end{prooftree}
$s_{subv}$ matches $q_{\epsilon_r}$ because $s$ matches $q_r$ and $q_{\epsilon_r}$ is simply $q_r$ with all patterns replaced by variables. $s_{subv}$ is equivalent to $t_{\epsilon_r}$, because, by definition, the two sides of $\epsilon_r$ are equivalent.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$(t_{\epsilon_r}[\sigma_\epsilon])_{subv} \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
$(t_{\epsilon_r}[\sigma_\epsilon])_{subv}$ matches $q_{\zeta_r}$ because $q_{\zeta_r}$ is simply $t_{\epsilon_r}$ with all variables replaced by the patterns of $q_r$. $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta]$ because $t_{\zeta_r} \sim t_r$ and $q[\sigma] \sim t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\epsilon]$ and $q_r \sim q_{\zeta_r}$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_patterns$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle fun, \overline{des}, prg \rangle^{autogen}(\overline{x}, \overline{x'})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q_r = fun(\overline{x}.\overline{des(\overline{x'})}$ that is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has no top-level destructor calls.

If it has one or more top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_patterns$ satisfies the third extraction function property.

\begin{proof}



\end{proof}

\end{lemma}

\subsubsection{Proof of ``no overlap" preservation}

Finally, it is proven that this extraction preserves the property that the program has no overlapping lhss. For this, note that $extract\_patterns$ also preserves the ``alignment of patterns'' property that $align\_patterns$ establishes, since patterns are either not touched or uniformly replaced by variables.

\begin{lemma}

If $prg$ has no overlapping lhss, neither has $\langle prg \rangle := \langle prg \rangle^{extract\_helpers(extract\_patterns)}$.

\begin{proof}

\end{proof}

\end{lemma}

\section{Core de- and refunctionalization}

\subsection{Core defunctionalization}

...

\subsubsection{Proof of strong bisimulation}

For the actual defunctionalization, $d''$, strong bisimulation holds. The proof relies on properties of the automatic defunctionalization of Uroboro in the paper of Rendel et al., in here called $d^{core}$. As stated in section 2.3.1, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $d^{core}$, the Codata Fragment, and, analogously, when restricted to the domain of their refunctionalization, the Data Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $d^{core}$.

\begin{proof}[Proof of strong bisimulation for $d''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is hole pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$). Such equations (and indeed the function definitions) are left unchanged by $d''$ except for defunctionalizing the right-hand term, as can be seen directly in the definition of $d''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

By inversion, we have from $s =^? q \searrow \sigma$ that $s$ has the form $fun(v_1, ..., v_n)$ for some values $v_1, ..., v_n$, thus $\langle s \rangle = fun(\langle v_1 \rangle, ..., \langle v_n \rangle)$. By inversion for values, we have that each $v_i$ is either a constructor application or a value of codata type. If it is a value of codata type, by inversion on pattern matching, the relevant subpattern of $q$ can only be a variable, thus it is also matched by $\langle v_i \rangle$. If it is a constructor application, the relevant subpattern of $q$ is either a variable, and the same holds, or it is a constructor pattern, and by recursively descending into its subpatterns we still get that $\langle v_i \rangle = con(\langle v^1_i \rangle, ..., \langle v^m_n \rangle)$ matches against the subpattern of $q$.

By carrying the substitutions returned from the matchings along in the above recursive argument, we get a substitution $\sigma'$ such that $\langle s \rangle =^? q \searrow \sigma'$ and, by distributing over $\langle s' \rangle$, $\langle s' \rangle [\sigma'] = \langle s'[\sigma] \rangle = \langle t \rangle$. It follows that $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\item \underline{Case 2}: $q = fun(p_1, ..., p_n).des(p'_1, ..., p'_k)$:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $d''$). Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $d^{core}$, as specified in the definition of $d''$. Let this part, amended by the ``constructor subsumption" noted for the definition of $d''$, be $prg'$; it is: $s \longrightarrow_{prg'} t$

By (*) we would have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. 

For the coverage, bear in mind that the equation $`` q = s' "$ enabling the reduction of $s$ by the ``Subst" rule is part of $prg'$ by the precondition of Case 2. As $s$ matches against $q$, copattern coverage for $s$ is trivially fulfilled in $prg'$. The immediate subterms of $s$ are values with respect to $prg$ and, by inversion, their immediate subterms and so forth, which especially means that there is no rule in $prg$ against which they match. But $prg$ has copattern coverage for such a subterm (TODO: make this a general precondition) and there is already no rule for it in $prg$. It follows that $prg'$ still has copattern coverage for the subterm even though there is no rule for it in $prg'$. This is because, either (1) the subterm is a destructor call, then it can only be covered by destructor copatterns (as it matches against a destructor copattern) and those only occur within $prg'$, or (2) it is a constructor call, which doesn't need to be matched for coverage. It can't be a function call, since these can only be covered by directly matching the call, which isn't the case even in $prg$, for which coverage is assumed. Thus coverage holds for $prg'$.

For well-typedness, simply treat the missing types temporarily, that is, for the sake of (*), as codata types. This is no problem for the restriction to the domain of $d^{core}$, since such types could be introduced inside the Codata Fragment with codata definitions. To be more precise, empty function definitions can be added for missing ones and empty codata definitions for missing types, and removed again after using (*), without adding or removing possible reductions, respectively. All in all, we have by (*):
\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle
\end{equation*}

But this program $\langle prg' \rangle^{d^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $d''$. This implies the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

Other cases are excluded by the relevant input fragment.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$.

By the induction hypothesis we have $\langle s' \rangle \longrightarrow_{\langle prg \rangle} \langle t' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$, defined analogously to the transformation of terms by transforming the terms in $\mathcal{E}$ and by setting $\langle [] \rangle = []$. By applying the congruence rule we get $\langle \mathcal{E} \rangle[\langle s' \rangle] \longrightarrow_{\langle prg \rangle} \langle \mathcal{E} \rangle[\langle t' \rangle]$. It is clear that $\langle \mathcal{E} \rangle[\langle s' \rangle] = \langle \mathcal{E}[s'] \rangle = \langle s \rangle$ and $\langle \mathcal{E} \rangle[\langle t' \rangle] = \langle \mathcal{E}[t'] \rangle = \langle t \rangle$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^d$, $\langle t \rangle = \langle t \rangle^d$. $d$ is the defunctionalization of terms defined at the end of section 2. This defunctionalization of terms is also, for all input terms from the fragment, identical to that of the Codata Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part of $prg$, as specified in the definition of $d''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $d''$, this other part is taken over unchanged from $prg$ except for defunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $d^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle$.

By (*) we would have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle prg' \rangle^{d^{core}}} \langle t \rangle \iff s \longrightarrow_{prg'} t,
\end{equation*}

were $prg'$ a well-typed program with copattern coverage for all subterms of $s$. Both of those properties can be shown or simulated similarly to the way they are in the $`` \Rightarrow "$ part.

But it is $prg' \subseteq prg$, as can be seen in the definition of $d''$. This implies the desired $s \longrightarrow_{prg} t$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = \langle s \rangle$ and $\mathcal{E}[t'] = \langle t \rangle$.

By the induction hypothesis we have $s'' \longrightarrow_{prg} t''$ with $s' = \langle s'' \rangle$, $t' = \langle t'' \rangle$. Let $\langle \mathcal{E} \rangle$ denote the transformation of $\mathcal{E}$ (defined as in the $`` \Rightarrow "$ part). Apply the congruence rule to get $\mathcal{E}'[s''] \longrightarrow_{prg} \mathcal{E}'[t'']$ with $\mathcal{E} = \langle \mathcal{E}' \rangle$. That is, $\mathcal{E}'$ is the result of applying the inverse of $\langle \cdot \rangle$ to $\mathcal{E}$, which is possible, since, for instance, $\mathcal{E}[s'] = \langle s \rangle$. It is $\langle \mathcal{E}'[s''] \rangle = \langle \mathcal{E}' \rangle[\langle s'' \rangle] = \mathcal{E}[s'] = \langle s \rangle$ and $\langle \mathcal{E}'[t''] \rangle = \langle \mathcal{E}' \rangle[\langle t'' \rangle] = \mathcal{E}[t'] = \langle t \rangle$ and thus we have the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\end{proof}

\subsection{Core refunctionalization}

...

\subsubsection{Proof of strong bisimulation}

For the actual refunctionalization, $r''$, strong bisimulation holds. The proof relies on properties of the automatic refunctionalization of Uroboro in the paper of Rendel et al., in here called $r^{core}$. As stated in section 2.3.1, the authors' notion of reducibility is the same than that of this work when restricted to the domain of $r^{core}$, the Data Fragment, and, analogously, when restricted to the domain of their defunctionalization, the Codata Fragment.

In section 3 of their paper, they prove Lemma 5, which in terms of this work can be stated as follows (possible since the reducibility notions are identical):

$s \longrightarrow_{prg} t \iff \langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$ for all input terms $s,t$ of $\langle \cdot \rangle$ (*)

Here, the angular brackets can stand for either of their transformations, refunctionalization and defunctionalization. Statement (*) is exactly the strong bisimulation statement above, thus strong bisimulation holds for $r^{core}$.

\begin{proof}[Proof of strong bisimulation for $r''$] ~

$`` \Rightarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$s =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the immediate subterms of $s$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2 (it is omitted that $prg$ is passed to $r$ as well). This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

\begin{itemize}

\item \underline{Case 1}: $q$ is destructor pattern:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a destructor pattern (other cases are excluded by the relevant input fragment for $r''$). Such equations (and indeed the function definitions) are left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Thus Rules($\langle prg \rangle$) contains $(q, \langle s' \rangle)$.

From here, the argument proceeds analogously to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

\item \underline{Case 2}: $q$ is hole pattern without arguments or where the first argument has codata type:

Then the equation is left unchanged by $r''$ except for refunctionalizing the right-hand term, as can be seen directly in the definition of $r''$ (last set in the highest-level union). Proceed as in Case 1.

\item \underline{Case 3}: $q$ is hole pattern and has a first argument with data type:

Then the function definition that contains $`` q = s' "$ contains only equations where the left-hand side is a hole pattern (other cases are excluded by the relevant input fragment for $d''$), and it has a first argument with data type. Thus $s$ reduces to $t$ already with respect to the part of the program that is passed to $des\_conv$, and then the result of this to $r^{core}$, as specified in the definition of $r''$. Let the part passed to $des\_conv$ be $prg'$; it is: $s \longrightarrow_{prg'} t$.

By (*) we have

\begin{equation*}
s \longrightarrow_{prg'} t \iff \langle s \rangle \longrightarrow_{\langle prg' \rangle^{r^{core}}} \langle t \rangle,
\end{equation*}

But this program $\langle prg' \rangle^{r^{core}}$ is a subset of $\langle prg \rangle$, as can be seen in the definition of $r''$. Thus we have the desired $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$.

\end{itemize}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{enumerate}

$`` \Leftarrow "$: By induction on the structure of $\mathcal{D}$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\mathcal{D}_{\textrm{PM}}$}
\UnaryInfC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$\langle s \rangle \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = \langle t \rangle$; the immediate subterms of $\langle s \rangle$ are values; $\mathcal{D}_{\textrm{PM}}$ is a derivation of the pattern matching. This transformation changes input terms, thus $\langle s \rangle = \langle s \rangle^r$, $\langle t \rangle = \langle t \rangle^r$. $r$ is the refunctionalization of terms defined at the end of section 2. This refunctionalization of terms is also, for all input terms from the fragment, identical to that of the Data Fragment.

The equation $`` q = s' "$ can either be contained in that part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part of $prg$, as specified in the definition of $r''$, or it can be in the other part of $\langle prg \rangle$. As can be seen in the definition of $r''$, this other part is taken over unchanged from $prg$ except for refunctionalizing the right-hand terms. Thus for an equation $`` q = s' "$ from this part, the equation $`` q = s'' "$ with $s' = \langle s'' \rangle$ is present in $prg$. For such an equation, $q$ has hole pattern. It can then be easily seen that $s =^? q \searrow \sigma'$ for a $\sigma'$ with $s''[\sigma'] = t$ by an argument analogous to that of $`` \Rightarrow "$, ``Subst" case, Case 1, in the proof for $d''$.

Now, suppose that $`` q = s' "$ is contained in the part of $\langle prg \rangle$ that results from the application of $des\_conv$ and then $r^{core}$ to the relevant part $prg' \subseteq prg$. Thus $\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle$.

By (*) we have

\begin{equation*}
\langle s \rangle \longrightarrow_{\langle \langle prg' \rangle^{des\_conv} \rangle^{r^{core}}} \langle t \rangle \iff s \longrightarrow_{\langle prg' \rangle^{des\_conv}} t.
\end{equation*}

In the result of $des\_conv$, no new matching left-hand sides are added. That is, $prg'$ contains at least all the matching left-hand sides that $\langle prg' \rangle^{des\_conv}$ has. Thus any reduction that is possible with respect to $\langle prg' \rangle^{des\_conv}$ is already possible with respect to $prg'$.

But it is $prg' \subseteq prg$, as can be seen in the definition of $r''$. This implies the desired $s \longrightarrow_{prg} t$.
\end{enumerate}

\item \textbf{``Cong" case}:

The argument here is identical to that of this case of this direction in the proof for $d''$.

\end{proof}
