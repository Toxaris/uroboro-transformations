\chapter{Automatic de- and refunctionalization}

...

\section{Overview and preliminaries}

Both de- and refunctionalization are made up of a couple of preprocessing steps, followed by the core de-/refunctionalization, which is essentially the transformation from the paper of Rendel et al.

Automatic defunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors.

\item Unmix function definitions.

\item Eliminate constructors from destructor copatterns.

\item Core defunctionalization.

\end{enumerate}

Automatic refunctionalization consists of the following steps:
\begin{enumerate}
\item Eliminate multiple destructors from copatterns containing constructors.

\item Unmix function definitions.

\item Eliminate constructors from destructor copatterns.

\item Eliminate multiple constructors.

\item Core refunctionalization.

\end{enumerate}

For the core de- and refunctionalization, strong bisimulation holds, which will be proven in the respective section.

For each of the preprocessing steps, a kind of weak bisimulation holds. Let angular brackets denote the transformation, and let $prg$ be any program to be transformed. It holds that:

\begin{itemize}
\item $s \longrightarrow_{prg} t \implies s  \longrightarrow^*_{\langle prg \rangle} \tilde{t}$ for a $\tilde{t} \sim t$ (1a)

\item for all terms $s'$ in the sequence of (1a), with the exception of the last ($t'$), it is $s \sim s'$ (1b)

\item if $s \not\sim t$: $s \longrightarrow_{\langle prg \rangle} t \implies \tilde{s} \longrightarrow_{prg} \tilde{t}$ for $\tilde{s} \sim s, \tilde{t} \sim t$ (2)

\end{itemize}

Here, $\sim$ is an equivalence relation; $s \sim t$ reads as: ``$s$ and $t$ represent the same `state' ''. The equivalence relation is specific to the respective extraction function: Given a function $\langle \cdot \rangle^{\sim}_{prg}$ returning an equivalent for copatterns, the equivalence relation is defined as the smallest congruence relation, with respect to the syntactic structure,\footnote{I.e., it is
\begin{itemize}

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $con(t_1, ..., t_n) \sim con(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{1, ..., n\}$: $fun(t_1, ..., t_n) \sim fun(\widetilde{t_1}, ..., \widetilde{t_n})$

\item If $t_i \sim \widetilde{t_i}$ for $i \in \{0, ..., n\}$: $t_0.des(t_1, ..., t_n) \sim \widetilde{t_0}.des(\widetilde{t_1}, ..., \widetilde{t_n})$ 

\end{itemize}} for which $q[\sigma] \sim \langle q \rangle^{\sim}_{prg}[\sigma]$ holds.

Each preprocessing step is defined as a recursive composition of one of the basic building blocks described in the next section. That weak bisimulation holds for the step is therefore shown by showing it that, for the lifted extraction function $e$ that serves as the building block, the following statements hold. Write $\langle prg \rangle$ for $\langle prg \rangle^{extract\_helpers(e)}$ and $prg^0$ for the original program that is the input of the entire transformation step.

\begin{itemize}
\item For $s,t$ with names declared in $prg^0$: $s \longrightarrow_{prg} t \implies s  \longrightarrow^*_{\langle prg \rangle} \tilde{t}$ for a $\tilde{t} \sim t$ (1a)

\item for all terms $s'$ in the sequence of (1a), with the exception of the last ($t'$), it is $s \sim s'$ (1b)

\item For $s,t$ with $s$ equivalent to a term with names declared in $prg^0$ and $s \not\sim t$: $s \longrightarrow_{\langle prg \rangle} t \implies \tilde{s} \longrightarrow_{prg} \tilde{t}$ for $\tilde{s} \sim s, \tilde{t} \sim t$ (2)

\end{itemize}

As proven in the propositions that follow, these weak bisimulation statements hold for all extraction functions that satisfy a number of properties defined below, simply called the \textit{extraction function properties}. Therefore, in its respective section, the bisimulation will be shown for an extraction function by showing that it satisfies these properties.

\begin{definition}[Extraction function properties]
An extraction function $e$ is said to satisfy the extraction function properties iff, for $s$ with names declared in $prg^0$:

\begin{enumerate}
\item $\forall r \not\in Rules(\langle prg \rangle): s \longrightarrow^{\textrm{Subst}_r}_{prg} t \implies s \longrightarrow^*_{\langle prg \rangle} \widetilde{t} \sim t$.

\item If $s$ reduces in $prg$, so does every $\widetilde{s} \sim s$ in $\langle prg \rangle$.

\item If $s$ is irreducible in $prg$, then there is a reduction sequence $s \longrightarrow^*_{\langle prg \rangle} s_v$, where $s \sim s_v$ is irreducible in $prg$.

\end{enumerate}

\end{definition}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties, and let $trans = extract\_helpers(e)$.

If the program $prg$ has no overlapping lhss, statements (1a) and (1b) hold for $trans$.

\begin{proof}

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$s =^? q_r \searrow \sigma$}
\RightLabel{\scriptsize Subst with $r \in \textrm{Rules}(prg)$}
\UnaryInfC{$s \longrightarrow t_r[\sigma]$}
\end{prooftree}

with $t_r[\sigma] = t$; the reduction-relevant subterms of $s$ are values.

When $r$ is also an equation of $\langle prg \rangle$, it suffices to (a) by the third extraction function property, reduce the reduction-relevant subterms of $s$ to equivalent values, and then (b) apply the ``Subst" rule for $r$ to get a reduction to a term equivalent to $t$.

When, otherwise, $r$ is not an equation of $\langle prg \rangle$, we have the desired sequence by the first extraction function property.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s^0 \longrightarrow t^0$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0] \longrightarrow \mathcal{E}[t^0]$}
\end{prooftree}

with $\mathcal{E}[s^0] = s$ and $\mathcal{E}[t^0] = t$. By the induction hypothesis, we have a reduction sequence $s^0 \longrightarrow_{\langle prg \rangle} \widetilde{t^0} \sim t^0$.

It suffices to (a) by the third extraction function property, reduce the reduction-relevant subterms of $\mathcal{E}[s^0]$ left of $s^0$ to equivalent values, and then (b) use the ``Cong" rule, with the new context $\widetilde{\mathcal{E}}$ (around $s^0$) yielded by this, on the reduction sequence obtained from the induction hypothesis.

\end{enumerate}

\end{proof}

\end{proposition}

\begin{proposition}

Let $e$ be any helper extraction function with the extraction function properties, and let $trans = extract\_helpers(e)$.

If the program $prg$ has no overlapping lhss, statement (2) holds for $trans$.

\begin{proof} By induction on the derivation $\mathcal{D}$ of $\langle s \rangle \longrightarrow_{\langle prg \rangle} \langle t \rangle$, with $s \not\sim t$.

\begin{enumerate}
\item \textbf{``Subst" case}:

\begin{prooftree}
\AxiomC{$\langle s \rangle =^? q \searrow \sigma$ with $(q, s') \in \textrm{Rules}(\langle prg \rangle)$}
\UnaryInfC{$s \longrightarrow_{\langle prg \rangle} s'[\sigma]$}
\end{prooftree}

with $s'[\sigma] = t$; the reduction-relevant subterms of $s$ are values.

By the extraction function properties, since $s \not\sim t$, it can only be the case that $`` q = s' " = \zeta$ for the $\zeta$ in $\langle r \rangle^e$. Choose $\widetilde{s} := q_r[\sigma]$ and $\widetilde{t} := t_r[\sigma]$.

\item \textbf{``Cong" case}:

\begin{prooftree}
\AxiomC{$s' \longrightarrow_{\langle prg \rangle} t'$}
\RightLabel{Cong}
\UnaryInfC{$\mathcal{E}[s'] \longrightarrow_{\langle prg \rangle} \mathcal{E}[t']$}
\end{prooftree}

with $\mathcal{E}[s'] = s$ and $\mathcal{E}[t'] = t$. Because $\mathcal{E}[s'] \not\sim \mathcal{E}[t']$, it follows that $s' \not\sim t'$.

By the induction hypothesis we have $\widetilde{s'} \longrightarrow_{prg} \widetilde{t'}$, for some $\widetilde{s'} \sim s'$ and $\widetilde{t'} \sim t'$. Apply the congruence rule to get the desired
\begin{equation*}
s = \mathcal{E}[s'] \sim \widetilde{\mathcal{E}}[\widetilde{s'}] \longrightarrow_{prg} \widetilde{\mathcal{E}}[\widetilde{t'}] \sim \mathcal{E}[t'] = t,
\end{equation*}
for an $\widetilde{\mathcal{E}} \sim \mathcal{E}$ with all names declared in $prg$, which, for each extraction function, exists by the definition of its equivalence relation. Also by this definition, $\widetilde{\mathcal{E}}$ is unique, and for a $\mathcal{E}[s']$ of the form
\begin{equation*}
fun(t^0_1, ..., t^0_{n_0}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k})
\end{equation*}
$\widetilde{\mathcal{E}}[\widetilde{s'}]$ has the form
\begin{equation*}
fun'(s^0_1, ..., s^0_{n'_0}).des'_1(s^0_1, ..., s^0_{n'_1})...des'_{k'}(s^0_1, ..., s^0_{n'_{k'}}).des_1(t^1_1, ..., t^1_{n_1})...des_k(t^k_1, ..., t^k_{n_k}),
\end{equation*}
where each of the $s^i_j$ is equivalent to exactly one of the $t^0_i$. Thus, it actually is an evaluation context in $prg$, i.e., all of its reduction-relevant subterms left of the hole are irreducible in $prg$. To see this, suppose such a subterm reduced in $prg$, then, by the second extraction function property, the equivalent term among the $t^0_i$ would reduce in $\langle prg \rangle$, contrary to the fact that it is a value in $\langle prg \rangle$ because it is to the left of the hole in $\mathcal{E}$.

\end{enumerate}

\end{proof}

\end{proposition}

\section{Building blocks}

Each of the extraction functions defined below are lifted to programs with $extract\_helpers$ and then recursively composed to build the preprocessing steps of de- and refunctionalization.

\subsection{Destructor extraction}

\begin{figure}
\vspace{2.4in}
\begin{alignat*}{3}
& \langle `` q.des(\overline{p}) = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` q =  \langle q \rangle^{\sim}_{prg} ", \big\langle \langle q \rangle^{hsig}_{prg}, `` \langle q \rangle^{\sim}_{prg}.des(\overline{p}) = t  " \big\rangle \big\rangle \span\span \\
& \langle `` fun(\overline{p}) = t " \rangle^{extract\_des}_{prg} &= &\big\langle `` fun(\overline{p}) = t " \big\rangle \span\span
\end{alignat*}
\caption{Extraction function $extract\_des$.}
\end{figure}

The destructor extraction function is called $extract\_des$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg^0 \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_des$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(\langle q \rangle^{vars}),& \text{if $q.des(\overline{p})$ is a lhs in $prg$} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

Destructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\begin{lemma}

$extract\_des$ satisfies the first extraction function property.

\begin{proof}

Let $r$ be the equation in $prg$ used in $s \longrightarrow^{\textrm{Subst}}_{prg} t$. We know that an actual transformation of $r$ to $\epsilon_r, \zeta_r$ has taken place, because $r$ doesn't exist in $\langle prg \rangle$. From the definition of $extract\_helpers$ and $extract\_des$ we thus know that $q_r$ is a destructor copattern. By inversion, we know the form of $s$ is $s^0.des(\overline{t})$ The desired sequence can be given as follows.
\begin{alignat*}{3}
s &\longrightarrow^* &s^0_{subv}.des(\overline{t}) = q_{\epsilon_r}[\sigma_\epsilon].des(\overline{t})\\
&\longrightarrow &t_{\epsilon_r}.des(\overline{t})\\
&\longrightarrow^*  &t_{\epsilon_r}.des(\overline{t_v}) = q_{\zeta_r}[\sigma_\zeta]\\
&\longrightarrow &t_{\zeta_r} =: \widetilde{t}
\end{alignat*}
The first multi-step part of the sequence is concerned with reducing the reduction-relevant subterms of $s^0$ to equivalent values. We have such a sequence by the third extraction property, because $s^0$ matches $q_{\epsilon_r}$, by the definition of $\epsilon_r$ and because $s = s^0.des(\overline{t})$ and $s$ matches $q_r$.

Similarly, the second multi-step part is concerned with reducing the $\overline{t}$ to equivalent values.

Now, the two one-step parts of the sequence are derived.
\begin{enumerate}
\item The first step is derived as given below.
\begin{prooftree}
\AxiomC{$s^0_{subv} =^? q_{\epsilon_r} \searrow \sigma_\epsilon$}
\RightLabel{\scriptsize Subst with $\epsilon_r$}
\UnaryInfC{$s^0_{subv} \longrightarrow t_{\epsilon_r}[\sigma_\epsilon]$}
\RightLabel{\scriptsize Cong}
\UnaryInfC{$\mathcal{E}[s^0_{subv}] \longrightarrow \mathcal{E}[t_{\epsilon_r}[\sigma_\epsilon]]$}
\end{prooftree}
with $\mathcal{E} = [].des(\overline{t})$. $s^0_{subv}$ matches $q_{\epsilon_r}$ because $s = s^0.des(\overline{t})$ and $q_r = q_{\epsilon_r}.des(\overline{p})$ and $s$ matches $q_r$. The two sides of $\epsilon_r$ are equivalent by definition, thus $s^0_{subv}$ and $t_{\epsilon_r}[\sigma_\epsilon]$ are, too.

\item The second step is derived as given below.
\begin{prooftree}
\AxiomC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) =^? q_{\zeta_r} \searrow \sigma_\zeta$}
\RightLabel{\scriptsize Subst with $\zeta_r$}
\UnaryInfC{$t_{\epsilon_r}[\sigma_\epsilon].des(\overline{t_v}) \longrightarrow t_{\zeta_r}[\sigma_\zeta]$}
\end{prooftree}
The relevant subterms of $s^0_{subv}$ were values, thus also the terms that $\sigma_\epsilon$ substituted with. And $t_{\epsilon_r}[\sigma_\epsilon]$ contains no reduction-relevant subterms, as well. $t_[\epsilon_r]$ matches $q_{\zeta_r}$ by the definition of $\epsilon_r$ and $\zeta_r$. Because $t_{\epsilon_r}[\sigma_\epsilon] = q_{\zeta_r}[\sigma_\zeta]$ is equivalent to $s = q_r[\sigma]$, $t = t_r[\sigma]$ is equivalent to $t_{\zeta_r}[\sigma_\zeta] \sim t_r[\sigma_\zeta]$.

\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the second extraction function property.

\begin{proof}

From the first extraction function property, it is already clear that $s$ itself reduces in $\langle prg \rangle$ if it does in $prg$. It suffices to shown that the $\widetilde{s}$ match a lhs of $\langle prg \rangle$, because if a reduction-relevant reducible subterm prevents the reduction of $\widetilde{s}$ by the ``Subst" rule, it is still the case that $\widetilde{s}$ is reducible, because of this subterm.

Now, this lhs of $\langle prg \rangle$ that $\widetilde{s}$ matches will be specified. All terms $\widetilde{s} \neq s$ equivalent to $s$ have the following form by the definition of the equivalence relation:
\begin{equation*}
\langle \textrm{extract}, \langle q \rangle^{name\_pattern}, prg^0 \rangle^{autogen}(\langle q \rangle^{vars})[\sigma].\overline{des(\overline{p}[\sigma])},
\end{equation*}
for some $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, and its equation $r$ is actually transformed to $\langle r \rangle^e$ containing $\epsilon_r, \zeta_r$. $q_{\zeta_r}$ is defined in precisely such a way that $\widetilde{s}$, with its form as given above, matches it, if it has exactly one top-level destructor call ($des_1$).

If it has more than one top-level destructor calls, a prefix of $\widetilde{s}$ matches $q_{\zeta_r}$. If a  possible reduction by the ``Cong" rule were prevented by another possible reduction by the ``Subst" rule, $\widetilde{s}$ would still reduce anyway.

Finally, if $\widetilde{s}$ had no top-level destructor calls, i.e., it is an application of the helper function, then there would exist equations in $prg^0$ which overlap. To see this, consider the form of $s \sim \widetilde{s}$: It matches a $q$ such that $q.des_1(\overline{p})$ is a lhs in $prg$, as stated above. $q$ 

\end{proof}

\end{lemma}

\begin{lemma}

$extract\_des$ satisfies the third extraction function property.

\begin{proof}

First, note that by the definition of extract helper, two equations in $\langle prg \rangle$ results from the application of $e$ to an equation $r$ in $prg$; specifically, they are the two equations $\epsilon_r, \zeta_r$ contained in $\langle r \rangle^e$. The other equations are taken over from $prg$ unchanged. By the third extraction function property, the two sides of $\epsilon_r$ are equivalent, and $\zeta_r$ is equivalent to the equation $r$ of $prg$, i.e., $q_{\zeta_r} \sim q_r$ and $t_{\zeta_r} \sim t_r$.

Suppose the lemma holds for the reduction-relevant subterms of $s$ (the induction hypothesis). This lets us reduce these subterms of $s$ to equivalent values (in $\langle prg \rangle$) first (from left to right). Let $s_0$ be the result of these reductions; it is equivalent to s. The desired reduction sequence is
\begin{equation*}
s \longrightarrow^* s_0 (\longrightarrow s_v).
\end{equation*}
The initial part of the reduction is derived as described above. The final step is only necessary if $s_0$ can still reduce in $\langle prg \rangle$. This can only be the case if it matches $q_{\epsilon_r}$, because (a) it can't match $q_{\zeta_r}$ since its function name isn't declared in $prg^0$, and (b) if it matched an unchanged equation of $prg$, it wouldn't be a value in $prg$. Thus, if at all, $s_0$ reduces by the ``Subst" rule for $\epsilon_r$ to a $s_v$; the two sides of $\epsilon_r$ are equivalent and therefore $s_0 \sim s_v$. $s_v$ can't reduce any further, because it is an instance of $t_{\epsilon_r}$, which has no destructor, and has a function name not declared in $prg^0$, and these functions only have definitions with destructor copattern lhss. If it doesn't reduce, set $s_v := s_0$.

\end{proof}

\end{lemma}

\subsection{Constructor extraction}

\begin{figure}
\vspace{2.4in}
\[
    \langle `` q = t " \rangle^{extract\_des}_{prg} =\\
\begin{cases}
    \big\langle `` q^{-con} =  \langle q \rangle^{\sim}_{prg} ", \big\langle \langle q \rangle^{hsig}_{prg}, `` \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^-}) = t  " \big\rangle \big\rangle,& \text{if $q$ contains a constructor other than a left outer-most} \\
   \big\langle `` fun(\overline{p}) = t " \big\rangle,& \text{otherwise}
\end{cases}
\]
\caption{Extraction function $extract\_con$.}
\end{figure}

The constructor extraction function is called $extract\_con$ and defined in Figure 3-1. The definition uses functions defined in the next paragraph.

For each copattern $q$ and program $prg$, define the helper function name for a given copattern
\begin{equation*}
\langle q \rangle^{hname}_{prg} := \langle \langle q^{-con} \rangle^{name\_pattern}, prg^0 \rangle^{autogen}
\end{equation*}
and the respective helper function signature
\begin{equation*}
\langle q \rangle^{hsig}_{prg} := \langle q \rangle^{hname}_{prg}(\langle q^{-con}_{vars^+} \rangle^{vartypes}_{prg}): \langle q \rangle^{rtype}_{prg}.
\end{equation*}

The equivalent function for $extract\_con$ is defined as follows:
\[
    \langle q \rangle^{\sim}_{prg} :=
\begin{cases}
    \langle q \rangle^{hname}_{prg}(q^{-con}_{vars^+}),& \text{if $q$ contains a constructor other than a left outer-most} \\
    q,                                                                                      & \text{otherwise}
\end{cases}
\]

Constructor extraction satisfies the extraction function properties. This is proven in the following three lemmas.

\subsection{Extraction of all constructors from a single-destructor copattern}

...

\section{Common pretransformations}

...

\subsection{From order-dependent to order-independent}

...

\subsection{Aligning patterns}

...


\section{Defunctionalization}

...

\section{Refunctionalization}

...
